
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
	
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

    movw $0x1234,0x472			# warm boot	
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
	
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax	
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4                   	.byte 0xe4

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 b0 22 04 80 	movabs $0x800422b038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 b0 22 04 80 	movabs $0x800422b000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 9a 00 20 04 80 	movabs $0x800420009a,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 20          	sub    $0x20,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 80 b7 22 04 80 	movabs $0x800422b780,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 0e 5f 21 04 80 	movabs $0x8004215f0e,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	90                   	nop
  8004200098:	5d                   	pop    %rbp
  8004200099:	c3                   	retq   

000000800420009a <i386_init>:



void
i386_init(void)
{
  800420009a:	55                   	push   %rbp
  800420009b:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  800420009e:	48 ba 10 60 3e 04 80 	movabs $0x80043e6010,%rdx
  80042000a5:	00 00 00 
  80042000a8:	48 b8 f0 15 36 04 80 	movabs $0x80043615f0,%rax
  80042000af:	00 00 00 
  80042000b2:	48 29 c2             	sub    %rax,%rdx
  80042000b5:	48 89 d0             	mov    %rdx,%rax
  80042000b8:	48 89 c2             	mov    %rax,%rdx
  80042000bb:	be 00 00 00 00       	mov    $0x0,%esi
  80042000c0:	48 bf f0 15 36 04 80 	movabs $0x80043615f0,%rdi
  80042000c7:	00 00 00 
  80042000ca:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  80042000d1:	00 00 00 
  80042000d4:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042000d6:	48 b8 49 11 20 04 80 	movabs $0x8004201149,%rax
  80042000dd:	00 00 00 
  80042000e0:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  80042000e2:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042000e7:	48 bf 40 62 21 04 80 	movabs $0x8004216240,%rdi
  80042000ee:	00 00 00 
  80042000f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000f6:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042000fd:	00 00 00 
  8004200100:	ff d2                	callq  *%rdx

	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end);
  8004200102:	48 b8 10 60 3e 04 80 	movabs $0x80043e6010,%rax
  8004200109:	00 00 00 
  800420010c:	48 89 c6             	mov    %rax,%rsi
  800420010f:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200116:	00 00 00 
  8004200119:	48 b8 d2 45 21 04 80 	movabs $0x80042145d2,%rax
  8004200120:	00 00 00 
  8004200123:	ff d0                	callq  *%rax
  8004200125:	48 89 c2             	mov    %rax,%rdx
  8004200128:	48 b8 08 37 36 04 80 	movabs $0x8004363708,%rax
  800420012f:	00 00 00 
  8004200132:	48 89 10             	mov    %rdx,(%rax)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200135:	b8 00 00 00 00       	mov    $0x0,%eax
  800420013a:	48 ba a5 23 20 04 80 	movabs $0x80042023a5,%rdx
  8004200141:	00 00 00 
  8004200144:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  8004200146:	48 b8 a2 78 20 04 80 	movabs $0x80042078a2,%rax
  800420014d:	00 00 00 
  8004200150:	ff d0                	callq  *%rax
	trap_init();
  8004200152:	48 b8 83 8f 20 04 80 	movabs $0x8004208f83,%rax
  8004200159:	00 00 00 
  800420015c:	ff d0                	callq  *%rax

	// Lab 4 multiprocessor initialization functions
	mp_init();
  800420015e:	48 b8 67 55 21 04 80 	movabs $0x8004215567,%rax
  8004200165:	00 00 00 
  8004200168:	ff d0                	callq  *%rax
	lapic_init();
  800420016a:	48 b8 6d 59 21 04 80 	movabs $0x800421596d,%rax
  8004200171:	00 00 00 
  8004200174:	ff d0                	callq  *%rax

	// Lab 4 multitasking initialization functions
	pic_init();
  8004200176:	48 b8 36 8b 20 04 80 	movabs $0x8004208b36,%rax
  800420017d:	00 00 00 
  8004200180:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:

	lock_kernel();
  8004200182:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200189:	00 00 00 
  800420018c:	ff d0                	callq  *%rax

	// Starting non-boot CPUs
	boot_aps();
  800420018e:	48 b8 c1 01 20 04 80 	movabs $0x80042001c1,%rax
  8004200195:	00 00 00 
  8004200198:	ff d0                	callq  *%rax
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
#else
	// Touch all you want.

	ENV_CREATE(user_sendpage,ENV_TYPE_USER);
  800420019a:	be 00 00 00 00       	mov    $0x0,%esi
  800420019f:	48 bf 28 a8 31 04 80 	movabs $0x800431a828,%rdi
  80042001a6:	00 00 00 
  80042001a9:	48 b8 3b 80 20 04 80 	movabs $0x800420803b,%rax
  80042001b0:	00 00 00 
  80042001b3:	ff d0                	callq  *%rax


#endif // TEST*

	// Schedule and run the first user environment!
	sched_yield();
  80042001b5:	48 b8 2e c1 20 04 80 	movabs $0x800420c12e,%rax
  80042001bc:	00 00 00 
  80042001bf:	ff d0                	callq  *%rax

00000080042001c1 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  80042001c1:	55                   	push   %rbp
  80042001c2:	48 89 e5             	mov    %rsp,%rbp
  80042001c5:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  80042001c9:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  80042001d0:	00 
  80042001d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042001d5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042001d9:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042001dc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042001df:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042001e6:	00 00 00 
  80042001e9:	48 8b 00             	mov    (%rax),%rax
  80042001ec:	48 39 c2             	cmp    %rax,%rdx
  80042001ef:	72 32                	jb     8004200223 <boot_aps+0x62>
  80042001f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042001f5:	48 89 c1             	mov    %rax,%rcx
  80042001f8:	48 ba 60 62 21 04 80 	movabs $0x8004216260,%rdx
  80042001ff:	00 00 00 
  8004200202:	be 69 00 00 00       	mov    $0x69,%esi
  8004200207:	48 bf 83 62 21 04 80 	movabs $0x8004216283,%rdi
  800420020e:	00 00 00 
  8004200211:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200216:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420021d:	00 00 00 
  8004200220:	41 ff d0             	callq  *%r8
  8004200223:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420022a:	00 00 00 
  800420022d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200231:	48 01 d0             	add    %rdx,%rax
  8004200234:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  8004200238:	48 ba 8e 50 21 04 80 	movabs $0x800421508e,%rdx
  800420023f:	00 00 00 
  8004200242:	48 b8 a8 4f 21 04 80 	movabs $0x8004214fa8,%rax
  8004200249:	00 00 00 
  800420024c:	48 29 c2             	sub    %rax,%rdx
  800420024f:	48 89 d0             	mov    %rdx,%rax
  8004200252:	48 89 c2             	mov    %rax,%rdx
  8004200255:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004200259:	48 be a8 4f 21 04 80 	movabs $0x8004214fa8,%rsi
  8004200260:	00 00 00 
  8004200263:	48 89 c7             	mov    %rax,%rdi
  8004200266:	48 b8 02 ed 20 04 80 	movabs $0x800420ed02,%rax
  800420026d:	00 00 00 
  8004200270:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200272:	48 b8 20 50 36 04 80 	movabs $0x8004365020,%rax
  8004200279:	00 00 00 
  800420027c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004200280:	e9 10 01 00 00       	jmpq   8004200395 <boot_aps+0x1d4>
		if (c == cpus + cpunum())  // We've started already.
  8004200285:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420028c:	00 00 00 
  800420028f:	ff d0                	callq  *%rax
  8004200291:	48 98                	cltq   
  8004200293:	48 c1 e0 03          	shl    $0x3,%rax
  8004200297:	48 89 c2             	mov    %rax,%rdx
  800420029a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420029e:	48 29 c2             	sub    %rax,%rdx
  80042002a1:	48 b8 20 50 36 04 80 	movabs $0x8004365020,%rax
  80042002a8:	00 00 00 
  80042002ab:	48 01 d0             	add    %rdx,%rax
  80042002ae:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042002b2:	0f 84 d7 00 00 00    	je     800420038f <boot_aps+0x1ce>
			continue;

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  80042002b8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042002bc:	48 b8 20 50 36 04 80 	movabs $0x8004365020,%rax
  80042002c3:	00 00 00 
  80042002c6:	48 29 c2             	sub    %rax,%rdx
  80042002c9:	48 89 d0             	mov    %rdx,%rax
  80042002cc:	48 c1 f8 03          	sar    $0x3,%rax
  80042002d0:	48 89 c2             	mov    %rax,%rdx
  80042002d3:	48 b8 ef ee ee ee ee 	movabs $0xeeeeeeeeeeeeeeef,%rax
  80042002da:	ee ee ee 
  80042002dd:	48 0f af c2          	imul   %rdx,%rax
  80042002e1:	48 c1 e0 10          	shl    $0x10,%rax
  80042002e5:	48 89 c2             	mov    %rax,%rdx
  80042002e8:	48 b8 00 60 36 04 80 	movabs $0x8004366000,%rax
  80042002ef:	00 00 00 
  80042002f2:	48 01 d0             	add    %rdx,%rax
  80042002f5:	48 8d 90 00 00 01 00 	lea    0x10000(%rax),%rdx
  80042002fc:	48 b8 18 37 36 04 80 	movabs $0x8004363718,%rax
  8004200303:	00 00 00 
  8004200306:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  8004200309:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420030d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004200311:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004200318:	00 00 00 
  800420031b:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800420031f:	77 32                	ja     8004200353 <boot_aps+0x192>
  8004200321:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200325:	48 89 c1             	mov    %rax,%rcx
  8004200328:	48 ba 90 62 21 04 80 	movabs $0x8004216290,%rdx
  800420032f:	00 00 00 
  8004200332:	be 73 00 00 00       	mov    $0x73,%esi
  8004200337:	48 bf 83 62 21 04 80 	movabs $0x8004216283,%rdi
  800420033e:	00 00 00 
  8004200341:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200346:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420034d:	00 00 00 
  8004200350:	41 ff d0             	callq  *%r8
  8004200353:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420035a:	ff ff ff 
  800420035d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200361:	48 01 d0             	add    %rdx,%rax
  8004200364:	89 c2                	mov    %eax,%edx
  8004200366:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420036a:	0f b6 00             	movzbl (%rax),%eax
  800420036d:	0f b6 c0             	movzbl %al,%eax
  8004200370:	89 d6                	mov    %edx,%esi
  8004200372:	89 c7                	mov    %eax,%edi
  8004200374:	48 b8 e5 5b 21 04 80 	movabs $0x8004215be5,%rax
  800420037b:	00 00 00 
  800420037e:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  8004200380:	90                   	nop
  8004200381:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200385:	8b 40 04             	mov    0x4(%rax),%eax
  8004200388:	83 f8 01             	cmp    $0x1,%eax
  800420038b:	75 f4                	jne    8004200381 <boot_aps+0x1c0>
  800420038d:	eb 01                	jmp    8004200390 <boot_aps+0x1cf>
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
		if (c == cpus + cpunum())  // We've started already.
			continue;
  800420038f:	90                   	nop

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200390:	48 83 45 f8 78       	addq   $0x78,-0x8(%rbp)
  8004200395:	48 b8 e8 53 36 04 80 	movabs $0x80043653e8,%rax
  800420039c:	00 00 00 
  800420039f:	8b 00                	mov    (%rax),%eax
  80042003a1:	48 98                	cltq   
  80042003a3:	48 c1 e0 03          	shl    $0x3,%rax
  80042003a7:	48 89 c2             	mov    %rax,%rdx
  80042003aa:	48 c1 e2 04          	shl    $0x4,%rdx
  80042003ae:	48 29 c2             	sub    %rax,%rdx
  80042003b1:	48 b8 20 50 36 04 80 	movabs $0x8004365020,%rax
  80042003b8:	00 00 00 
  80042003bb:	48 01 d0             	add    %rdx,%rax
  80042003be:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042003c2:	0f 87 bd fe ff ff    	ja     8004200285 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  80042003c8:	90                   	nop
  80042003c9:	c9                   	leaveq 
  80042003ca:	c3                   	retq   

00000080042003cb <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  80042003cb:	55                   	push   %rbp
  80042003cc:	48 89 e5             	mov    %rsp,%rbp
  80042003cf:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  80042003d3:	48 b8 20 37 36 04 80 	movabs $0x8004363720,%rax
  80042003da:	00 00 00 
  80042003dd:	48 8b 00             	mov    (%rax),%rax
  80042003e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  80042003e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003e8:	0f 22 d8             	mov    %rax,%cr3

	cprintf("SMP: CPU %d starting\n", cpunum());
  80042003eb:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  80042003f2:	00 00 00 
  80042003f5:	ff d0                	callq  *%rax
  80042003f7:	89 c6                	mov    %eax,%esi
  80042003f9:	48 bf b4 62 21 04 80 	movabs $0x80042162b4,%rdi
  8004200400:	00 00 00 
  8004200403:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200408:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420040f:	00 00 00 
  8004200412:	ff d2                	callq  *%rdx

	lapic_init();
  8004200414:	48 b8 6d 59 21 04 80 	movabs $0x800421596d,%rax
  800420041b:	00 00 00 
  800420041e:	ff d0                	callq  *%rax
	env_init_percpu();
  8004200420:	48 b8 ab 79 20 04 80 	movabs $0x80042079ab,%rax
  8004200427:	00 00 00 
  800420042a:	ff d0                	callq  *%rax
	trap_init_percpu();
  800420042c:	48 b8 cc ab 20 04 80 	movabs $0x800420abcc,%rax
  8004200433:	00 00 00 
  8004200436:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  8004200438:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420043f:	00 00 00 
  8004200442:	ff d0                	callq  *%rax
  8004200444:	48 98                	cltq   
  8004200446:	48 89 c2             	mov    %rax,%rdx
  8004200449:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004200450:	00 
  8004200451:	48 89 c2             	mov    %rax,%rdx
  8004200454:	48 89 d0             	mov    %rdx,%rax
  8004200457:	48 c1 e0 04          	shl    $0x4,%rax
  800420045b:	48 29 d0             	sub    %rdx,%rax
  800420045e:	48 ba 20 50 36 04 80 	movabs $0x8004365020,%rdx
  8004200465:	00 00 00 
  8004200468:	48 01 d0             	add    %rdx,%rax
  800420046b:	48 83 c0 04          	add    $0x4,%rax
  800420046f:	be 01 00 00 00       	mov    $0x1,%esi
  8004200474:	48 89 c7             	mov    %rax,%rdi
  8004200477:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  800420047e:	00 00 00 
  8004200481:	ff d0                	callq  *%rax
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:

	lock_kernel();
  8004200483:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  800420048a:	00 00 00 
  800420048d:	ff d0                	callq  *%rax
	sched_yield();
  800420048f:	48 b8 2e c1 20 04 80 	movabs $0x800420c12e,%rax
  8004200496:	00 00 00 
  8004200499:	ff d0                	callq  *%rax

000000800420049b <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  800420049b:	55                   	push   %rbp
  800420049c:	48 89 e5             	mov    %rsp,%rbp
  800420049f:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042004a6:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042004ad:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042004b3:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  80042004ba:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042004c1:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042004c8:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042004cf:	84 c0                	test   %al,%al
  80042004d1:	74 20                	je     80042004f3 <_panic+0x58>
  80042004d3:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042004d7:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042004db:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042004df:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042004e3:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042004e7:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042004eb:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042004ef:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	if (panicstr)
  80042004f3:	48 b8 10 37 36 04 80 	movabs $0x8004363710,%rax
  80042004fa:	00 00 00 
  80042004fd:	48 8b 00             	mov    (%rax),%rax
  8004200500:	48 85 c0             	test   %rax,%rax
  8004200503:	74 05                	je     800420050a <_panic+0x6f>
		goto dead;
  8004200505:	e9 ba 00 00 00       	jmpq   80042005c4 <_panic+0x129>
	panicstr = fmt;
  800420050a:	48 b8 10 37 36 04 80 	movabs $0x8004363710,%rax
  8004200511:	00 00 00 
  8004200514:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420051b:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  800420051e:	fa                   	cli    
  800420051f:	fc                   	cld    

	va_start(ap, fmt);
  8004200520:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200527:	00 00 00 
  800420052a:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200531:	00 00 00 
  8004200534:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200538:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420053f:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200546:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  800420054d:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004200554:	00 00 00 
  8004200557:	ff d0                	callq  *%rax
  8004200559:	89 c6                	mov    %eax,%esi
  800420055b:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200561:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004200568:	89 d1                	mov    %edx,%ecx
  800420056a:	48 89 c2             	mov    %rax,%rdx
  800420056d:	48 bf d0 62 21 04 80 	movabs $0x80042162d0,%rdi
  8004200574:	00 00 00 
  8004200577:	b8 00 00 00 00       	mov    $0x0,%eax
  800420057c:	49 b8 0a 8e 20 04 80 	movabs $0x8004208e0a,%r8
  8004200583:	00 00 00 
  8004200586:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  8004200589:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200590:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200597:	48 89 d6             	mov    %rdx,%rsi
  800420059a:	48 89 c7             	mov    %rax,%rdi
  800420059d:	48 b8 ab 8d 20 04 80 	movabs $0x8004208dab,%rax
  80042005a4:	00 00 00 
  80042005a7:	ff d0                	callq  *%rax
	cprintf("\n");
  80042005a9:	48 bf f2 62 21 04 80 	movabs $0x80042162f2,%rdi
  80042005b0:	00 00 00 
  80042005b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005b8:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042005bf:	00 00 00 
  80042005c2:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  80042005c4:	bf 00 00 00 00       	mov    $0x0,%edi
  80042005c9:	48 b8 4e 18 20 04 80 	movabs $0x800420184e,%rax
  80042005d0:	00 00 00 
  80042005d3:	ff d0                	callq  *%rax
  80042005d5:	eb ed                	jmp    80042005c4 <_panic+0x129>

00000080042005d7 <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  80042005d7:	55                   	push   %rbp
  80042005d8:	48 89 e5             	mov    %rsp,%rbp
  80042005db:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042005e2:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042005e9:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042005ef:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  80042005f6:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042005fd:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200604:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420060b:	84 c0                	test   %al,%al
  800420060d:	74 20                	je     800420062f <_warn+0x58>
  800420060f:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200613:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200617:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420061b:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420061f:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200623:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200627:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420062b:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420062f:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004200636:	00 00 00 
  8004200639:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200640:	00 00 00 
  8004200643:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200647:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420064e:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200655:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  800420065c:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200662:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004200669:	48 89 c6             	mov    %rax,%rsi
  800420066c:	48 bf f4 62 21 04 80 	movabs $0x80042162f4,%rdi
  8004200673:	00 00 00 
  8004200676:	b8 00 00 00 00       	mov    $0x0,%eax
  800420067b:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  8004200682:	00 00 00 
  8004200685:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  8004200687:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420068e:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200695:	48 89 d6             	mov    %rdx,%rsi
  8004200698:	48 89 c7             	mov    %rax,%rdi
  800420069b:	48 b8 ab 8d 20 04 80 	movabs $0x8004208dab,%rax
  80042006a2:	00 00 00 
  80042006a5:	ff d0                	callq  *%rax
	cprintf("\n");
  80042006a7:	48 bf f2 62 21 04 80 	movabs $0x80042162f2,%rdi
  80042006ae:	00 00 00 
  80042006b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006b6:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042006bd:	00 00 00 
  80042006c0:	ff d2                	callq  *%rdx
	va_end(ap);
}
  80042006c2:	90                   	nop
  80042006c3:	c9                   	leaveq 
  80042006c4:	c3                   	retq   

00000080042006c5 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  80042006c5:	55                   	push   %rbp
  80042006c6:	48 89 e5             	mov    %rsp,%rbp
  80042006c9:	48 83 ec 20          	sub    $0x20,%rsp
  80042006cd:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042006d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042006d7:	89 c2                	mov    %eax,%edx
  80042006d9:	ec                   	in     (%dx),%al
  80042006da:	88 45 ec             	mov    %al,-0x14(%rbp)
  80042006dd:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%rbp)
  80042006e4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042006e7:	89 c2                	mov    %eax,%edx
  80042006e9:	ec                   	in     (%dx),%al
  80042006ea:	88 45 ed             	mov    %al,-0x13(%rbp)
  80042006ed:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  80042006f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042006f7:	89 c2                	mov    %eax,%edx
  80042006f9:	ec                   	in     (%dx),%al
  80042006fa:	88 45 ee             	mov    %al,-0x12(%rbp)
  80042006fd:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%rbp)
  8004200704:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200707:	89 c2                	mov    %eax,%edx
  8004200709:	ec                   	in     (%dx),%al
  800420070a:	88 45 ef             	mov    %al,-0x11(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  800420070d:	90                   	nop
  800420070e:	c9                   	leaveq 
  800420070f:	c3                   	retq   

0000008004200710 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200710:	55                   	push   %rbp
  8004200711:	48 89 e5             	mov    %rsp,%rbp
  8004200714:	48 83 ec 10          	sub    $0x10,%rsp
  8004200718:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)
  800420071f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200722:	89 c2                	mov    %eax,%edx
  8004200724:	ec                   	in     (%dx),%al
  8004200725:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004200728:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  800420072c:	0f b6 c0             	movzbl %al,%eax
  800420072f:	83 e0 01             	and    $0x1,%eax
  8004200732:	85 c0                	test   %eax,%eax
  8004200734:	75 07                	jne    800420073d <serial_proc_data+0x2d>
		return -1;
  8004200736:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420073b:	eb 17                	jmp    8004200754 <serial_proc_data+0x44>
  800420073d:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200744:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200747:	89 c2                	mov    %eax,%edx
  8004200749:	ec                   	in     (%dx),%al
  800420074a:	88 45 f6             	mov    %al,-0xa(%rbp)
	return data;
  800420074d:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
	return inb(COM1+COM_RX);
  8004200751:	0f b6 c0             	movzbl %al,%eax
}
  8004200754:	c9                   	leaveq 
  8004200755:	c3                   	retq   

0000008004200756 <serial_intr>:

void
serial_intr(void)
{
  8004200756:	55                   	push   %rbp
  8004200757:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  800420075a:	48 b8 00 20 36 04 80 	movabs $0x8004362000,%rax
  8004200761:	00 00 00 
  8004200764:	0f b6 00             	movzbl (%rax),%eax
  8004200767:	84 c0                	test   %al,%al
  8004200769:	74 16                	je     8004200781 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  800420076b:	48 bf 10 07 20 04 80 	movabs $0x8004200710,%rdi
  8004200772:	00 00 00 
  8004200775:	48 b8 ca 0f 20 04 80 	movabs $0x8004200fca,%rax
  800420077c:	00 00 00 
  800420077f:	ff d0                	callq  *%rax
}
  8004200781:	90                   	nop
  8004200782:	5d                   	pop    %rbp
  8004200783:	c3                   	retq   

0000008004200784 <serial_putc>:

static void
serial_putc(int c)
{
  8004200784:	55                   	push   %rbp
  8004200785:	48 89 e5             	mov    %rsp,%rbp
  8004200788:	48 83 ec 18          	sub    $0x18,%rsp
  800420078c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;

	for (i = 0;
  800420078f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200796:	eb 10                	jmp    80042007a8 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  8004200798:	48 b8 c5 06 20 04 80 	movabs $0x80042006c5,%rax
  800420079f:	00 00 00 
  80042007a2:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  80042007a4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042007a8:	c7 45 f4 fd 03 00 00 	movl   $0x3fd,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007af:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042007b2:	89 c2                	mov    %eax,%edx
  80042007b4:	ec                   	in     (%dx),%al
  80042007b5:	88 45 f3             	mov    %al,-0xd(%rbp)
	return data;
  80042007b8:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007bc:	0f b6 c0             	movzbl %al,%eax
  80042007bf:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  80042007c2:	85 c0                	test   %eax,%eax
  80042007c4:	75 09                	jne    80042007cf <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  80042007c6:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042007cd:	7e c9                	jle    8004200798 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  80042007cf:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042007d2:	0f b6 c0             	movzbl %al,%eax
  80042007d5:	c7 45 f8 f8 03 00 00 	movl   $0x3f8,-0x8(%rbp)
  80042007dc:	88 45 f2             	mov    %al,-0xe(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042007df:	0f b6 45 f2          	movzbl -0xe(%rbp),%eax
  80042007e3:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042007e6:	ee                   	out    %al,(%dx)
}
  80042007e7:	90                   	nop
  80042007e8:	c9                   	leaveq 
  80042007e9:	c3                   	retq   

00000080042007ea <serial_init>:

static void
serial_init(void)
{
  80042007ea:	55                   	push   %rbp
  80042007eb:	48 89 e5             	mov    %rsp,%rbp
  80042007ee:	48 83 ec 40          	sub    $0x40,%rsp
  80042007f2:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  80042007f9:	c6 45 ce 00          	movb   $0x0,-0x32(%rbp)
  80042007fd:	0f b6 45 ce          	movzbl -0x32(%rbp),%eax
  8004200801:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200804:	ee                   	out    %al,(%dx)
  8004200805:	c7 45 f8 fb 03 00 00 	movl   $0x3fb,-0x8(%rbp)
  800420080c:	c6 45 cf 80          	movb   $0x80,-0x31(%rbp)
  8004200810:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
  8004200814:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200817:	ee                   	out    %al,(%dx)
  8004200818:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)
  800420081f:	c6 45 d0 0c          	movb   $0xc,-0x30(%rbp)
  8004200823:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
  8004200827:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420082a:	ee                   	out    %al,(%dx)
  800420082b:	c7 45 f0 f9 03 00 00 	movl   $0x3f9,-0x10(%rbp)
  8004200832:	c6 45 d1 00          	movb   $0x0,-0x2f(%rbp)
  8004200836:	0f b6 45 d1          	movzbl -0x2f(%rbp),%eax
  800420083a:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420083d:	ee                   	out    %al,(%dx)
  800420083e:	c7 45 ec fb 03 00 00 	movl   $0x3fb,-0x14(%rbp)
  8004200845:	c6 45 d2 03          	movb   $0x3,-0x2e(%rbp)
  8004200849:	0f b6 45 d2          	movzbl -0x2e(%rbp),%eax
  800420084d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200850:	ee                   	out    %al,(%dx)
  8004200851:	c7 45 e8 fc 03 00 00 	movl   $0x3fc,-0x18(%rbp)
  8004200858:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  800420085c:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200860:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200863:	ee                   	out    %al,(%dx)
  8004200864:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  800420086b:	c6 45 d4 01          	movb   $0x1,-0x2c(%rbp)
  800420086f:	0f b6 45 d4          	movzbl -0x2c(%rbp),%eax
  8004200873:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200876:	ee                   	out    %al,(%dx)
  8004200877:	c7 45 e0 fd 03 00 00 	movl   $0x3fd,-0x20(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420087e:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004200881:	89 c2                	mov    %eax,%edx
  8004200883:	ec                   	in     (%dx),%al
  8004200884:	88 45 d5             	mov    %al,-0x2b(%rbp)
	return data;
  8004200887:	0f b6 45 d5          	movzbl -0x2b(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  800420088b:	3c ff                	cmp    $0xff,%al
  800420088d:	0f 95 c2             	setne  %dl
  8004200890:	48 b8 00 20 36 04 80 	movabs $0x8004362000,%rax
  8004200897:	00 00 00 
  800420089a:	88 10                	mov    %dl,(%rax)
  800420089c:	c7 45 dc fa 03 00 00 	movl   $0x3fa,-0x24(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008a3:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042008a6:	89 c2                	mov    %eax,%edx
  80042008a8:	ec                   	in     (%dx),%al
  80042008a9:	88 45 d6             	mov    %al,-0x2a(%rbp)
  80042008ac:	c7 45 d8 f8 03 00 00 	movl   $0x3f8,-0x28(%rbp)
  80042008b3:	8b 45 d8             	mov    -0x28(%rbp),%eax
  80042008b6:	89 c2                	mov    %eax,%edx
  80042008b8:	ec                   	in     (%dx),%al
  80042008b9:	88 45 d7             	mov    %al,-0x29(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

}
  80042008bc:	90                   	nop
  80042008bd:	c9                   	leaveq 
  80042008be:	c3                   	retq   

00000080042008bf <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  80042008bf:	55                   	push   %rbp
  80042008c0:	48 89 e5             	mov    %rsp,%rbp
  80042008c3:	48 83 ec 28          	sub    $0x28,%rsp
  80042008c7:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  80042008ca:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042008d1:	eb 10                	jmp    80042008e3 <lpt_putc+0x24>
		delay();
  80042008d3:	48 b8 c5 06 20 04 80 	movabs $0x80042006c5,%rax
  80042008da:	00 00 00 
  80042008dd:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  80042008df:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042008e3:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%rbp)
  80042008ea:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042008ed:	89 c2                	mov    %eax,%edx
  80042008ef:	ec                   	in     (%dx),%al
  80042008f0:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  80042008f3:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042008f7:	84 c0                	test   %al,%al
  80042008f9:	78 09                	js     8004200904 <lpt_putc+0x45>
  80042008fb:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200902:	7e cf                	jle    80042008d3 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  8004200904:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200907:	0f b6 c0             	movzbl %al,%eax
  800420090a:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%rbp)
  8004200911:	88 45 e8             	mov    %al,-0x18(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200914:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  8004200918:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420091b:	ee                   	out    %al,(%dx)
  800420091c:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%rbp)
  8004200923:	c6 45 e9 0d          	movb   $0xd,-0x17(%rbp)
  8004200927:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
  800420092b:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420092e:	ee                   	out    %al,(%dx)
  800420092f:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%rbp)
  8004200936:	c6 45 ea 08          	movb   $0x8,-0x16(%rbp)
  800420093a:	0f b6 45 ea          	movzbl -0x16(%rbp),%eax
  800420093e:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200941:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  8004200942:	90                   	nop
  8004200943:	c9                   	leaveq 
  8004200944:	c3                   	retq   

0000008004200945 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200945:	55                   	push   %rbp
  8004200946:	48 89 e5             	mov    %rsp,%rbp
  8004200949:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  800420094d:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200954:	00 00 00 
  8004200957:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  800420095b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420095f:	0f b7 00             	movzwl (%rax),%eax
  8004200962:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200966:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420096a:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  800420096f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200973:	0f b7 00             	movzwl (%rax),%eax
  8004200976:	66 3d 5a a5          	cmp    $0xa55a,%ax
  800420097a:	74 20                	je     800420099c <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  800420097c:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200983:	00 00 00 
  8004200986:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  800420098a:	48 b8 04 20 36 04 80 	movabs $0x8004362004,%rax
  8004200991:	00 00 00 
  8004200994:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  800420099a:	eb 1b                	jmp    80042009b7 <cga_init+0x72>
	} else {
		*cp = was;
  800420099c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042009a0:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80042009a4:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  80042009a7:	48 b8 04 20 36 04 80 	movabs $0x8004362004,%rax
  80042009ae:	00 00 00 
  80042009b1:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  80042009b7:	48 b8 04 20 36 04 80 	movabs $0x8004362004,%rax
  80042009be:	00 00 00 
  80042009c1:	8b 00                	mov    (%rax),%eax
  80042009c3:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042009c6:	c6 45 dc 0e          	movb   $0xe,-0x24(%rbp)
  80042009ca:	0f b6 45 dc          	movzbl -0x24(%rbp),%eax
  80042009ce:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042009d1:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  80042009d2:	48 b8 04 20 36 04 80 	movabs $0x8004362004,%rax
  80042009d9:	00 00 00 
  80042009dc:	8b 00                	mov    (%rax),%eax
  80042009de:	83 c0 01             	add    $0x1,%eax
  80042009e1:	89 45 e8             	mov    %eax,-0x18(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042009e4:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042009e7:	89 c2                	mov    %eax,%edx
  80042009e9:	ec                   	in     (%dx),%al
  80042009ea:	88 45 dd             	mov    %al,-0x23(%rbp)
	return data;
  80042009ed:	0f b6 45 dd          	movzbl -0x23(%rbp),%eax
  80042009f1:	0f b6 c0             	movzbl %al,%eax
  80042009f4:	c1 e0 08             	shl    $0x8,%eax
  80042009f7:	89 45 ec             	mov    %eax,-0x14(%rbp)
	outb(addr_6845, 15);
  80042009fa:	48 b8 04 20 36 04 80 	movabs $0x8004362004,%rax
  8004200a01:	00 00 00 
  8004200a04:	8b 00                	mov    (%rax),%eax
  8004200a06:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004200a09:	c6 45 de 0f          	movb   $0xf,-0x22(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200a0d:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004200a11:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200a14:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200a15:	48 b8 04 20 36 04 80 	movabs $0x8004362004,%rax
  8004200a1c:	00 00 00 
  8004200a1f:	8b 00                	mov    (%rax),%eax
  8004200a21:	83 c0 01             	add    $0x1,%eax
  8004200a24:	89 45 e0             	mov    %eax,-0x20(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a27:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004200a2a:	89 c2                	mov    %eax,%edx
  8004200a2c:	ec                   	in     (%dx),%al
  8004200a2d:	88 45 df             	mov    %al,-0x21(%rbp)
	return data;
  8004200a30:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200a34:	0f b6 c0             	movzbl %al,%eax
  8004200a37:	09 45 ec             	or     %eax,-0x14(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200a3a:	48 b8 08 20 36 04 80 	movabs $0x8004362008,%rax
  8004200a41:	00 00 00 
  8004200a44:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200a48:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200a4b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200a4e:	89 c2                	mov    %eax,%edx
  8004200a50:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200a57:	00 00 00 
  8004200a5a:	66 89 10             	mov    %dx,(%rax)
}
  8004200a5d:	90                   	nop
  8004200a5e:	c9                   	leaveq 
  8004200a5f:	c3                   	retq   

0000008004200a60 <cga_putc>:



static void
cga_putc(int c)
{
  8004200a60:	55                   	push   %rbp
  8004200a61:	48 89 e5             	mov    %rsp,%rbp
  8004200a64:	48 83 ec 30          	sub    $0x30,%rsp
  8004200a68:	89 7d dc             	mov    %edi,-0x24(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200a6b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200a6e:	b0 00                	mov    $0x0,%al
  8004200a70:	85 c0                	test   %eax,%eax
  8004200a72:	75 07                	jne    8004200a7b <cga_putc+0x1b>
		c |= 0x0700;
  8004200a74:	81 4d dc 00 07 00 00 	orl    $0x700,-0x24(%rbp)

	switch (c & 0xff) {
  8004200a7b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200a7e:	0f b6 c0             	movzbl %al,%eax
  8004200a81:	83 f8 09             	cmp    $0x9,%eax
  8004200a84:	0f 84 f5 00 00 00    	je     8004200b7f <cga_putc+0x11f>
  8004200a8a:	83 f8 09             	cmp    $0x9,%eax
  8004200a8d:	7f 0a                	jg     8004200a99 <cga_putc+0x39>
  8004200a8f:	83 f8 08             	cmp    $0x8,%eax
  8004200a92:	74 18                	je     8004200aac <cga_putc+0x4c>
  8004200a94:	e9 3d 01 00 00       	jmpq   8004200bd6 <cga_putc+0x176>
  8004200a99:	83 f8 0a             	cmp    $0xa,%eax
  8004200a9c:	74 74                	je     8004200b12 <cga_putc+0xb2>
  8004200a9e:	83 f8 0d             	cmp    $0xd,%eax
  8004200aa1:	0f 84 88 00 00 00    	je     8004200b2f <cga_putc+0xcf>
  8004200aa7:	e9 2a 01 00 00       	jmpq   8004200bd6 <cga_putc+0x176>
	case '\b':
		if (crt_pos > 0) {
  8004200aac:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200ab3:	00 00 00 
  8004200ab6:	0f b7 00             	movzwl (%rax),%eax
  8004200ab9:	66 85 c0             	test   %ax,%ax
  8004200abc:	0f 84 4f 01 00 00    	je     8004200c11 <cga_putc+0x1b1>
			crt_pos--;
  8004200ac2:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200ac9:	00 00 00 
  8004200acc:	0f b7 00             	movzwl (%rax),%eax
  8004200acf:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200ad2:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200ad9:	00 00 00 
  8004200adc:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200adf:	48 b8 08 20 36 04 80 	movabs $0x8004362008,%rax
  8004200ae6:	00 00 00 
  8004200ae9:	48 8b 10             	mov    (%rax),%rdx
  8004200aec:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200af3:	00 00 00 
  8004200af6:	0f b7 00             	movzwl (%rax),%eax
  8004200af9:	0f b7 c0             	movzwl %ax,%eax
  8004200afc:	48 01 c0             	add    %rax,%rax
  8004200aff:	48 01 d0             	add    %rdx,%rax
  8004200b02:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200b05:	b2 00                	mov    $0x0,%dl
  8004200b07:	83 ca 20             	or     $0x20,%edx
  8004200b0a:	66 89 10             	mov    %dx,(%rax)
		}
		break;
  8004200b0d:	e9 ff 00 00 00       	jmpq   8004200c11 <cga_putc+0x1b1>
	case '\n':
		crt_pos += CRT_COLS;
  8004200b12:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200b19:	00 00 00 
  8004200b1c:	0f b7 00             	movzwl (%rax),%eax
  8004200b1f:	8d 50 50             	lea    0x50(%rax),%edx
  8004200b22:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200b29:	00 00 00 
  8004200b2c:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200b2f:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200b36:	00 00 00 
  8004200b39:	0f b7 30             	movzwl (%rax),%esi
  8004200b3c:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200b43:	00 00 00 
  8004200b46:	0f b7 08             	movzwl (%rax),%ecx
  8004200b49:	0f b7 c1             	movzwl %cx,%eax
  8004200b4c:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200b52:	c1 e8 10             	shr    $0x10,%eax
  8004200b55:	89 c2                	mov    %eax,%edx
  8004200b57:	66 c1 ea 06          	shr    $0x6,%dx
  8004200b5b:	89 d0                	mov    %edx,%eax
  8004200b5d:	c1 e0 02             	shl    $0x2,%eax
  8004200b60:	01 d0                	add    %edx,%eax
  8004200b62:	c1 e0 04             	shl    $0x4,%eax
  8004200b65:	29 c1                	sub    %eax,%ecx
  8004200b67:	89 ca                	mov    %ecx,%edx
  8004200b69:	29 d6                	sub    %edx,%esi
  8004200b6b:	89 f2                	mov    %esi,%edx
  8004200b6d:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200b74:	00 00 00 
  8004200b77:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200b7a:	e9 93 00 00 00       	jmpq   8004200c12 <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200b7f:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200b84:	48 b8 08 11 20 04 80 	movabs $0x8004201108,%rax
  8004200b8b:	00 00 00 
  8004200b8e:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200b90:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200b95:	48 b8 08 11 20 04 80 	movabs $0x8004201108,%rax
  8004200b9c:	00 00 00 
  8004200b9f:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200ba1:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200ba6:	48 b8 08 11 20 04 80 	movabs $0x8004201108,%rax
  8004200bad:	00 00 00 
  8004200bb0:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bb2:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bb7:	48 b8 08 11 20 04 80 	movabs $0x8004201108,%rax
  8004200bbe:	00 00 00 
  8004200bc1:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200bc3:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200bc8:	48 b8 08 11 20 04 80 	movabs $0x8004201108,%rax
  8004200bcf:	00 00 00 
  8004200bd2:	ff d0                	callq  *%rax
		break;
  8004200bd4:	eb 3c                	jmp    8004200c12 <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200bd6:	48 b8 08 20 36 04 80 	movabs $0x8004362008,%rax
  8004200bdd:	00 00 00 
  8004200be0:	48 8b 30             	mov    (%rax),%rsi
  8004200be3:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200bea:	00 00 00 
  8004200bed:	0f b7 00             	movzwl (%rax),%eax
  8004200bf0:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200bf3:	48 ba 10 20 36 04 80 	movabs $0x8004362010,%rdx
  8004200bfa:	00 00 00 
  8004200bfd:	66 89 0a             	mov    %cx,(%rdx)
  8004200c00:	0f b7 c0             	movzwl %ax,%eax
  8004200c03:	48 01 c0             	add    %rax,%rax
  8004200c06:	48 01 f0             	add    %rsi,%rax
  8004200c09:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200c0c:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200c0f:	eb 01                	jmp    8004200c12 <cga_putc+0x1b2>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
  8004200c11:	90                   	nop
		crt_buf[crt_pos++] = c;		/* write the character */
		break;
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200c12:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200c19:	00 00 00 
  8004200c1c:	0f b7 00             	movzwl (%rax),%eax
  8004200c1f:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200c23:	0f 86 89 00 00 00    	jbe    8004200cb2 <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200c29:	48 b8 08 20 36 04 80 	movabs $0x8004362008,%rax
  8004200c30:	00 00 00 
  8004200c33:	48 8b 00             	mov    (%rax),%rax
  8004200c36:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200c3d:	48 b8 08 20 36 04 80 	movabs $0x8004362008,%rax
  8004200c44:	00 00 00 
  8004200c47:	48 8b 00             	mov    (%rax),%rax
  8004200c4a:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200c4f:	48 89 ce             	mov    %rcx,%rsi
  8004200c52:	48 89 c7             	mov    %rax,%rdi
  8004200c55:	48 b8 02 ed 20 04 80 	movabs $0x800420ed02,%rax
  8004200c5c:	00 00 00 
  8004200c5f:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200c61:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200c68:	eb 22                	jmp    8004200c8c <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200c6a:	48 b8 08 20 36 04 80 	movabs $0x8004362008,%rax
  8004200c71:	00 00 00 
  8004200c74:	48 8b 00             	mov    (%rax),%rax
  8004200c77:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200c7a:	48 63 d2             	movslq %edx,%rdx
  8004200c7d:	48 01 d2             	add    %rdx,%rdx
  8004200c80:	48 01 d0             	add    %rdx,%rax
  8004200c83:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200c88:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200c8c:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200c93:	7e d5                	jle    8004200c6a <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200c95:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200c9c:	00 00 00 
  8004200c9f:	0f b7 00             	movzwl (%rax),%eax
  8004200ca2:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200ca5:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200cac:	00 00 00 
  8004200caf:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200cb2:	48 b8 04 20 36 04 80 	movabs $0x8004362004,%rax
  8004200cb9:	00 00 00 
  8004200cbc:	8b 00                	mov    (%rax),%eax
  8004200cbe:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200cc1:	c6 45 e8 0e          	movb   $0xe,-0x18(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200cc5:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  8004200cc9:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200ccc:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200ccd:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200cd4:	00 00 00 
  8004200cd7:	0f b7 00             	movzwl (%rax),%eax
  8004200cda:	66 c1 e8 08          	shr    $0x8,%ax
  8004200cde:	0f b6 c0             	movzbl %al,%eax
  8004200ce1:	48 ba 04 20 36 04 80 	movabs $0x8004362004,%rdx
  8004200ce8:	00 00 00 
  8004200ceb:	8b 12                	mov    (%rdx),%edx
  8004200ced:	83 c2 01             	add    $0x1,%edx
  8004200cf0:	89 55 f4             	mov    %edx,-0xc(%rbp)
  8004200cf3:	88 45 e9             	mov    %al,-0x17(%rbp)
  8004200cf6:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
  8004200cfa:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200cfd:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200cfe:	48 b8 04 20 36 04 80 	movabs $0x8004362004,%rax
  8004200d05:	00 00 00 
  8004200d08:	8b 00                	mov    (%rax),%eax
  8004200d0a:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004200d0d:	c6 45 ea 0f          	movb   $0xf,-0x16(%rbp)
  8004200d11:	0f b6 45 ea          	movzbl -0x16(%rbp),%eax
  8004200d15:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200d18:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200d19:	48 b8 10 20 36 04 80 	movabs $0x8004362010,%rax
  8004200d20:	00 00 00 
  8004200d23:	0f b7 00             	movzwl (%rax),%eax
  8004200d26:	0f b6 c0             	movzbl %al,%eax
  8004200d29:	48 ba 04 20 36 04 80 	movabs $0x8004362004,%rdx
  8004200d30:	00 00 00 
  8004200d33:	8b 12                	mov    (%rdx),%edx
  8004200d35:	83 c2 01             	add    $0x1,%edx
  8004200d38:	89 55 ec             	mov    %edx,-0x14(%rbp)
  8004200d3b:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004200d3e:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200d42:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200d45:	ee                   	out    %al,(%dx)
}
  8004200d46:	90                   	nop
  8004200d47:	c9                   	leaveq 
  8004200d48:	c3                   	retq   

0000008004200d49 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200d49:	55                   	push   %rbp
  8004200d4a:	48 89 e5             	mov    %rsp,%rbp
  8004200d4d:	48 83 ec 20          	sub    $0x20,%rsp
  8004200d51:	c7 45 ec 64 00 00 00 	movl   $0x64,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200d58:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200d5b:	89 c2                	mov    %eax,%edx
  8004200d5d:	ec                   	in     (%dx),%al
  8004200d5e:	88 45 eb             	mov    %al,-0x15(%rbp)
	return data;
  8004200d61:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200d65:	0f b6 c0             	movzbl %al,%eax
  8004200d68:	83 e0 01             	and    $0x1,%eax
  8004200d6b:	85 c0                	test   %eax,%eax
  8004200d6d:	75 0a                	jne    8004200d79 <kbd_proc_data+0x30>
		return -1;
  8004200d6f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200d74:	e9 fc 01 00 00       	jmpq   8004200f75 <kbd_proc_data+0x22c>
  8004200d79:	c7 45 f4 60 00 00 00 	movl   $0x60,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200d80:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200d83:	89 c2                	mov    %eax,%edx
  8004200d85:	ec                   	in     (%dx),%al
  8004200d86:	88 45 ea             	mov    %al,-0x16(%rbp)
	return data;
  8004200d89:	0f b6 45 ea          	movzbl -0x16(%rbp),%eax

	data = inb(KBDATAP);
  8004200d8d:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200d90:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200d94:	75 27                	jne    8004200dbd <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200d96:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200d9d:	00 00 00 
  8004200da0:	8b 00                	mov    (%rax),%eax
  8004200da2:	83 c8 40             	or     $0x40,%eax
  8004200da5:	89 c2                	mov    %eax,%edx
  8004200da7:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200dae:	00 00 00 
  8004200db1:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200db3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200db8:	e9 b8 01 00 00       	jmpq   8004200f75 <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200dbd:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200dc1:	84 c0                	test   %al,%al
  8004200dc3:	79 65                	jns    8004200e2a <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200dc5:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200dcc:	00 00 00 
  8004200dcf:	8b 00                	mov    (%rax),%eax
  8004200dd1:	83 e0 40             	and    $0x40,%eax
  8004200dd4:	85 c0                	test   %eax,%eax
  8004200dd6:	75 09                	jne    8004200de1 <kbd_proc_data+0x98>
  8004200dd8:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ddc:	83 e0 7f             	and    $0x7f,%eax
  8004200ddf:	eb 04                	jmp    8004200de5 <kbd_proc_data+0x9c>
  8004200de1:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200de5:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200de8:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200dec:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200df3:	00 00 00 
  8004200df6:	48 98                	cltq   
  8004200df8:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200dfc:	83 c8 40             	or     $0x40,%eax
  8004200dff:	0f b6 c0             	movzbl %al,%eax
  8004200e02:	f7 d0                	not    %eax
  8004200e04:	89 c2                	mov    %eax,%edx
  8004200e06:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200e0d:	00 00 00 
  8004200e10:	8b 00                	mov    (%rax),%eax
  8004200e12:	21 c2                	and    %eax,%edx
  8004200e14:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200e1b:	00 00 00 
  8004200e1e:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e20:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e25:	e9 4b 01 00 00       	jmpq   8004200f75 <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200e2a:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200e31:	00 00 00 
  8004200e34:	8b 00                	mov    (%rax),%eax
  8004200e36:	83 e0 40             	and    $0x40,%eax
  8004200e39:	85 c0                	test   %eax,%eax
  8004200e3b:	74 21                	je     8004200e5e <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200e3d:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200e41:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200e48:	00 00 00 
  8004200e4b:	8b 00                	mov    (%rax),%eax
  8004200e4d:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200e50:	89 c2                	mov    %eax,%edx
  8004200e52:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200e59:	00 00 00 
  8004200e5c:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200e5e:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e62:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200e69:	00 00 00 
  8004200e6c:	48 98                	cltq   
  8004200e6e:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200e72:	0f b6 d0             	movzbl %al,%edx
  8004200e75:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200e7c:	00 00 00 
  8004200e7f:	8b 00                	mov    (%rax),%eax
  8004200e81:	09 c2                	or     %eax,%edx
  8004200e83:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200e8a:	00 00 00 
  8004200e8d:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200e8f:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e93:	48 ba 60 b1 22 04 80 	movabs $0x800422b160,%rdx
  8004200e9a:	00 00 00 
  8004200e9d:	48 98                	cltq   
  8004200e9f:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200ea3:	0f b6 d0             	movzbl %al,%edx
  8004200ea6:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200ead:	00 00 00 
  8004200eb0:	8b 00                	mov    (%rax),%eax
  8004200eb2:	31 c2                	xor    %eax,%edx
  8004200eb4:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200ebb:	00 00 00 
  8004200ebe:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200ec0:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200ec7:	00 00 00 
  8004200eca:	8b 00                	mov    (%rax),%eax
  8004200ecc:	83 e0 03             	and    $0x3,%eax
  8004200ecf:	89 c2                	mov    %eax,%edx
  8004200ed1:	48 b8 60 b5 22 04 80 	movabs $0x800422b560,%rax
  8004200ed8:	00 00 00 
  8004200edb:	89 d2                	mov    %edx,%edx
  8004200edd:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200ee1:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ee5:	48 01 d0             	add    %rdx,%rax
  8004200ee8:	0f b6 00             	movzbl (%rax),%eax
  8004200eeb:	0f b6 c0             	movzbl %al,%eax
  8004200eee:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200ef1:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200ef8:	00 00 00 
  8004200efb:	8b 00                	mov    (%rax),%eax
  8004200efd:	83 e0 08             	and    $0x8,%eax
  8004200f00:	85 c0                	test   %eax,%eax
  8004200f02:	74 22                	je     8004200f26 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200f04:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200f08:	7e 0c                	jle    8004200f16 <kbd_proc_data+0x1cd>
  8004200f0a:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200f0e:	7f 06                	jg     8004200f16 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200f10:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200f14:	eb 10                	jmp    8004200f26 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200f16:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200f1a:	7e 0a                	jle    8004200f26 <kbd_proc_data+0x1dd>
  8004200f1c:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200f20:	7f 04                	jg     8004200f26 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200f22:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200f26:	48 b8 28 22 36 04 80 	movabs $0x8004362228,%rax
  8004200f2d:	00 00 00 
  8004200f30:	8b 00                	mov    (%rax),%eax
  8004200f32:	f7 d0                	not    %eax
  8004200f34:	83 e0 06             	and    $0x6,%eax
  8004200f37:	85 c0                	test   %eax,%eax
  8004200f39:	75 37                	jne    8004200f72 <kbd_proc_data+0x229>
  8004200f3b:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004200f42:	75 2e                	jne    8004200f72 <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004200f44:	48 bf 0e 63 21 04 80 	movabs $0x800421630e,%rdi
  8004200f4b:	00 00 00 
  8004200f4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f53:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004200f5a:	00 00 00 
  8004200f5d:	ff d2                	callq  *%rdx
  8004200f5f:	c7 45 f0 92 00 00 00 	movl   $0x92,-0x10(%rbp)
  8004200f66:	c6 45 e9 03          	movb   $0x3,-0x17(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200f6a:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
  8004200f6e:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200f71:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}
	return c;
  8004200f72:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004200f75:	c9                   	leaveq 
  8004200f76:	c3                   	retq   

0000008004200f77 <kbd_intr>:

void
kbd_intr(void)
{
  8004200f77:	55                   	push   %rbp
  8004200f78:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004200f7b:	48 bf 49 0d 20 04 80 	movabs $0x8004200d49,%rdi
  8004200f82:	00 00 00 
  8004200f85:	48 b8 ca 0f 20 04 80 	movabs $0x8004200fca,%rax
  8004200f8c:	00 00 00 
  8004200f8f:	ff d0                	callq  *%rax
}
  8004200f91:	90                   	nop
  8004200f92:	5d                   	pop    %rbp
  8004200f93:	c3                   	retq   

0000008004200f94 <kbd_init>:

static void
kbd_init(void)
{
  8004200f94:	55                   	push   %rbp
  8004200f95:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004200f98:	48 b8 77 0f 20 04 80 	movabs $0x8004200f77,%rax
  8004200f9f:	00 00 00 
  8004200fa2:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004200fa4:	48 b8 92 b6 22 04 80 	movabs $0x800422b692,%rax
  8004200fab:	00 00 00 
  8004200fae:	0f b7 00             	movzwl (%rax),%eax
  8004200fb1:	0f b7 c0             	movzwl %ax,%eax
  8004200fb4:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004200fb9:	89 c7                	mov    %eax,%edi
  8004200fbb:	48 b8 89 8c 20 04 80 	movabs $0x8004208c89,%rax
  8004200fc2:	00 00 00 
  8004200fc5:	ff d0                	callq  *%rax
}
  8004200fc7:	90                   	nop
  8004200fc8:	5d                   	pop    %rbp
  8004200fc9:	c3                   	retq   

0000008004200fca <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004200fca:	55                   	push   %rbp
  8004200fcb:	48 89 e5             	mov    %rsp,%rbp
  8004200fce:	48 83 ec 20          	sub    $0x20,%rsp
  8004200fd2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  8004200fd6:	eb 6a                	jmp    8004201042 <cons_intr+0x78>
		if (c == 0)
  8004200fd8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004200fdc:	75 02                	jne    8004200fe0 <cons_intr+0x16>
			continue;
  8004200fde:	eb 62                	jmp    8004201042 <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  8004200fe0:	48 b8 20 20 36 04 80 	movabs $0x8004362020,%rax
  8004200fe7:	00 00 00 
  8004200fea:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004200ff0:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200ff3:	48 ba 20 20 36 04 80 	movabs $0x8004362020,%rdx
  8004200ffa:	00 00 00 
  8004200ffd:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  8004201003:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004201006:	89 d1                	mov    %edx,%ecx
  8004201008:	48 ba 20 20 36 04 80 	movabs $0x8004362020,%rdx
  800420100f:	00 00 00 
  8004201012:	89 c0                	mov    %eax,%eax
  8004201014:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  8004201017:	48 b8 20 20 36 04 80 	movabs $0x8004362020,%rax
  800420101e:	00 00 00 
  8004201021:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201027:	3d 00 02 00 00       	cmp    $0x200,%eax
  800420102c:	75 14                	jne    8004201042 <cons_intr+0x78>
			cons.wpos = 0;
  800420102e:	48 b8 20 20 36 04 80 	movabs $0x8004362020,%rax
  8004201035:	00 00 00 
  8004201038:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  800420103f:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  8004201042:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201046:	ff d0                	callq  *%rax
  8004201048:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420104b:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420104f:	75 87                	jne    8004200fd8 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  8004201051:	90                   	nop
  8004201052:	c9                   	leaveq 
  8004201053:	c3                   	retq   

0000008004201054 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  8004201054:	55                   	push   %rbp
  8004201055:	48 89 e5             	mov    %rsp,%rbp
  8004201058:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  800420105c:	48 b8 56 07 20 04 80 	movabs $0x8004200756,%rax
  8004201063:	00 00 00 
  8004201066:	ff d0                	callq  *%rax
	kbd_intr();
  8004201068:	48 b8 77 0f 20 04 80 	movabs $0x8004200f77,%rax
  800420106f:	00 00 00 
  8004201072:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  8004201074:	48 b8 20 20 36 04 80 	movabs $0x8004362020,%rax
  800420107b:	00 00 00 
  800420107e:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  8004201084:	48 b8 20 20 36 04 80 	movabs $0x8004362020,%rax
  800420108b:	00 00 00 
  800420108e:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201094:	39 c2                	cmp    %eax,%edx
  8004201096:	74 69                	je     8004201101 <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004201098:	48 b8 20 20 36 04 80 	movabs $0x8004362020,%rax
  800420109f:	00 00 00 
  80042010a2:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042010a8:	8d 48 01             	lea    0x1(%rax),%ecx
  80042010ab:	48 ba 20 20 36 04 80 	movabs $0x8004362020,%rdx
  80042010b2:	00 00 00 
  80042010b5:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  80042010bb:	48 ba 20 20 36 04 80 	movabs $0x8004362020,%rdx
  80042010c2:	00 00 00 
  80042010c5:	89 c0                	mov    %eax,%eax
  80042010c7:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80042010cb:	0f b6 c0             	movzbl %al,%eax
  80042010ce:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  80042010d1:	48 b8 20 20 36 04 80 	movabs $0x8004362020,%rax
  80042010d8:	00 00 00 
  80042010db:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042010e1:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042010e6:	75 14                	jne    80042010fc <cons_getc+0xa8>
			cons.rpos = 0;
  80042010e8:	48 b8 20 20 36 04 80 	movabs $0x8004362020,%rax
  80042010ef:	00 00 00 
  80042010f2:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  80042010f9:	00 00 00 
		return c;
  80042010fc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042010ff:	eb 05                	jmp    8004201106 <cons_getc+0xb2>
	}
	return 0;
  8004201101:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201106:	c9                   	leaveq 
  8004201107:	c3                   	retq   

0000008004201108 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  8004201108:	55                   	push   %rbp
  8004201109:	48 89 e5             	mov    %rsp,%rbp
  800420110c:	48 83 ec 10          	sub    $0x10,%rsp
  8004201110:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  8004201113:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201116:	89 c7                	mov    %eax,%edi
  8004201118:	48 b8 84 07 20 04 80 	movabs $0x8004200784,%rax
  800420111f:	00 00 00 
  8004201122:	ff d0                	callq  *%rax
	lpt_putc(c);
  8004201124:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201127:	89 c7                	mov    %eax,%edi
  8004201129:	48 b8 bf 08 20 04 80 	movabs $0x80042008bf,%rax
  8004201130:	00 00 00 
  8004201133:	ff d0                	callq  *%rax
	cga_putc(c);
  8004201135:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201138:	89 c7                	mov    %eax,%edi
  800420113a:	48 b8 60 0a 20 04 80 	movabs $0x8004200a60,%rax
  8004201141:	00 00 00 
  8004201144:	ff d0                	callq  *%rax
}
  8004201146:	90                   	nop
  8004201147:	c9                   	leaveq 
  8004201148:	c3                   	retq   

0000008004201149 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  8004201149:	55                   	push   %rbp
  800420114a:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  800420114d:	48 b8 45 09 20 04 80 	movabs $0x8004200945,%rax
  8004201154:	00 00 00 
  8004201157:	ff d0                	callq  *%rax
	kbd_init();
  8004201159:	48 b8 94 0f 20 04 80 	movabs $0x8004200f94,%rax
  8004201160:	00 00 00 
  8004201163:	ff d0                	callq  *%rax
	serial_init();
  8004201165:	48 b8 ea 07 20 04 80 	movabs $0x80042007ea,%rax
  800420116c:	00 00 00 
  800420116f:	ff d0                	callq  *%rax

	if (!serial_exists)
  8004201171:	48 b8 00 20 36 04 80 	movabs $0x8004362000,%rax
  8004201178:	00 00 00 
  800420117b:	0f b6 00             	movzbl (%rax),%eax
  800420117e:	83 f0 01             	xor    $0x1,%eax
  8004201181:	84 c0                	test   %al,%al
  8004201183:	74 1b                	je     80042011a0 <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  8004201185:	48 bf 1a 63 21 04 80 	movabs $0x800421631a,%rdi
  800420118c:	00 00 00 
  800420118f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201194:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420119b:	00 00 00 
  800420119e:	ff d2                	callq  *%rdx
}
  80042011a0:	90                   	nop
  80042011a1:	5d                   	pop    %rbp
  80042011a2:	c3                   	retq   

00000080042011a3 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  80042011a3:	55                   	push   %rbp
  80042011a4:	48 89 e5             	mov    %rsp,%rbp
  80042011a7:	48 83 ec 10          	sub    $0x10,%rsp
  80042011ab:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  80042011ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011b1:	89 c7                	mov    %eax,%edi
  80042011b3:	48 b8 08 11 20 04 80 	movabs $0x8004201108,%rax
  80042011ba:	00 00 00 
  80042011bd:	ff d0                	callq  *%rax
}
  80042011bf:	90                   	nop
  80042011c0:	c9                   	leaveq 
  80042011c1:	c3                   	retq   

00000080042011c2 <getchar>:

int
getchar(void)
{
  80042011c2:	55                   	push   %rbp
  80042011c3:	48 89 e5             	mov    %rsp,%rbp
  80042011c6:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  80042011ca:	48 b8 54 10 20 04 80 	movabs $0x8004201054,%rax
  80042011d1:	00 00 00 
  80042011d4:	ff d0                	callq  *%rax
  80042011d6:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042011d9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042011dd:	74 eb                	je     80042011ca <getchar+0x8>
		/* do nothing */;
	return c;
  80042011df:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042011e2:	c9                   	leaveq 
  80042011e3:	c3                   	retq   

00000080042011e4 <iscons>:

int
iscons(int fdnum)
{
  80042011e4:	55                   	push   %rbp
  80042011e5:	48 89 e5             	mov    %rsp,%rbp
  80042011e8:	48 83 ec 08          	sub    $0x8,%rsp
  80042011ec:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  80042011ef:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042011f4:	c9                   	leaveq 
  80042011f5:	c3                   	retq   

00000080042011f6 <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  80042011f6:	55                   	push   %rbp
  80042011f7:	48 89 e5             	mov    %rsp,%rbp
  80042011fa:	48 83 ec 30          	sub    $0x30,%rsp
  80042011fe:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201201:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201205:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201209:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004201210:	eb 6f                	jmp    8004201281 <mon_help+0x8b>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  8004201212:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  8004201219:	00 00 00 
  800420121c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420121f:	48 63 d0             	movslq %eax,%rdx
  8004201222:	48 89 d0             	mov    %rdx,%rax
  8004201225:	48 01 c0             	add    %rax,%rax
  8004201228:	48 01 d0             	add    %rdx,%rax
  800420122b:	48 c1 e0 03          	shl    $0x3,%rax
  800420122f:	48 01 c8             	add    %rcx,%rax
  8004201232:	48 83 c0 08          	add    $0x8,%rax
  8004201236:	48 8b 08             	mov    (%rax),%rcx
  8004201239:	48 be 80 b5 22 04 80 	movabs $0x800422b580,%rsi
  8004201240:	00 00 00 
  8004201243:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201246:	48 63 d0             	movslq %eax,%rdx
  8004201249:	48 89 d0             	mov    %rdx,%rax
  800420124c:	48 01 c0             	add    %rax,%rax
  800420124f:	48 01 d0             	add    %rdx,%rax
  8004201252:	48 c1 e0 03          	shl    $0x3,%rax
  8004201256:	48 01 f0             	add    %rsi,%rax
  8004201259:	48 8b 00             	mov    (%rax),%rax
  800420125c:	48 89 ca             	mov    %rcx,%rdx
  800420125f:	48 89 c6             	mov    %rax,%rsi
  8004201262:	48 bf b3 63 21 04 80 	movabs $0x80042163b3,%rdi
  8004201269:	00 00 00 
  800420126c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201271:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  8004201278:	00 00 00 
  800420127b:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  800420127d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201281:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201284:	83 f8 02             	cmp    $0x2,%eax
  8004201287:	76 89                	jbe    8004201212 <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  8004201289:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420128e:	c9                   	leaveq 
  800420128f:	c3                   	retq   

0000008004201290 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201290:	55                   	push   %rbp
  8004201291:	48 89 e5             	mov    %rsp,%rbp
  8004201294:	48 83 ec 30          	sub    $0x30,%rsp
  8004201298:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420129b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420129f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  80042012a3:	48 bf bc 63 21 04 80 	movabs $0x80042163bc,%rdi
  80042012aa:	00 00 00 
  80042012ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012b2:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042012b9:	00 00 00 
  80042012bc:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  80042012be:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  80042012c5:	00 00 00 
  80042012c8:	48 bf d8 63 21 04 80 	movabs $0x80042163d8,%rdi
  80042012cf:	00 00 00 
  80042012d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042012d7:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042012de:	00 00 00 
  80042012e1:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  80042012e3:	48 b8 0c 00 20 00 00 	movabs $0x20000c,%rax
  80042012ea:	00 00 00 
  80042012ed:	48 89 c2             	mov    %rax,%rdx
  80042012f0:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042012f7:	00 00 00 
  80042012fa:	48 bf 00 64 21 04 80 	movabs $0x8004216400,%rdi
  8004201301:	00 00 00 
  8004201304:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201309:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  8004201310:	00 00 00 
  8004201313:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  8004201315:	48 b8 3c 62 21 00 00 	movabs $0x21623c,%rax
  800420131c:	00 00 00 
  800420131f:	48 89 c2             	mov    %rax,%rdx
  8004201322:	48 be 3c 62 21 04 80 	movabs $0x800421623c,%rsi
  8004201329:	00 00 00 
  800420132c:	48 bf 28 64 21 04 80 	movabs $0x8004216428,%rdi
  8004201333:	00 00 00 
  8004201336:	b8 00 00 00 00       	mov    $0x0,%eax
  800420133b:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  8004201342:	00 00 00 
  8004201345:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004201347:	48 b8 f0 15 36 00 00 	movabs $0x3615f0,%rax
  800420134e:	00 00 00 
  8004201351:	48 89 c2             	mov    %rax,%rdx
  8004201354:	48 be f0 15 36 04 80 	movabs $0x80043615f0,%rsi
  800420135b:	00 00 00 
  800420135e:	48 bf 50 64 21 04 80 	movabs $0x8004216450,%rdi
  8004201365:	00 00 00 
  8004201368:	b8 00 00 00 00       	mov    $0x0,%eax
  800420136d:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  8004201374:	00 00 00 
  8004201377:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201379:	48 b8 10 60 3e 00 00 	movabs $0x3e6010,%rax
  8004201380:	00 00 00 
  8004201383:	48 89 c2             	mov    %rax,%rdx
  8004201386:	48 be 10 60 3e 04 80 	movabs $0x80043e6010,%rsi
  800420138d:	00 00 00 
  8004201390:	48 bf 78 64 21 04 80 	movabs $0x8004216478,%rdi
  8004201397:	00 00 00 
  800420139a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420139f:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  80042013a6:	00 00 00 
  80042013a9:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  80042013ab:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  80042013b2:	00 
  80042013b3:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  80042013ba:	00 00 00 
  80042013bd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042013c1:	48 29 c2             	sub    %rax,%rdx
  80042013c4:	48 b8 10 60 3e 04 80 	movabs $0x80043e6010,%rax
  80042013cb:	00 00 00 
  80042013ce:	48 83 e8 01          	sub    $0x1,%rax
  80042013d2:	48 01 d0             	add    %rdx,%rax
  80042013d5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042013d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042013dd:	ba 00 00 00 00       	mov    $0x0,%edx
  80042013e2:	48 f7 75 f8          	divq   -0x8(%rbp)
  80042013e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042013ea:	48 29 d0             	sub    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042013ed:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042013f4:	48 85 c0             	test   %rax,%rax
  80042013f7:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042013fb:	48 c1 f8 0a          	sar    $0xa,%rax
  80042013ff:	48 89 c6             	mov    %rax,%rsi
  8004201402:	48 bf a0 64 21 04 80 	movabs $0x80042164a0,%rdi
  8004201409:	00 00 00 
  800420140c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201411:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004201418:	00 00 00 
  800420141b:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  800420141d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201422:	c9                   	leaveq 
  8004201423:	c3                   	retq   

0000008004201424 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  8004201424:	55                   	push   %rbp
  8004201425:	48 89 e5             	mov    %rsp,%rbp
  8004201428:	48 81 ec 80 05 00 00 	sub    $0x580,%rsp
  800420142f:	89 bd 9c fa ff ff    	mov    %edi,-0x564(%rbp)
  8004201435:	48 89 b5 90 fa ff ff 	mov    %rsi,-0x570(%rbp)
  800420143c:	48 89 95 88 fa ff ff 	mov    %rdx,-0x578(%rbp)
	cprintf("Stack backtrace:\n");
  8004201443:	48 bf ca 64 21 04 80 	movabs $0x80042164ca,%rdi
  800420144a:	00 00 00 
  800420144d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201452:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004201459:	00 00 00 
  800420145c:	ff d2                	callq  *%rdx

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  800420145e:	48 89 e8             	mov    %rbp,%rax
  8004201461:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	return rbp;
  8004201465:	48 8b 45 80          	mov    -0x80(%rbp),%rax

	//gather initial rbp and rip
	uint64_t rbp = read_rbp();
  8004201469:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint64_t rip;
	__asm __volatile("leaq (%%rip), %0" : "=r" (rip)::"cc","memory");
  800420146d:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 8004201474 <mon_backtrace+0x50>
  8004201474:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	//iterate until end
	while(rbp!=0){
  8004201478:	e9 b0 01 00 00       	jmpq   800420162d <mon_backtrace+0x209>
		struct Ripdebuginfo ripdebug;
		struct Ripdebuginfo *info;
		info = &ripdebug;
  800420147d:	48 8d 85 a0 fa ff ff 	lea    -0x560(%rbp),%rax
  8004201484:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		int returnInt = debuginfo_rip(rip,info);
  8004201488:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420148c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201490:	48 89 d6             	mov    %rdx,%rsi
  8004201493:	48 89 c7             	mov    %rax,%rdi
  8004201496:	48 b8 f0 d8 20 04 80 	movabs $0x800420d8f0,%rax
  800420149d:	00 00 00 
  80042014a0:	ff d0                	callq  *%rax
  80042014a2:	89 45 cc             	mov    %eax,-0x34(%rbp)

		//print first line
		cprintf("  rbp %016llx  rip %016llx\n", rbp, rip);
  80042014a5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042014a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042014ad:	48 89 c6             	mov    %rax,%rsi
  80042014b0:	48 bf dc 64 21 04 80 	movabs $0x80042164dc,%rdi
  80042014b7:	00 00 00 
  80042014ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014bf:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  80042014c6:	00 00 00 
  80042014c9:	ff d1                	callq  *%rcx

		//make sure rip debug was successfull
		if (returnInt==0){
  80042014cb:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042014cf:	0f 85 3e 01 00 00    	jne    8004201613 <mon_backtrace+0x1ef>
		
			//gather data for second line of print
			const char *rip_file = info->rip_file;
  80042014d5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042014d9:	48 8b 00             	mov    (%rax),%rax
  80042014dc:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			int line = info->rip_line;
  80042014e0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042014e4:	8b 40 08             	mov    0x8(%rax),%eax
  80042014e7:	89 45 bc             	mov    %eax,-0x44(%rbp)
			const char *funct_name = info->rip_fn_name;
  80042014ea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042014ee:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042014f2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
			uint64_t funct_add= (uint64_t)(info->rip_fn_addr);
  80042014f6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042014fa:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042014fe:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t funct_off = rip - funct_add ;
  8004201502:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201506:	48 2b 45 a8          	sub    -0x58(%rbp),%rax
  800420150a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			int args = info->rip_fn_narg;
  800420150e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201512:	8b 40 28             	mov    0x28(%rax),%eax
  8004201515:	89 45 9c             	mov    %eax,-0x64(%rbp)

			//print second line
			cprintf("    %s:%d: %s+%016llx  args:%d", rip_file,line,funct_name,funct_off, args);
  8004201518:	8b 7d 9c             	mov    -0x64(%rbp),%edi
  800420151b:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420151f:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201523:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004201526:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420152a:	41 89 f9             	mov    %edi,%r9d
  800420152d:	49 89 f0             	mov    %rsi,%r8
  8004201530:	48 89 c6             	mov    %rax,%rsi
  8004201533:	48 bf f8 64 21 04 80 	movabs $0x80042164f8,%rdi
  800420153a:	00 00 00 
  800420153d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201542:	49 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%r10
  8004201549:	00 00 00 
  800420154c:	41 ff d2             	callq  *%r10

			//get data for arguments
			uint16_t regnum = ripdebug.reg_table.cfa_rule.dw_regnum;
  800420154f:	0f b7 85 4a fb ff ff 	movzwl -0x4b6(%rbp),%eax
  8004201556:	66 89 45 9a          	mov    %ax,-0x66(%rbp)
                        uint64_t ptr;
			//determine where arguments should be read from
                        if (regnum==6){
  800420155a:	66 83 7d 9a 06       	cmpw   $0x6,-0x66(%rbp)
  800420155f:	75 14                	jne    8004201575 <mon_backtrace+0x151>
                        	ptr = rbp+ripdebug.reg_table.cfa_rule.dw_offset;
  8004201561:	48 8b 95 50 fb ff ff 	mov    -0x4b0(%rbp),%rdx
  8004201568:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420156c:	48 01 d0             	add    %rdx,%rax
  800420156f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004201573:	eb 20                	jmp    8004201595 <mon_backtrace+0x171>
                        }else if(regnum==7){
  8004201575:	66 83 7d 9a 07       	cmpw   $0x7,-0x66(%rbp)
  800420157a:	75 19                	jne    8004201595 <mon_backtrace+0x171>

static __inline uint64_t
read_rsp(void)
{
	uint64_t esp;
	__asm __volatile("movq %%rsp,%0" : "=r" (esp));
  800420157c:	48 89 e0             	mov    %rsp,%rax
  800420157f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	return esp;
  8004201583:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
	                	ptr = read_rsp()+ripdebug.reg_table.cfa_rule.dw_offset;
  8004201587:	48 8b 85 50 fb ff ff 	mov    -0x4b0(%rbp),%rax
  800420158e:	48 01 d0             	add    %rdx,%rax
  8004201591:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                        }
				
			//print arguments from stack
			for (int i=1; i<=args; i++){
  8004201595:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%rbp)
  800420159c:	eb 52                	jmp    80042015f0 <mon_backtrace+0x1cc>
				uint64_t argument = ptr+ripdebug.offset_fn_arg[i-1];
  800420159e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042015a1:	83 e8 01             	sub    $0x1,%eax
  80042015a4:	48 98                	cltq   
  80042015a6:	48 83 c0 0a          	add    $0xa,%rax
  80042015aa:	48 8b 94 c5 a8 fa ff 	mov    -0x558(%rbp,%rax,8),%rdx
  80042015b1:	ff 
  80042015b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042015b6:	48 01 d0             	add    %rdx,%rax
  80042015b9:	48 89 45 90          	mov    %rax,-0x70(%rbp)
				uint16_t *arg_ptr=(uint16_t *)argument;
  80042015bd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042015c1:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				cprintf("  %016x", arg_ptr[0]);
  80042015c5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042015c9:	0f b7 00             	movzwl (%rax),%eax
  80042015cc:	0f b7 c0             	movzwl %ax,%eax
  80042015cf:	89 c6                	mov    %eax,%esi
  80042015d1:	48 bf 17 65 21 04 80 	movabs $0x8004216517,%rdi
  80042015d8:	00 00 00 
  80042015db:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015e0:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042015e7:	00 00 00 
  80042015ea:	ff d2                	callq  *%rdx
                        }else if(regnum==7){
	                	ptr = read_rsp()+ripdebug.reg_table.cfa_rule.dw_offset;
                        }
				
			//print arguments from stack
			for (int i=1; i<=args; i++){
  80042015ec:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  80042015f0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042015f3:	3b 45 9c             	cmp    -0x64(%rbp),%eax
  80042015f6:	7e a6                	jle    800420159e <mon_backtrace+0x17a>
				uint64_t argument = ptr+ripdebug.offset_fn_arg[i-1];
				uint16_t *arg_ptr=(uint16_t *)argument;
				cprintf("  %016x", arg_ptr[0]);
			}
			cprintf("\n");
  80042015f8:	48 bf 1f 65 21 04 80 	movabs $0x800421651f,%rdi
  80042015ff:	00 00 00 
  8004201602:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201607:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420160e:	00 00 00 
  8004201611:	ff d2                	callq  *%rdx
		}

		//get next values
		rip = ((uint64_t *)rbp)[1];
  8004201613:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201617:	48 83 c0 08          	add    $0x8,%rax
  800420161b:	48 8b 00             	mov    (%rax),%rax
  800420161e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		rbp = ((uint64_t *)rbp)[0];
  8004201622:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201626:	48 8b 00             	mov    (%rax),%rax
  8004201629:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint64_t rbp = read_rbp();
	uint64_t rip;
	__asm __volatile("leaq (%%rip), %0" : "=r" (rip)::"cc","memory");

	//iterate until end
	while(rbp!=0){
  800420162d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201632:	0f 85 45 fe ff ff    	jne    800420147d <mon_backtrace+0x59>

		//get next values
		rip = ((uint64_t *)rbp)[1];
		rbp = ((uint64_t *)rbp)[0];
	}
	return 0;
  8004201638:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420163d:	c9                   	leaveq 
  800420163e:	c3                   	retq   

000000800420163f <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  800420163f:	55                   	push   %rbp
  8004201640:	48 89 e5             	mov    %rsp,%rbp
  8004201643:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  800420164a:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004201651:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201658:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  800420165f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201662:	48 98                	cltq   
  8004201664:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  800420166b:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201670:	eb 15                	jmp    8004201687 <runcmd+0x48>
			*buf++ = 0;
  8004201672:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201679:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420167d:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  8004201684:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201687:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420168e:	0f b6 00             	movzbl (%rax),%eax
  8004201691:	84 c0                	test   %al,%al
  8004201693:	74 2a                	je     80042016bf <runcmd+0x80>
  8004201695:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420169c:	0f b6 00             	movzbl (%rax),%eax
  800420169f:	0f be c0             	movsbl %al,%eax
  80042016a2:	89 c6                	mov    %eax,%esi
  80042016a4:	48 bf 21 65 21 04 80 	movabs $0x8004216521,%rdi
  80042016ab:	00 00 00 
  80042016ae:	48 b8 03 ec 20 04 80 	movabs $0x800420ec03,%rax
  80042016b5:	00 00 00 
  80042016b8:	ff d0                	callq  *%rax
  80042016ba:	48 85 c0             	test   %rax,%rax
  80042016bd:	75 b3                	jne    8004201672 <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  80042016bf:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042016c6:	0f b6 00             	movzbl (%rax),%eax
  80042016c9:	84 c0                	test   %al,%al
  80042016cb:	0f 84 95 00 00 00    	je     8004201766 <runcmd+0x127>
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  80042016d1:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042016d5:	75 2a                	jne    8004201701 <runcmd+0xc2>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  80042016d7:	be 10 00 00 00       	mov    $0x10,%esi
  80042016dc:	48 bf 26 65 21 04 80 	movabs $0x8004216526,%rdi
  80042016e3:	00 00 00 
  80042016e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016eb:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042016f2:	00 00 00 
  80042016f5:	ff d2                	callq  *%rdx
			return 0;
  80042016f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016fc:	e9 4b 01 00 00       	jmpq   800420184c <runcmd+0x20d>
		}
		argv[argc++] = buf;
  8004201701:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201704:	8d 50 01             	lea    0x1(%rax),%edx
  8004201707:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420170a:	48 98                	cltq   
  800420170c:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201713:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  800420171a:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  800420171b:	eb 08                	jmp    8004201725 <runcmd+0xe6>
			buf++;
  800420171d:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201724:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201725:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420172c:	0f b6 00             	movzbl (%rax),%eax
  800420172f:	84 c0                	test   %al,%al
  8004201731:	0f 84 39 ff ff ff    	je     8004201670 <runcmd+0x31>
  8004201737:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420173e:	0f b6 00             	movzbl (%rax),%eax
  8004201741:	0f be c0             	movsbl %al,%eax
  8004201744:	89 c6                	mov    %eax,%esi
  8004201746:	48 bf 21 65 21 04 80 	movabs $0x8004216521,%rdi
  800420174d:	00 00 00 
  8004201750:	48 b8 03 ec 20 04 80 	movabs $0x800420ec03,%rax
  8004201757:	00 00 00 
  800420175a:	ff d0                	callq  *%rax
  800420175c:	48 85 c0             	test   %rax,%rax
  800420175f:	74 bc                	je     800420171d <runcmd+0xde>
			buf++;
	}
  8004201761:	e9 0a ff ff ff       	jmpq   8004201670 <runcmd+0x31>
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
			*buf++ = 0;
		if (*buf == 0)
			break;
  8004201766:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  8004201767:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420176a:	48 98                	cltq   
  800420176c:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201773:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  8004201778:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420177c:	75 0a                	jne    8004201788 <runcmd+0x149>
		return 0;
  800420177e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201783:	e9 c4 00 00 00       	jmpq   800420184c <runcmd+0x20d>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201788:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800420178f:	e9 82 00 00 00       	jmpq   8004201816 <runcmd+0x1d7>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201794:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  800420179b:	00 00 00 
  800420179e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042017a1:	48 63 d0             	movslq %eax,%rdx
  80042017a4:	48 89 d0             	mov    %rdx,%rax
  80042017a7:	48 01 c0             	add    %rax,%rax
  80042017aa:	48 01 d0             	add    %rdx,%rax
  80042017ad:	48 c1 e0 03          	shl    $0x3,%rax
  80042017b1:	48 01 c8             	add    %rcx,%rax
  80042017b4:	48 8b 10             	mov    (%rax),%rdx
  80042017b7:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042017be:	48 89 d6             	mov    %rdx,%rsi
  80042017c1:	48 89 c7             	mov    %rax,%rdi
  80042017c4:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  80042017cb:	00 00 00 
  80042017ce:	ff d0                	callq  *%rax
  80042017d0:	85 c0                	test   %eax,%eax
  80042017d2:	75 3e                	jne    8004201812 <runcmd+0x1d3>
			return commands[i].func(argc, argv, tf);
  80042017d4:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  80042017db:	00 00 00 
  80042017de:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042017e1:	48 63 d0             	movslq %eax,%rdx
  80042017e4:	48 89 d0             	mov    %rdx,%rax
  80042017e7:	48 01 c0             	add    %rax,%rax
  80042017ea:	48 01 d0             	add    %rdx,%rax
  80042017ed:	48 c1 e0 03          	shl    $0x3,%rax
  80042017f1:	48 01 c8             	add    %rcx,%rax
  80042017f4:	48 83 c0 10          	add    $0x10,%rax
  80042017f8:	48 8b 00             	mov    (%rax),%rax
  80042017fb:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201802:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201809:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800420180c:	89 cf                	mov    %ecx,%edi
  800420180e:	ff d0                	callq  *%rax
  8004201810:	eb 3a                	jmp    800420184c <runcmd+0x20d>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004201812:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201816:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201819:	83 f8 02             	cmp    $0x2,%eax
  800420181c:	0f 86 72 ff ff ff    	jbe    8004201794 <runcmd+0x155>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201822:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201829:	48 89 c6             	mov    %rax,%rsi
  800420182c:	48 bf 43 65 21 04 80 	movabs $0x8004216543,%rdi
  8004201833:	00 00 00 
  8004201836:	b8 00 00 00 00       	mov    $0x0,%eax
  800420183b:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004201842:	00 00 00 
  8004201845:	ff d2                	callq  *%rdx
	return 0;
  8004201847:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420184c:	c9                   	leaveq 
  800420184d:	c3                   	retq   

000000800420184e <monitor>:

void
monitor(struct Trapframe *tf)
{
  800420184e:	55                   	push   %rbp
  800420184f:	48 89 e5             	mov    %rsp,%rbp
  8004201852:	48 83 ec 20          	sub    $0x20,%rsp
  8004201856:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  800420185a:	48 bf 60 65 21 04 80 	movabs $0x8004216560,%rdi
  8004201861:	00 00 00 
  8004201864:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201869:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004201870:	00 00 00 
  8004201873:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201875:	48 bf 88 65 21 04 80 	movabs $0x8004216588,%rdi
  800420187c:	00 00 00 
  800420187f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201884:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420188b:	00 00 00 
  800420188e:	ff d2                	callq  *%rdx

	if (tf != NULL)
  8004201890:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201895:	74 13                	je     80042018aa <monitor+0x5c>
		print_trapframe(tf);
  8004201897:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420189b:	48 89 c7             	mov    %rax,%rdi
  800420189e:	48 b8 25 b0 20 04 80 	movabs $0x800420b025,%rax
  80042018a5:	00 00 00 
  80042018a8:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  80042018aa:	48 bf ad 65 21 04 80 	movabs $0x80042165ad,%rdi
  80042018b1:	00 00 00 
  80042018b4:	48 b8 1e e8 20 04 80 	movabs $0x800420e81e,%rax
  80042018bb:	00 00 00 
  80042018be:	ff d0                	callq  *%rax
  80042018c0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  80042018c4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042018c9:	74 df                	je     80042018aa <monitor+0x5c>
			if (runcmd(buf, tf) < 0)
  80042018cb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042018cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018d3:	48 89 d6             	mov    %rdx,%rsi
  80042018d6:	48 89 c7             	mov    %rax,%rdi
  80042018d9:	48 b8 3f 16 20 04 80 	movabs $0x800420163f,%rax
  80042018e0:	00 00 00 
  80042018e3:	ff d0                	callq  *%rax
  80042018e5:	85 c0                	test   %eax,%eax
  80042018e7:	78 02                	js     80042018eb <monitor+0x9d>
				break;
	}
  80042018e9:	eb bf                	jmp    80042018aa <monitor+0x5c>

	while (1) {
		buf = readline("K> ");
		if (buf != NULL)
			if (runcmd(buf, tf) < 0)
				break;
  80042018eb:	90                   	nop
	}
}
  80042018ec:	90                   	nop
  80042018ed:	c9                   	leaveq 
  80042018ee:	c3                   	retq   

00000080042018ef <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042018ef:	55                   	push   %rbp
  80042018f0:	48 89 e5             	mov    %rsp,%rbp
  80042018f3:	48 83 ec 08          	sub    $0x8,%rsp
  80042018f7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  80042018fb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042018ff:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004201906:	00 00 00 
  8004201909:	48 8b 00             	mov    (%rax),%rax
  800420190c:	48 29 c2             	sub    %rax,%rdx
  800420190f:	48 89 d0             	mov    %rdx,%rax
  8004201912:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201916:	c9                   	leaveq 
  8004201917:	c3                   	retq   

0000008004201918 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201918:	55                   	push   %rbp
  8004201919:	48 89 e5             	mov    %rsp,%rbp
  800420191c:	48 83 ec 08          	sub    $0x8,%rsp
  8004201920:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201924:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201928:	48 89 c7             	mov    %rax,%rdi
  800420192b:	48 b8 ef 18 20 04 80 	movabs $0x80042018ef,%rax
  8004201932:	00 00 00 
  8004201935:	ff d0                	callq  *%rax
  8004201937:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420193b:	c9                   	leaveq 
  800420193c:	c3                   	retq   

000000800420193d <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  800420193d:	55                   	push   %rbp
  800420193e:	48 89 e5             	mov    %rsp,%rbp
  8004201941:	48 83 ec 10          	sub    $0x10,%rsp
  8004201945:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201949:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420194d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201951:	48 89 c2             	mov    %rax,%rdx
  8004201954:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  800420195b:	00 00 00 
  800420195e:	48 8b 00             	mov    (%rax),%rax
  8004201961:	48 39 c2             	cmp    %rax,%rdx
  8004201964:	72 2a                	jb     8004201990 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201966:	48 ba b8 65 21 04 80 	movabs $0x80042165b8,%rdx
  800420196d:	00 00 00 
  8004201970:	be 54 00 00 00       	mov    $0x54,%esi
  8004201975:	48 bf d7 65 21 04 80 	movabs $0x80042165d7,%rdi
  800420197c:	00 00 00 
  800420197f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201984:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  800420198b:	00 00 00 
  800420198e:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201990:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004201997:	00 00 00 
  800420199a:	48 8b 00             	mov    (%rax),%rax
  800420199d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042019a1:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042019a5:	48 c1 e2 04          	shl    $0x4,%rdx
  80042019a9:	48 01 d0             	add    %rdx,%rax
}
  80042019ac:	c9                   	leaveq 
  80042019ad:	c3                   	retq   

00000080042019ae <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  80042019ae:	55                   	push   %rbp
  80042019af:	48 89 e5             	mov    %rsp,%rbp
  80042019b2:	48 83 ec 20          	sub    $0x20,%rsp
  80042019b6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  80042019ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042019be:	48 89 c7             	mov    %rax,%rdi
  80042019c1:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  80042019c8:	00 00 00 
  80042019cb:	ff d0                	callq  *%rax
  80042019cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042019d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042019d5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042019d9:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042019dc:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042019df:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042019e6:	00 00 00 
  80042019e9:	48 8b 00             	mov    (%rax),%rax
  80042019ec:	48 39 c2             	cmp    %rax,%rdx
  80042019ef:	72 32                	jb     8004201a23 <page2kva+0x75>
  80042019f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042019f5:	48 89 c1             	mov    %rax,%rcx
  80042019f8:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  80042019ff:	00 00 00 
  8004201a02:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004201a07:	48 bf d7 65 21 04 80 	movabs $0x80042165d7,%rdi
  8004201a0e:	00 00 00 
  8004201a11:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a16:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004201a1d:	00 00 00 
  8004201a20:	41 ff d0             	callq  *%r8
  8004201a23:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201a2a:	00 00 00 
  8004201a2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a31:	48 01 d0             	add    %rdx,%rax
}
  8004201a34:	c9                   	leaveq 
  8004201a35:	c3                   	retq   

0000008004201a36 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201a36:	55                   	push   %rbp
  8004201a37:	48 89 e5             	mov    %rsp,%rbp
  8004201a3a:	48 83 ec 08          	sub    $0x8,%rsp
  8004201a3e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201a41:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201a44:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201a48:	74 06                	je     8004201a50 <restrictive_type+0x1a>
  8004201a4a:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201a4e:	75 07                	jne    8004201a57 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201a50:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201a55:	eb 3e                	jmp    8004201a95 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201a57:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201a5b:	74 06                	je     8004201a63 <restrictive_type+0x2d>
  8004201a5d:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201a61:	75 07                	jne    8004201a6a <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201a63:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201a68:	eb 2b                	jmp    8004201a95 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201a6a:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201a6e:	74 06                	je     8004201a76 <restrictive_type+0x40>
  8004201a70:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201a74:	75 07                	jne    8004201a7d <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201a76:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201a7b:	eb 18                	jmp    8004201a95 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201a7d:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201a81:	74 06                	je     8004201a89 <restrictive_type+0x53>
  8004201a83:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201a87:	75 07                	jne    8004201a90 <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201a89:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201a8e:	eb 05                	jmp    8004201a95 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201a90:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201a95:	c9                   	leaveq 
  8004201a96:	c3                   	retq   

0000008004201a97 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201a97:	55                   	push   %rbp
  8004201a98:	48 89 e5             	mov    %rsp,%rbp
  8004201a9b:	53                   	push   %rbx
  8004201a9c:	48 83 ec 18          	sub    $0x18,%rsp
  8004201aa0:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201aa3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201aa6:	89 c7                	mov    %eax,%edi
  8004201aa8:	48 b8 b9 8a 20 04 80 	movabs $0x8004208ab9,%rax
  8004201aaf:	00 00 00 
  8004201ab2:	ff d0                	callq  *%rax
  8004201ab4:	89 c3                	mov    %eax,%ebx
  8004201ab6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ab9:	83 c0 01             	add    $0x1,%eax
  8004201abc:	89 c7                	mov    %eax,%edi
  8004201abe:	48 b8 b9 8a 20 04 80 	movabs $0x8004208ab9,%rax
  8004201ac5:	00 00 00 
  8004201ac8:	ff d0                	callq  *%rax
  8004201aca:	c1 e0 08             	shl    $0x8,%eax
  8004201acd:	09 d8                	or     %ebx,%eax
}
  8004201acf:	48 83 c4 18          	add    $0x18,%rsp
  8004201ad3:	5b                   	pop    %rbx
  8004201ad4:	5d                   	pop    %rbp
  8004201ad5:	c3                   	retq   

0000008004201ad6 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201ad6:	55                   	push   %rbp
  8004201ad7:	48 89 e5             	mov    %rsp,%rbp
  8004201ada:	53                   	push   %rbx
  8004201adb:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
  8004201ae2:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201ae9:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201af0:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201af7:	48 89 e0             	mov    %rsp,%rax
  8004201afa:	48 89 c3             	mov    %rax,%rbx
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201afd:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201b04:	8b 40 30             	mov    0x30(%rax),%eax
  8004201b07:	89 c0                	mov    %eax,%eax
  8004201b09:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201b0d:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201b14:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201b17:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201b1c:	f7 e2                	mul    %edx
  8004201b1e:	89 d0                	mov    %edx,%eax
  8004201b20:	c1 e8 04             	shr    $0x4,%eax
  8004201b23:	89 c0                	mov    %eax,%eax
  8004201b25:	48 89 c2             	mov    %rax,%rdx
  8004201b28:	48 83 ea 01          	sub    $0x1,%rdx
  8004201b2c:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201b30:	49 89 c2             	mov    %rax,%r10
  8004201b33:	41 bb 00 00 00 00    	mov    $0x0,%r11d
  8004201b39:	49 89 c0             	mov    %rax,%r8
  8004201b3c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201b42:	48 c1 e0 03          	shl    $0x3,%rax
  8004201b46:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201b4a:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201b4f:	48 83 e8 01          	sub    $0x1,%rax
  8004201b53:	48 01 d0             	add    %rdx,%rax
  8004201b56:	be 10 00 00 00       	mov    $0x10,%esi
  8004201b5b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201b60:	48 f7 f6             	div    %rsi
  8004201b63:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201b67:	48 29 c4             	sub    %rax,%rsp
  8004201b6a:	48 89 e0             	mov    %rsp,%rax
  8004201b6d:	48 83 c0 07          	add    $0x7,%rax
  8004201b71:	48 c1 e8 03          	shr    $0x3,%rax
  8004201b75:	48 c1 e0 03          	shl    $0x3,%rax
  8004201b79:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201b7d:	48 bf 0b 66 21 04 80 	movabs $0x800421660b,%rdi
  8004201b84:	00 00 00 
  8004201b87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b8c:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004201b93:	00 00 00 
  8004201b96:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201b98:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201b9f:	e9 6c 01 00 00       	jmpq   8004201d10 <multiboot_read+0x23a>
		memory_map_t* mmap = &mmap_base[i];
  8004201ba4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ba7:	48 63 d0             	movslq %eax,%rdx
  8004201baa:	48 89 d0             	mov    %rdx,%rax
  8004201bad:	48 01 c0             	add    %rax,%rax
  8004201bb0:	48 01 d0             	add    %rdx,%rax
  8004201bb3:	48 c1 e0 03          	shl    $0x3,%rax
  8004201bb7:	48 89 c2             	mov    %rax,%rdx
  8004201bba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201bbe:	48 01 d0             	add    %rdx,%rax
  8004201bc1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201bc5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201bc9:	8b 40 08             	mov    0x8(%rax),%eax
  8004201bcc:	89 c0                	mov    %eax,%eax
  8004201bce:	48 c1 e0 20          	shl    $0x20,%rax
  8004201bd2:	48 89 c2             	mov    %rax,%rdx
  8004201bd5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201bd9:	8b 40 04             	mov    0x4(%rax),%eax
  8004201bdc:	89 c0                	mov    %eax,%eax
  8004201bde:	48 01 d0             	add    %rdx,%rax
  8004201be1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201be5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201be9:	8b 40 10             	mov    0x10(%rax),%eax
  8004201bec:	89 c0                	mov    %eax,%eax
  8004201bee:	48 c1 e0 20          	shl    $0x20,%rax
  8004201bf2:	48 89 c2             	mov    %rax,%rdx
  8004201bf5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201bf9:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201bfc:	89 c0                	mov    %eax,%eax
  8004201bfe:	48 01 d0             	add    %rdx,%rax
  8004201c01:	48 89 45 b0          	mov    %rax,-0x50(%rbp)

		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size,
  8004201c05:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c09:	8b 70 14             	mov    0x14(%rax),%esi
  8004201c0c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c10:	8b 00                	mov    (%rax),%eax
  8004201c12:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201c16:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201c1a:	41 89 f0             	mov    %esi,%r8d
  8004201c1d:	89 c6                	mov    %eax,%esi
  8004201c1f:	48 bf 20 66 21 04 80 	movabs $0x8004216620,%rdi
  8004201c26:	00 00 00 
  8004201c29:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c2e:	49 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%r9
  8004201c35:	00 00 00 
  8004201c38:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201c3b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c3f:	8b 40 14             	mov    0x14(%rax),%eax
  8004201c42:	83 f8 05             	cmp    $0x5,%eax
  8004201c45:	77 0b                	ja     8004201c52 <multiboot_read+0x17c>
  8004201c47:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c4b:	8b 40 14             	mov    0x14(%rax),%eax
  8004201c4e:	85 c0                	test   %eax,%eax
  8004201c50:	75 0b                	jne    8004201c5d <multiboot_read+0x187>
			mmap->type = MB_TYPE_RESERVED;
  8004201c52:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c56:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)

		//Insert into the sorted list
		int j = 0;
  8004201c5d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201c64:	e9 85 00 00 00       	jmpq   8004201cee <multiboot_read+0x218>
			memory_map_t* this = mmap_list[j];
  8004201c69:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201c6d:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201c70:	48 63 d2             	movslq %edx,%rdx
  8004201c73:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201c77:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201c7b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201c7f:	8b 40 08             	mov    0x8(%rax),%eax
  8004201c82:	89 c0                	mov    %eax,%eax
  8004201c84:	48 c1 e0 20          	shl    $0x20,%rax
  8004201c88:	48 89 c2             	mov    %rax,%rdx
  8004201c8b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201c8f:	8b 40 04             	mov    0x4(%rax),%eax
  8004201c92:	89 c0                	mov    %eax,%eax
  8004201c94:	48 01 d0             	add    %rdx,%rax
  8004201c97:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201c9b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201c9f:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201ca3:	76 45                	jbe    8004201cea <multiboot_read+0x214>
				int last = i+1;
  8004201ca5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ca8:	83 c0 01             	add    $0x1,%eax
  8004201cab:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201cae:	eb 30                	jmp    8004201ce0 <multiboot_read+0x20a>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201cb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201cb4:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201cb7:	48 63 d2             	movslq %edx,%rdx
  8004201cba:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201cbe:	48 01 c2             	add    %rax,%rdx
  8004201cc1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201cc5:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201cc8:	48 63 c9             	movslq %ecx,%rcx
  8004201ccb:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201ccf:	48 83 e9 08          	sub    $0x8,%rcx
  8004201cd3:	48 01 c8             	add    %rcx,%rax
  8004201cd6:	48 8b 00             	mov    (%rax),%rax
  8004201cd9:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201cdc:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201ce0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201ce3:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201ce6:	75 c8                	jne    8004201cb0 <multiboot_read+0x1da>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break;
  8004201ce8:	eb 10                	jmp    8004201cfa <multiboot_read+0x224>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;

		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004201cea:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201cee:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201cf1:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201cf4:	0f 8c 6f ff ff ff    	jl     8004201c69 <multiboot_read+0x193>
					last--;
				}
				break;
			}
		}
		mmap_list[j] = mmap;
  8004201cfa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201cfe:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201d01:	48 63 d2             	movslq %edx,%rdx
  8004201d04:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201d08:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201d0c:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201d10:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d13:	48 63 c8             	movslq %eax,%rcx
  8004201d16:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201d1d:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201d20:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201d25:	f7 e2                	mul    %edx
  8004201d27:	89 d0                	mov    %edx,%eax
  8004201d29:	c1 e8 04             	shr    $0x4,%eax
  8004201d2c:	89 c0                	mov    %eax,%eax
  8004201d2e:	48 39 c1             	cmp    %rax,%rcx
  8004201d31:	0f 82 6d fe ff ff    	jb     8004201ba4 <multiboot_read+0xce>
				break;
			}
		}
		mmap_list[j] = mmap;
	}
	cprintf("\n");
  8004201d37:	48 bf 57 66 21 04 80 	movabs $0x8004216657,%rdi
  8004201d3e:	00 00 00 
  8004201d41:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d46:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004201d4d:	00 00 00 
  8004201d50:	ff d2                	callq  *%rdx

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201d52:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004201d59:	e9 93 01 00 00       	jmpq   8004201ef1 <multiboot_read+0x41b>
		memory_map_t* prev = mmap_list[i-1];
  8004201d5e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d61:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201d64:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d68:	48 63 d2             	movslq %edx,%rdx
  8004201d6b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201d6f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004201d73:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d77:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201d7a:	48 63 d2             	movslq %edx,%rdx
  8004201d7d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201d81:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201d85:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d89:	8b 40 08             	mov    0x8(%rax),%eax
  8004201d8c:	89 c0                	mov    %eax,%eax
  8004201d8e:	48 c1 e0 20          	shl    $0x20,%rax
  8004201d92:	48 89 c2             	mov    %rax,%rdx
  8004201d95:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201d99:	8b 40 04             	mov    0x4(%rax),%eax
  8004201d9c:	89 c0                	mov    %eax,%eax
  8004201d9e:	48 01 d0             	add    %rdx,%rax
  8004201da1:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004201da5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201da9:	8b 40 08             	mov    0x8(%rax),%eax
  8004201dac:	89 c0                	mov    %eax,%eax
  8004201dae:	48 c1 e0 20          	shl    $0x20,%rax
  8004201db2:	48 89 c2             	mov    %rax,%rdx
  8004201db5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201db9:	8b 40 04             	mov    0x4(%rax),%eax
  8004201dbc:	89 c0                	mov    %eax,%eax
  8004201dbe:	48 01 d0             	add    %rdx,%rax
  8004201dc1:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004201dc5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201dc9:	8b 40 10             	mov    0x10(%rax),%eax
  8004201dcc:	89 c0                	mov    %eax,%eax
  8004201dce:	48 c1 e0 20          	shl    $0x20,%rax
  8004201dd2:	48 89 c2             	mov    %rax,%rdx
  8004201dd5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201dd9:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201ddc:	89 c0                	mov    %eax,%eax
  8004201dde:	48 01 d0             	add    %rdx,%rax
  8004201de1:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  8004201de8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201dec:	8b 40 10             	mov    0x10(%rax),%eax
  8004201def:	89 c0                	mov    %eax,%eax
  8004201df1:	48 c1 e0 20          	shl    $0x20,%rax
  8004201df5:	48 89 c2             	mov    %rax,%rdx
  8004201df8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201dfc:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201dff:	89 c0                	mov    %eax,%eax
  8004201e01:	48 01 d0             	add    %rdx,%rax
  8004201e04:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  8004201e0b:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201e0f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201e16:	48 01 d0             	add    %rdx,%rax
  8004201e19:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201e1d:	75 7c                	jne    8004201e9b <multiboot_read+0x3c5>
  8004201e1f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e23:	8b 50 14             	mov    0x14(%rax),%edx
  8004201e26:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e2a:	8b 40 14             	mov    0x14(%rax),%eax
  8004201e2d:	39 c2                	cmp    %eax,%edx
  8004201e2f:	75 6a                	jne    8004201e9b <multiboot_read+0x3c5>
			this->length_low = (uint32_t)prev_length + this_length;
  8004201e31:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201e38:	89 c2                	mov    %eax,%edx
  8004201e3a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201e41:	01 c2                	add    %eax,%edx
  8004201e43:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e47:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004201e4a:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004201e51:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201e58:	48 01 d0             	add    %rdx,%rax
  8004201e5b:	48 c1 e8 20          	shr    $0x20,%rax
  8004201e5f:	89 c2                	mov    %eax,%edx
  8004201e61:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e65:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004201e68:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e6c:	8b 50 04             	mov    0x4(%rax),%edx
  8004201e6f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e73:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004201e76:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e7a:	8b 50 08             	mov    0x8(%rax),%edx
  8004201e7d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e81:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004201e84:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201e87:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201e8a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201e8e:	48 63 d2             	movslq %edx,%rdx
  8004201e91:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004201e98:	00 
  8004201e99:	eb 52                	jmp    8004201eed <multiboot_read+0x417>
		} else if(prev_addr + prev_length > this_addr) {
  8004201e9b:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201e9f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201ea6:	48 01 d0             	add    %rdx,%rax
  8004201ea9:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201ead:	76 3e                	jbe    8004201eed <multiboot_read+0x417>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004201eaf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201eb3:	8b 50 14             	mov    0x14(%rax),%edx
  8004201eb6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201eba:	8b 40 14             	mov    0x14(%rax),%eax
  8004201ebd:	89 d6                	mov    %edx,%esi
  8004201ebf:	89 c7                	mov    %eax,%edi
  8004201ec1:	48 b8 36 1a 20 04 80 	movabs $0x8004201a36,%rax
  8004201ec8:	00 00 00 
  8004201ecb:	ff d0                	callq  *%rax
  8004201ecd:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  8004201ed3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201ed7:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201edd:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004201ee0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201ee4:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201eea:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;
	}
	cprintf("\n");

	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201eed:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201ef1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ef4:	48 63 c8             	movslq %eax,%rcx
  8004201ef7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201efe:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201f01:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201f06:	f7 e2                	mul    %edx
  8004201f08:	89 d0                	mov    %edx,%eax
  8004201f0a:	c1 e8 04             	shr    $0x4,%eax
  8004201f0d:	89 c0                	mov    %eax,%eax
  8004201f0f:	48 39 c1             	cmp    %rax,%rcx
  8004201f12:	0f 82 46 fe ff ff    	jb     8004201d5e <multiboot_read+0x288>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201f18:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201f1f:	e9 dc 00 00 00       	jmpq   8004202000 <multiboot_read+0x52a>
		memory_map_t* mmap = mmap_list[i];
  8004201f24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f28:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201f2b:	48 63 d2             	movslq %edx,%rdx
  8004201f2e:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201f32:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004201f39:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004201f40:	00 
  8004201f41:	0f 84 b5 00 00 00    	je     8004201ffc <multiboot_read+0x526>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004201f47:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201f4e:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f51:	83 f8 01             	cmp    $0x1,%eax
  8004201f54:	74 13                	je     8004201f69 <multiboot_read+0x493>
  8004201f56:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201f5d:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f60:	83 f8 03             	cmp    $0x3,%eax
  8004201f63:	0f 85 93 00 00 00    	jne    8004201ffc <multiboot_read+0x526>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  8004201f69:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201f70:	8b 40 04             	mov    0x4(%rax),%eax
  8004201f73:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8004201f78:	77 49                	ja     8004201fc3 <multiboot_read+0x4ed>
  8004201f7a:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201f81:	8b 40 08             	mov    0x8(%rax),%eax
  8004201f84:	85 c0                	test   %eax,%eax
  8004201f86:	75 3b                	jne    8004201fc3 <multiboot_read+0x4ed>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201f88:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004201f8f:	48 8b 10             	mov    (%rax),%rdx
  8004201f92:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201f99:	8b 40 10             	mov    0x10(%rax),%eax
  8004201f9c:	89 c0                	mov    %eax,%eax
  8004201f9e:	48 c1 e0 20          	shl    $0x20,%rax
  8004201fa2:	48 89 c1             	mov    %rax,%rcx
  8004201fa5:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201fac:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201faf:	89 c0                	mov    %eax,%eax
  8004201fb1:	48 01 c8             	add    %rcx,%rax
  8004201fb4:	48 01 c2             	add    %rax,%rdx
  8004201fb7:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004201fbe:	48 89 10             	mov    %rdx,(%rax)
  8004201fc1:	eb 39                	jmp    8004201ffc <multiboot_read+0x526>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201fc3:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004201fca:	48 8b 10             	mov    (%rax),%rdx
  8004201fcd:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201fd4:	8b 40 10             	mov    0x10(%rax),%eax
  8004201fd7:	89 c0                	mov    %eax,%eax
  8004201fd9:	48 c1 e0 20          	shl    $0x20,%rax
  8004201fdd:	48 89 c1             	mov    %rax,%rcx
  8004201fe0:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201fe7:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201fea:	89 c0                	mov    %eax,%eax
  8004201fec:	48 01 c8             	add    %rcx,%rax
  8004201fef:	48 01 c2             	add    %rax,%rdx
  8004201ff2:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004201ff9:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201ffc:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202000:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202003:	48 63 c8             	movslq %eax,%rcx
  8004202006:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420200d:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202010:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202015:	f7 e2                	mul    %edx
  8004202017:	89 d0                	mov    %edx,%eax
  8004202019:	c1 e8 04             	shr    $0x4,%eax
  800420201c:	89 c0                	mov    %eax,%eax
  800420201e:	48 39 c1             	cmp    %rax,%rcx
  8004202021:	0f 82 fd fe ff ff    	jb     8004201f24 <multiboot_read+0x44e>
  8004202027:	48 89 dc             	mov    %rbx,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  800420202a:	90                   	nop
  800420202b:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  800420202f:	c9                   	leaveq 
  8004202030:	c3                   	retq   

0000008004202031 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202031:	55                   	push   %rbp
  8004202032:	48 89 e5             	mov    %rsp,%rbp
  8004202035:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  8004202039:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004202040:	00 
	size_t extmem = 0;
  8004202041:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004202048:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  8004202049:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004202050:	00 00 00 
  8004202053:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004202057:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420205b:	48 8b 00             	mov    (%rax),%rax
  800420205e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202062:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202067:	74 2d                	je     8004202096 <i386_detect_memory+0x65>
  8004202069:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420206d:	8b 00                	mov    (%rax),%eax
  800420206f:	83 e0 40             	and    $0x40,%eax
  8004202072:	85 c0                	test   %eax,%eax
  8004202074:	74 20                	je     8004202096 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004202076:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  800420207a:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  800420207e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202082:	48 89 ce             	mov    %rcx,%rsi
  8004202085:	48 89 c7             	mov    %rax,%rdi
  8004202088:	48 b8 d6 1a 20 04 80 	movabs $0x8004201ad6,%rax
  800420208f:	00 00 00 
  8004202092:	ff d0                	callq  *%rax
  8004202094:	eb 34                	jmp    80042020ca <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004202096:	bf 15 00 00 00       	mov    $0x15,%edi
  800420209b:	48 b8 97 1a 20 04 80 	movabs $0x8004201a97,%rax
  80042020a2:	00 00 00 
  80042020a5:	ff d0                	callq  *%rax
  80042020a7:	c1 e0 0a             	shl    $0xa,%eax
  80042020aa:	48 98                	cltq   
  80042020ac:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  80042020b0:	bf 17 00 00 00       	mov    $0x17,%edi
  80042020b5:	48 b8 97 1a 20 04 80 	movabs $0x8004201a97,%rax
  80042020bc:	00 00 00 
  80042020bf:	ff d0                	callq  *%rax
  80042020c1:	c1 e0 0a             	shl    $0xa,%eax
  80042020c4:	48 98                	cltq   
  80042020c6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  80042020ca:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042020ce:	48 85 c0             	test   %rax,%rax
  80042020d1:	75 35                	jne    8004202108 <i386_detect_memory+0xd7>
  80042020d3:	48 b9 59 66 21 04 80 	movabs $0x8004216659,%rcx
  80042020da:	00 00 00 
  80042020dd:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042020e4:	00 00 00 
  80042020e7:	be 8e 00 00 00       	mov    $0x8e,%esi
  80042020ec:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042020f3:	00 00 00 
  80042020f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042020fb:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004202102:	00 00 00 
  8004202105:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004202108:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420210c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202110:	48 89 c2             	mov    %rax,%rdx
  8004202113:	48 b8 30 22 36 04 80 	movabs $0x8004362230,%rax
  800420211a:	00 00 00 
  800420211d:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202120:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202124:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202128:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  800420212c:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202131:	48 b8 97 1a 20 04 80 	movabs $0x8004201a97,%rax
  8004202138:	00 00 00 
  800420213b:	ff d0                	callq  *%rax
  800420213d:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202142:	75 2c                	jne    8004202170 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202144:	bf 34 00 00 00       	mov    $0x34,%edi
  8004202149:	48 b8 97 1a 20 04 80 	movabs $0x8004201a97,%rax
  8004202150:	00 00 00 
  8004202153:	ff d0                	callq  *%rax
  8004202155:	c1 e0 10             	shl    $0x10,%eax
  8004202158:	48 98                	cltq   
  800420215a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  800420215e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202162:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004202168:	48 c1 e8 0c          	shr    $0xc,%rax
  800420216c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}

	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202170:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202175:	74 1a                	je     8004202191 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004202177:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420217b:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202182:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004202189:	00 00 00 
  800420218c:	48 89 10             	mov    %rdx,(%rax)
  800420218f:	eb 1a                	jmp    80042021ab <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  8004202191:	48 b8 30 22 36 04 80 	movabs $0x8004362230,%rax
  8004202198:	00 00 00 
  800420219b:	48 8b 10             	mov    (%rax),%rdx
  800420219e:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042021a5:	00 00 00 
  80042021a8:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042021ab:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042021b2:	00 00 00 
  80042021b5:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  80042021b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042021bc:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042021c0:	48 c1 e8 0a          	shr    $0xa,%rax
  80042021c4:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  80042021c7:	48 b8 30 22 36 04 80 	movabs $0x8004362230,%rax
  80042021ce:	00 00 00 
  80042021d1:	48 8b 00             	mov    (%rax),%rax
  80042021d4:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042021d8:	48 c1 e8 0a          	shr    $0xa,%rax
  80042021dc:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  80042021df:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042021e6:	00 00 00 
  80042021e9:	48 8b 00             	mov    (%rax),%rax
  80042021ec:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042021f0:	48 c1 e8 14          	shr    $0x14,%rax
  80042021f4:	49 89 f0             	mov    %rsi,%r8
  80042021f7:	48 89 c6             	mov    %rax,%rsi
  80042021fa:	48 bf 88 66 21 04 80 	movabs $0x8004216688,%rdi
  8004202201:	00 00 00 
  8004202204:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202209:	49 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%r9
  8004202210:	00 00 00 
  8004202213:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004202216:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  800420221d:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  800420221e:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202225:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202226:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420222a:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
  800420222e:	48 c1 e8 14          	shr    $0x14,%rax
  8004202232:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202235:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202239:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to
	//     max out memory
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n",
  800420223d:	48 c1 e8 14          	shr    $0x14,%rax
  8004202241:	48 89 c6             	mov    %rax,%rsi
  8004202244:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004202248:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420224c:	49 89 c8             	mov    %rcx,%r8
  800420224f:	48 89 d1             	mov    %rdx,%rcx
  8004202252:	48 89 f2             	mov    %rsi,%rdx
  8004202255:	48 89 c6             	mov    %rax,%rsi
  8004202258:	48 bf d8 66 21 04 80 	movabs $0x80042166d8,%rdi
  800420225f:	00 00 00 
  8004202262:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202267:	49 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%r9
  800420226e:	00 00 00 
  8004202271:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004202274:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202278:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420227c:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  8004202281:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  8004202285:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  800420228c:	00 00 00 
  800420228f:	48 8b 00             	mov    (%rax),%rax
  8004202292:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004202296:	76 3a                	jbe    80042022d2 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  8004202298:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420229c:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  80042022a3:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042022aa:	00 00 00 
  80042022ad:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  80042022b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042022b4:	48 89 c6             	mov    %rax,%rsi
  80042022b7:	48 bf 40 67 21 04 80 	movabs $0x8004216740,%rdi
  80042022be:	00 00 00 
  80042022c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042022c6:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042022cd:	00 00 00 
  80042022d0:	ff d2                	callq  *%rdx
	}
}
  80042022d2:	90                   	nop
  80042022d3:	c9                   	leaveq 
  80042022d4:	c3                   	retq   

00000080042022d5 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  80042022d5:	55                   	push   %rbp
  80042022d6:	48 89 e5             	mov    %rsp,%rbp
  80042022d9:	48 83 ec 38          	sub    $0x38,%rsp
  80042022dd:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  80042022e0:	48 b8 48 22 36 04 80 	movabs $0x8004362248,%rax
  80042022e7:	00 00 00 
  80042022ea:	48 8b 00             	mov    (%rax),%rax
  80042022ed:	48 85 c0             	test   %rax,%rax
  80042022f0:	75 45                	jne    8004202337 <boot_alloc+0x62>
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  80042022f2:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  80042022f9:	00 
  80042022fa:	48 b8 10 60 3e 04 80 	movabs $0x80043e6010,%rax
  8004202301:	00 00 00 
  8004202304:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004202308:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420230c:	48 01 d0             	add    %rdx,%rax
  800420230f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202313:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202317:	ba 00 00 00 00       	mov    $0x0,%edx
  800420231c:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202320:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202324:	48 29 d0             	sub    %rdx,%rax
  8004202327:	48 89 c2             	mov    %rax,%rdx
  800420232a:	48 b8 48 22 36 04 80 	movabs $0x8004362248,%rax
  8004202331:	00 00 00 
  8004202334:	48 89 10             	mov    %rdx,(%rax)
	//
	// LAB 2: Your code here.

	assert(n>=0);

	result = nextfree; 		//preserve original next free to return
  8004202337:	48 b8 48 22 36 04 80 	movabs $0x8004362248,%rax
  800420233e:	00 00 00 
  8004202341:	48 8b 00             	mov    (%rax),%rax
  8004202344:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (n>0){			//in case more memory has to be allocated
  8004202348:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420234c:	74 51                	je     800420239f <boot_alloc+0xca>
		nextfree = ROUNDUP((char *)(nextfree+n), PGSIZE);	//increment nextfree
  800420234e:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004202355:	00 
  8004202356:	48 b8 48 22 36 04 80 	movabs $0x8004362248,%rax
  800420235d:	00 00 00 
  8004202360:	48 8b 10             	mov    (%rax),%rdx
  8004202363:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202366:	48 01 d0             	add    %rdx,%rax
  8004202369:	48 89 c2             	mov    %rax,%rdx
  800420236c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202370:	48 01 d0             	add    %rdx,%rax
  8004202373:	48 83 e8 01          	sub    $0x1,%rax
  8004202377:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420237b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420237f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202384:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004202388:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420238c:	48 29 d0             	sub    %rdx,%rax
  800420238f:	48 89 c2             	mov    %rax,%rdx
  8004202392:	48 b8 48 22 36 04 80 	movabs $0x8004362248,%rax
  8004202399:	00 00 00 
  800420239c:	48 89 10             	mov    %rdx,(%rax)
	}
	return result;
  800420239f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80042023a3:	c9                   	leaveq 
  80042023a4:	c3                   	retq   

00000080042023a5 <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  80042023a5:	55                   	push   %rbp
  80042023a6:	48 89 e5             	mov    %rsp,%rbp
  80042023a9:	48 83 ec 60          	sub    $0x60,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  80042023ad:	48 b8 31 20 20 04 80 	movabs $0x8004202031,%rax
  80042023b4:	00 00 00 
  80042023b7:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  80042023b9:	bf 00 10 00 00       	mov    $0x1000,%edi
  80042023be:	48 b8 d5 22 20 04 80 	movabs $0x80042022d5,%rax
  80042023c5:	00 00 00 
  80042023c8:	ff d0                	callq  *%rax
  80042023ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  80042023ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042023d2:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042023d7:	be 00 00 00 00       	mov    $0x0,%esi
  80042023dc:	48 89 c7             	mov    %rax,%rdi
  80042023df:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  80042023e6:	00 00 00 
  80042023e9:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  80042023eb:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042023f2:	00 00 00 
  80042023f5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042023f9:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  80042023fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202400:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202404:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420240b:	00 00 00 
  800420240e:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004202412:	77 32                	ja     8004202446 <x64_vm_init+0xa1>
  8004202414:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202418:	48 89 c1             	mov    %rax,%rcx
  800420241b:	48 ba 70 67 21 04 80 	movabs $0x8004216770,%rdx
  8004202422:	00 00 00 
  8004202425:	be 0b 01 00 00       	mov    $0x10b,%esi
  800420242a:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004202431:	00 00 00 
  8004202434:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202439:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004202440:	00 00 00 
  8004202443:	41 ff d0             	callq  *%r8
  8004202446:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420244d:	ff ff ff 
  8004202450:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202454:	48 01 c2             	add    %rax,%rdx
  8004202457:	48 b8 20 37 36 04 80 	movabs $0x8004363720,%rax
  800420245e:	00 00 00 
  8004202461:	48 89 10             	mov    %rdx,(%rax)
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:

	pages = boot_alloc(npages*sizeof(struct PageInfo));
  8004202464:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  800420246b:	00 00 00 
  800420246e:	48 8b 00             	mov    (%rax),%rax
  8004202471:	c1 e0 04             	shl    $0x4,%eax
  8004202474:	89 c7                	mov    %eax,%edi
  8004202476:	48 b8 d5 22 20 04 80 	movabs $0x80042022d5,%rax
  800420247d:	00 00 00 
  8004202480:	ff d0                	callq  *%rax
  8004202482:	48 89 c2             	mov    %rax,%rdx
  8004202485:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  800420248c:	00 00 00 
  800420248f:	48 89 10             	mov    %rdx,(%rax)

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.i

	envs = boot_alloc(NENV*sizeof(struct Env));
  8004202492:	bf 00 80 04 00       	mov    $0x48000,%edi
  8004202497:	48 b8 d5 22 20 04 80 	movabs $0x80042022d5,%rax
  800420249e:	00 00 00 
  80042024a1:	ff d0                	callq  *%rax
  80042024a3:	48 89 c2             	mov    %rax,%rdx
  80042024a6:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  80042024ad:	00 00 00 
  80042024b0:	48 89 10             	mov    %rdx,(%rax)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  80042024b3:	48 b8 1f 29 20 04 80 	movabs $0x800420291f,%rax
  80042024ba:	00 00 00 
  80042024bd:	ff d0                	callq  *%rax
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)i
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:

	boot_map_region(boot_pml4e, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);
  80042024bf:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  80042024c6:	00 00 00 
  80042024c9:	48 8b 00             	mov    (%rax),%rax
  80042024cc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042024d0:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042024d7:	00 00 00 
  80042024da:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042024de:	77 32                	ja     8004202512 <x64_vm_init+0x16d>
  80042024e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042024e4:	48 89 c1             	mov    %rax,%rcx
  80042024e7:	48 ba 70 67 21 04 80 	movabs $0x8004216770,%rdx
  80042024ee:	00 00 00 
  80042024f1:	be 2e 01 00 00       	mov    $0x12e,%esi
  80042024f6:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042024fd:	00 00 00 
  8004202500:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202505:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420250c:	00 00 00 
  800420250f:	41 ff d0             	callq  *%r8
  8004202512:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202519:	ff ff ff 
  800420251c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202520:	48 01 c2             	add    %rax,%rdx
  8004202523:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  800420252a:	00 00 00 
  800420252d:	48 8b 00             	mov    (%rax),%rax
  8004202530:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202536:	48 89 d1             	mov    %rdx,%rcx
  8004202539:	ba 00 00 20 00       	mov    $0x200000,%edx
  800420253e:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202545:	00 00 00 
  8004202548:	48 89 c7             	mov    %rax,%rdi
  800420254b:	48 b8 70 34 20 04 80 	movabs $0x8004203470,%rax
  8004202552:	00 00 00 
  8004202555:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	
	boot_map_region(boot_pml4e, UENVS, PTSIZE, PADDR(envs), PTE_U | PTE_P);
  8004202557:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  800420255e:	00 00 00 
  8004202561:	48 8b 00             	mov    (%rax),%rax
  8004202564:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202568:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420256f:	00 00 00 
  8004202572:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202576:	77 32                	ja     80042025aa <x64_vm_init+0x205>
  8004202578:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420257c:	48 89 c1             	mov    %rax,%rcx
  800420257f:	48 ba 70 67 21 04 80 	movabs $0x8004216770,%rdx
  8004202586:	00 00 00 
  8004202589:	be 38 01 00 00       	mov    $0x138,%esi
  800420258e:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004202595:	00 00 00 
  8004202598:	b8 00 00 00 00       	mov    $0x0,%eax
  800420259d:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042025a4:	00 00 00 
  80042025a7:	41 ff d0             	callq  *%r8
  80042025aa:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042025b1:	ff ff ff 
  80042025b4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042025b8:	48 01 c2             	add    %rax,%rdx
  80042025bb:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042025c2:	00 00 00 
  80042025c5:	48 8b 00             	mov    (%rax),%rax
  80042025c8:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  80042025ce:	48 89 d1             	mov    %rdx,%rcx
  80042025d1:	ba 00 00 20 00       	mov    $0x200000,%edx
  80042025d6:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  80042025dd:	00 00 00 
  80042025e0:	48 89 c7             	mov    %rax,%rdi
  80042025e3:	48 b8 70 34 20 04 80 	movabs $0x8004203470,%rax
  80042025ea:	00 00 00 
  80042025ed:	ff d0                	callq  *%rax
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:

	//PTE_W 0x2 = 1=read/write 0=read only
	boot_map_region(boot_pml4e, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);
  80042025ef:	48 b8 00 b0 21 04 80 	movabs $0x800421b000,%rax
  80042025f6:	00 00 00 
  80042025f9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042025fd:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202604:	00 00 00 
  8004202607:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800420260b:	77 32                	ja     800420263f <x64_vm_init+0x29a>
  800420260d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202611:	48 89 c1             	mov    %rax,%rcx
  8004202614:	48 ba 70 67 21 04 80 	movabs $0x8004216770,%rdx
  800420261b:	00 00 00 
  800420261e:	be 48 01 00 00       	mov    $0x148,%esi
  8004202623:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420262a:	00 00 00 
  800420262d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202632:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004202639:	00 00 00 
  800420263c:	41 ff d0             	callq  *%r8
  800420263f:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202646:	ff ff ff 
  8004202649:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420264d:	48 01 c2             	add    %rax,%rdx
  8004202650:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004202657:	00 00 00 
  800420265a:	48 8b 00             	mov    (%rax),%rax
  800420265d:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  8004202663:	48 89 d1             	mov    %rdx,%rcx
  8004202666:	ba 00 00 01 00       	mov    $0x10000,%edx
  800420266b:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  8004202672:	00 00 00 
  8004202675:	48 89 c7             	mov    %rax,%rdi
  8004202678:	48 b8 70 34 20 04 80 	movabs $0x8004203470,%rax
  800420267f:	00 00 00 
  8004202682:	ff d0                	callq  *%rax
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	boot_map_region(boot_pml4e, KERNBASE, npages*PGSIZE, 0, PTE_W);
  8004202684:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  800420268b:	00 00 00 
  800420268e:	48 8b 00             	mov    (%rax),%rax
  8004202691:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202695:	48 89 c2             	mov    %rax,%rdx
  8004202698:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  800420269f:	00 00 00 
  80042026a2:	48 8b 00             	mov    (%rax),%rax
  80042026a5:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  80042026ab:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042026b0:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  80042026b7:	00 00 00 
  80042026ba:	48 89 c7             	mov    %rax,%rdi
  80042026bd:	48 b8 70 34 20 04 80 	movabs $0x8004203470,%rax
  80042026c4:	00 00 00 
  80042026c7:	ff d0                	callq  *%rax

	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  80042026c9:	48 b8 3a 28 20 04 80 	movabs $0x800420283a,%rax
  80042026d0:	00 00 00 
  80042026d3:	ff d0                	callq  *%rax

	check_page_free_list(1);
  80042026d5:	bf 01 00 00 00       	mov    $0x1,%edi
  80042026da:	48 b8 ec 3a 20 04 80 	movabs $0x8004203aec,%rax
  80042026e1:	00 00 00 
  80042026e4:	ff d0                	callq  *%rax
	check_page_alloc();
  80042026e6:	48 b8 1a 40 20 04 80 	movabs $0x800420401a,%rax
  80042026ed:	00 00 00 
  80042026f0:	ff d0                	callq  *%rax
	page_check();
  80042026f2:	48 b8 db 53 20 04 80 	movabs $0x80042053db,%rax
  80042026f9:	00 00 00 
  80042026fc:	ff d0                	callq  *%rax
	check_page_free_list(0);
  80042026fe:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202703:	48 b8 ec 3a 20 04 80 	movabs $0x8004203aec,%rax
  800420270a:	00 00 00 
  800420270d:	ff d0                	callq  *%rax
	//cprintf("SUCCESSSS\n");

	check_boot_pml4e(boot_pml4e);
  800420270f:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004202716:	00 00 00 
  8004202719:	48 8b 00             	mov    (%rax),%rax
  800420271c:	48 89 c7             	mov    %rax,%rdi
  800420271f:	48 b8 10 4a 20 04 80 	movabs $0x8004204a10,%rax
  8004202726:	00 00 00 
  8004202729:	ff d0                	callq  *%rax


	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  800420272b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420272f:	48 83 c0 08          	add    $0x8,%rax
  8004202733:	48 8b 00             	mov    (%rax),%rax
  8004202736:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420273c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202740:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202744:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202748:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800420274b:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420274e:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004202755:	00 00 00 
  8004202758:	48 8b 00             	mov    (%rax),%rax
  800420275b:	48 39 c2             	cmp    %rax,%rdx
  800420275e:	72 32                	jb     8004202792 <x64_vm_init+0x3ed>
  8004202760:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202764:	48 89 c1             	mov    %rax,%rcx
  8004202767:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  800420276e:	00 00 00 
  8004202771:	be 63 01 00 00       	mov    $0x163,%esi
  8004202776:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420277d:	00 00 00 
  8004202780:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202785:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420278c:	00 00 00 
  800420278f:	41 ff d0             	callq  *%r8
  8004202792:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202799:	00 00 00 
  800420279c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042027a0:	48 01 d0             	add    %rdx,%rax
  80042027a3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  80042027a7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042027ab:	48 8b 00             	mov    (%rax),%rax
  80042027ae:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042027b4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  80042027b8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042027bc:	48 c1 e8 0c          	shr    $0xc,%rax
  80042027c0:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  80042027c3:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  80042027c6:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042027cd:	00 00 00 
  80042027d0:	48 8b 00             	mov    (%rax),%rax
  80042027d3:	48 39 c2             	cmp    %rax,%rdx
  80042027d6:	72 32                	jb     800420280a <x64_vm_init+0x465>
  80042027d8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042027dc:	48 89 c1             	mov    %rax,%rcx
  80042027df:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  80042027e6:	00 00 00 
  80042027e9:	be 64 01 00 00       	mov    $0x164,%esi
  80042027ee:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042027f5:	00 00 00 
  80042027f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042027fd:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004202804:	00 00 00 
  8004202807:	41 ff d0             	callq  *%r8
  800420280a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202811:	00 00 00 
  8004202814:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202818:	48 01 d0             	add    %rdx,%rax
  800420281b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	//check_boot_pml4e(boot_pml4e);
	lcr3(boot_cr3);
  800420281f:	48 b8 20 37 36 04 80 	movabs $0x8004363720,%rax
  8004202826:	00 00 00 
  8004202829:	48 8b 00             	mov    (%rax),%rax
  800420282c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202830:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202834:	0f 22 d8             	mov    %rax,%cr3
}
  8004202837:	90                   	nop
  8004202838:	c9                   	leaveq 
  8004202839:	c3                   	retq   

000000800420283a <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  800420283a:	55                   	push   %rbp
  800420283b:	48 89 e5             	mov    %rsp,%rbp
  800420283e:	48 83 ec 20          	sub    $0x20,%rsp
	//     Permissions: kernel RW, user NONE PTE_W
	//
	// LAB 4: Your code here:

	//for every CPU
	for (int i=0; i<NCPU;i++){
  8004202842:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004202849:	e9 c4 00 00 00       	jmpq   8004202912 <mem_init_mp+0xd8>

		uintptr_t kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP) - KSTKSIZE;
  800420284e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004202851:	89 d0                	mov    %edx,%eax
  8004202853:	01 c0                	add    %eax,%eax
  8004202855:	01 d0                	add    %edx,%eax
  8004202857:	c1 e0 0f             	shl    $0xf,%eax
  800420285a:	48 98                	cltq   
  800420285c:	48 ba 00 00 ff 03 80 	movabs $0x8003ff0000,%rdx
  8004202863:	00 00 00 
  8004202866:	48 29 c2             	sub    %rax,%rdx
  8004202869:	48 89 d0             	mov    %rdx,%rax
  800420286c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		boot_map_region(boot_pml4e, kstacktop_i, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W);
  8004202870:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202873:	48 98                	cltq   
  8004202875:	48 c1 e0 10          	shl    $0x10,%rax
  8004202879:	48 89 c2             	mov    %rax,%rdx
  800420287c:	48 b8 00 60 36 04 80 	movabs $0x8004366000,%rax
  8004202883:	00 00 00 
  8004202886:	48 01 d0             	add    %rdx,%rax
  8004202889:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420288d:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202894:	00 00 00 
  8004202897:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420289b:	77 32                	ja     80042028cf <mem_init_mp+0x95>
  800420289d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042028a1:	48 89 c1             	mov    %rax,%rcx
  80042028a4:	48 ba 70 67 21 04 80 	movabs $0x8004216770,%rdx
  80042028ab:	00 00 00 
  80042028ae:	be 86 01 00 00       	mov    $0x186,%esi
  80042028b3:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042028ba:	00 00 00 
  80042028bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042028c2:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042028c9:	00 00 00 
  80042028cc:	41 ff d0             	callq  *%r8
  80042028cf:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042028d6:	ff ff ff 
  80042028d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042028dd:	48 01 c2             	add    %rax,%rdx
  80042028e0:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042028e7:	00 00 00 
  80042028ea:	48 8b 00             	mov    (%rax),%rax
  80042028ed:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042028f1:	41 b8 02 00 00 00    	mov    $0x2,%r8d
  80042028f7:	48 89 d1             	mov    %rdx,%rcx
  80042028fa:	ba 00 00 01 00       	mov    $0x10000,%edx
  80042028ff:	48 89 c7             	mov    %rax,%rdi
  8004202902:	48 b8 70 34 20 04 80 	movabs $0x8004203470,%rax
  8004202909:	00 00 00 
  800420290c:	ff d0                	callq  *%rax
	//     Permissions: kernel RW, user NONE PTE_W
	//
	// LAB 4: Your code here:

	//for every CPU
	for (int i=0; i<NCPU;i++){
  800420290e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202912:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  8004202916:	0f 8e 32 ff ff ff    	jle    800420284e <mem_init_mp+0x14>
		boot_map_region(boot_pml4e, kstacktop_i, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W);

	}


}
  800420291c:	90                   	nop
  800420291d:	c9                   	leaveq 
  800420291e:	c3                   	retq   

000000800420291f <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  800420291f:	55                   	push   %rbp
  8004202920:	48 89 e5             	mov    %rsp,%rbp
  8004202923:	48 83 ec 20          	sub    $0x20,%rsp
	// free pages!
	// NB: Make sure you preserve the direction in which your page_free_list
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)
	size_t i;
	struct PageInfo* last = NULL;
  8004202927:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420292e:	00 
	//page_free_list = NULL;

	//find pages after end of kernel
	uint64_t kern_end_mem = (((uint64_t)boot_alloc(0))-KERNBASE)/PGSIZE;
  800420292f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202934:	48 b8 d5 22 20 04 80 	movabs $0x80042022d5,%rax
  800420293b:	00 00 00 
  800420293e:	ff d0                	callq  *%rax
  8004202940:	48 89 c2             	mov    %rax,%rdx
  8004202943:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800420294a:	ff ff ff 
  800420294d:	48 01 d0             	add    %rdx,%rax
  8004202950:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202954:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t mpentry = (uint64_t)MPENTRY_PADDR/PGSIZE;
  8004202958:	48 c7 45 e0 07 00 00 	movq   $0x7,-0x20(%rbp)
  800420295f:	00 


	for (i = 0; i < npages; i++) {
  8004202960:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202967:	00 
  8004202968:	e9 5e 01 00 00       	jmpq   8004202acb <page_init+0x1ac>

		if (i==0 || i==mpentry){ 	//#1 make sure first page isn't free amd mpentry is gone too
  800420296d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202972:	74 0a                	je     800420297e <page_init+0x5f>
  8004202974:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202978:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420297c:	75 42                	jne    80042029c0 <page_init+0xa1>
			pages[i].pp_ref = 1;
  800420297e:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004202985:	00 00 00 
  8004202988:	48 8b 00             	mov    (%rax),%rax
  800420298b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420298f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202993:	48 01 d0             	add    %rdx,%rax
  8004202996:	66 c7 40 08 01 00    	movw   $0x1,0x8(%rax)
			pages[i].pp_link = NULL;
  800420299c:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  80042029a3:	00 00 00 
  80042029a6:	48 8b 00             	mov    (%rax),%rax
  80042029a9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042029ad:	48 c1 e2 04          	shl    $0x4,%rdx
  80042029b1:	48 01 d0             	add    %rdx,%rax
  80042029b4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  80042029bb:	e9 06 01 00 00       	jmpq   8004202ac6 <page_init+0x1a7>

		//#2 and #4 stipulation, skips past kernel and IO hole (before kern)
		}else if(i<npages_basemem || i>kern_end_mem){
  80042029c0:	48 b8 30 22 36 04 80 	movabs $0x8004362230,%rax
  80042029c7:	00 00 00 
  80042029ca:	48 8b 00             	mov    (%rax),%rax
  80042029cd:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042029d1:	72 0e                	jb     80042029e1 <page_init+0xc2>
  80042029d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042029d7:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042029db:	0f 86 a8 00 00 00    	jbe    8004202a89 <page_init+0x16a>
			pages[i].pp_ref = 0;
  80042029e1:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  80042029e8:	00 00 00 
  80042029eb:	48 8b 00             	mov    (%rax),%rax
  80042029ee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042029f2:	48 c1 e2 04          	shl    $0x4,%rdx
  80042029f6:	48 01 d0             	add    %rdx,%rax
  80042029f9:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
                	pages[i].pp_link = NULL;
  80042029ff:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004202a06:	00 00 00 
  8004202a09:	48 8b 00             	mov    (%rax),%rax
  8004202a0c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202a10:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202a14:	48 01 d0             	add    %rdx,%rax
  8004202a17:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

			//cprintf("page_free_list == %p \n", page_free_list);

			if (last){
  8004202a1e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202a23:	74 21                	je     8004202a46 <page_init+0x127>
				last->pp_link = &pages[i];
  8004202a25:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004202a2c:	00 00 00 
  8004202a2f:	48 8b 00             	mov    (%rax),%rax
  8004202a32:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202a36:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202a3a:	48 01 c2             	add    %rax,%rdx
  8004202a3d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202a41:	48 89 10             	mov    %rdx,(%rax)
  8004202a44:	eb 25                	jmp    8004202a6b <page_init+0x14c>
			}else{
				page_free_list = &pages[i];
  8004202a46:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004202a4d:	00 00 00 
  8004202a50:	48 8b 00             	mov    (%rax),%rax
  8004202a53:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202a57:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202a5b:	48 01 c2             	add    %rax,%rdx
  8004202a5e:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004202a65:	00 00 00 
  8004202a68:	48 89 10             	mov    %rdx,(%rax)
			}
			last = &pages[i];
  8004202a6b:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004202a72:	00 00 00 
  8004202a75:	48 8b 00             	mov    (%rax),%rax
  8004202a78:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202a7c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202a80:	48 01 d0             	add    %rdx,%rax
  8004202a83:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202a87:	eb 3d                	jmp    8004202ac6 <page_init+0x1a7>
		}else{
			pages[i].pp_ref = 1;
  8004202a89:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004202a90:	00 00 00 
  8004202a93:	48 8b 00             	mov    (%rax),%rax
  8004202a96:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202a9a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202a9e:	48 01 d0             	add    %rdx,%rax
  8004202aa1:	66 c7 40 08 01 00    	movw   $0x1,0x8(%rax)
                        pages[i].pp_link = NULL;
  8004202aa7:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004202aae:	00 00 00 
  8004202ab1:	48 8b 00             	mov    (%rax),%rax
  8004202ab4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202ab8:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202abc:	48 01 d0             	add    %rdx,%rax
  8004202abf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	//find pages after end of kernel
	uint64_t kern_end_mem = (((uint64_t)boot_alloc(0))-KERNBASE)/PGSIZE;
	uint64_t mpentry = (uint64_t)MPENTRY_PADDR/PGSIZE;


	for (i = 0; i < npages; i++) {
  8004202ac6:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202acb:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004202ad2:	00 00 00 
  8004202ad5:	48 8b 00             	mov    (%rax),%rax
  8004202ad8:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202adc:	0f 82 8b fe ff ff    	jb     800420296d <page_init+0x4e>
			pages[i].pp_ref = 1;
                        pages[i].pp_link = NULL;
		}
	}
	//cprintf("%p \n", page_free_list);
}
  8004202ae2:	90                   	nop
  8004202ae3:	c9                   	leaveq 
  8004202ae4:	c3                   	retq   

0000008004202ae5 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202ae5:	55                   	push   %rbp
  8004202ae6:	48 89 e5             	mov    %rsp,%rbp
  8004202ae9:	48 83 ec 20          	sub    $0x20,%rsp
  8004202aed:	89 7d ec             	mov    %edi,-0x14(%rbp)
	//cprintf("Alloc-ing a page\n");
	// return null if out of free memory
	if(page_free_list==NULL){
  8004202af0:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004202af7:	00 00 00 
  8004202afa:	48 8b 00             	mov    (%rax),%rax
  8004202afd:	48 85 c0             	test   %rax,%rax
  8004202b00:	75 0a                	jne    8004202b0c <page_alloc+0x27>
		return NULL;
  8004202b02:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b07:	e9 ba 00 00 00       	jmpq   8004202bc6 <page_alloc+0xe1>
		//cprintf("HERE\n");
	}
	struct PageInfo *page_allocated = page_free_list;		//sets page
  8004202b0c:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004202b13:	00 00 00 
  8004202b16:	48 8b 00             	mov    (%rax),%rax
  8004202b19:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (page_allocated == NULL)
  8004202b1d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202b22:	75 0a                	jne    8004202b2e <page_alloc+0x49>
                return NULL;
  8004202b24:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b29:	e9 98 00 00 00       	jmpq   8004202bc6 <page_alloc+0xe1>
	else{
		if (alloc_flags & ALLOC_ZERO){
  8004202b2e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202b31:	83 e0 01             	and    $0x1,%eax
  8004202b34:	85 c0                	test   %eax,%eax
  8004202b36:	74 2c                	je     8004202b64 <page_alloc+0x7f>
                        memset(page2kva(page_allocated), '\0', PGSIZE);
  8004202b38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b3c:	48 89 c7             	mov    %rax,%rdi
  8004202b3f:	48 b8 ae 19 20 04 80 	movabs $0x80042019ae,%rax
  8004202b46:	00 00 00 
  8004202b49:	ff d0                	callq  *%rax
  8004202b4b:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202b50:	be 00 00 00 00       	mov    $0x0,%esi
  8004202b55:	48 89 c7             	mov    %rax,%rdi
  8004202b58:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004202b5f:	00 00 00 
  8004202b62:	ff d0                	callq  *%rax
                }

		page_free_list = page_free_list->pp_link;	//sets next free page through link
  8004202b64:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004202b6b:	00 00 00 
  8004202b6e:	48 8b 00             	mov    (%rax),%rax
  8004202b71:	48 8b 10             	mov    (%rax),%rdx
  8004202b74:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004202b7b:	00 00 00 
  8004202b7e:	48 89 10             	mov    %rdx,(%rax)

		//set pp_link of allocated page to null
		page_allocated->pp_link = NULL;
  8004202b81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b85:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

		//set memory if flags are set with "\0' for length of page
		if (alloc_flags & ALLOC_ZERO){
  8004202b8c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202b8f:	83 e0 01             	and    $0x1,%eax
  8004202b92:	85 c0                	test   %eax,%eax
  8004202b94:	74 2c                	je     8004202bc2 <page_alloc+0xdd>
			memset(page2kva(page_allocated), '\0', PGSIZE);
  8004202b96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202b9a:	48 89 c7             	mov    %rax,%rdi
  8004202b9d:	48 b8 ae 19 20 04 80 	movabs $0x80042019ae,%rax
  8004202ba4:	00 00 00 
  8004202ba7:	ff d0                	callq  *%rax
  8004202ba9:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202bae:	be 00 00 00 00       	mov    $0x0,%esi
  8004202bb3:	48 89 c7             	mov    %rax,%rdi
  8004202bb6:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004202bbd:	00 00 00 
  8004202bc0:	ff d0                	callq  *%rax
		}

		//cprintf("PAGE ALLOCATED\n");
		return page_allocated;
  8004202bc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	}
}
  8004202bc6:	c9                   	leaveq 
  8004202bc7:	c3                   	retq   

0000008004202bc8 <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202bc8:	55                   	push   %rbp
  8004202bc9:	48 89 e5             	mov    %rsp,%rbp
  8004202bcc:	48 83 ec 10          	sub    $0x10,%rsp
  8004202bd0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202bd4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202bd8:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202bdd:	be 00 00 00 00       	mov    $0x0,%esi
  8004202be2:	48 89 c7             	mov    %rax,%rdi
  8004202be5:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004202bec:	00 00 00 
  8004202bef:	ff d0                	callq  *%rax
}
  8004202bf1:	90                   	nop
  8004202bf2:	c9                   	leaveq 
  8004202bf3:	c3                   	retq   

0000008004202bf4 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004202bf4:	55                   	push   %rbp
  8004202bf5:	48 89 e5             	mov    %rsp,%rbp
  8004202bf8:	48 83 ec 10          	sub    $0x10,%rsp
  8004202bfc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.

	if( pp->pp_ref!=0 || pp->pp_link!=NULL){
  8004202c00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c04:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202c08:	66 85 c0             	test   %ax,%ax
  8004202c0b:	75 0c                	jne    8004202c19 <page_free+0x25>
  8004202c0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c11:	48 8b 00             	mov    (%rax),%rax
  8004202c14:	48 85 c0             	test   %rax,%rax
  8004202c17:	74 2a                	je     8004202c43 <page_free+0x4f>
		panic("cannot free page with non-zero ref or link");
  8004202c19:	48 ba 98 67 21 04 80 	movabs $0x8004216798,%rdx
  8004202c20:	00 00 00 
  8004202c23:	be 1b 02 00 00       	mov    $0x21b,%esi
  8004202c28:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004202c2f:	00 00 00 
  8004202c32:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c37:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  8004202c3e:	00 00 00 
  8004202c41:	ff d1                	callq  *%rcx
	}

	pp->pp_link = page_free_list; //link back to free page list
  8004202c43:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004202c4a:	00 00 00 
  8004202c4d:	48 8b 10             	mov    (%rax),%rdx
  8004202c50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c54:	48 89 10             	mov    %rdx,(%rax)
	page_free_list = pp;	      //other end of connection
  8004202c57:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004202c5e:	00 00 00 
  8004202c61:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c65:	48 89 10             	mov    %rdx,(%rax)

}
  8004202c68:	90                   	nop
  8004202c69:	c9                   	leaveq 
  8004202c6a:	c3                   	retq   

0000008004202c6b <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004202c6b:	55                   	push   %rbp
  8004202c6c:	48 89 e5             	mov    %rsp,%rbp
  8004202c6f:	48 83 ec 10          	sub    $0x10,%rsp
  8004202c73:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004202c77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c7b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202c7f:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202c82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c86:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004202c8a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c8e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202c92:	66 85 c0             	test   %ax,%ax
  8004202c95:	75 13                	jne    8004202caa <page_decref+0x3f>
		page_free(pp);
  8004202c97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202c9b:	48 89 c7             	mov    %rax,%rdi
  8004202c9e:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  8004202ca5:	00 00 00 
  8004202ca8:	ff d0                	callq  *%rax
}
  8004202caa:	90                   	nop
  8004202cab:	c9                   	leaveq 
  8004202cac:	c3                   	retq   

0000008004202cad <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004202cad:	55                   	push   %rbp
  8004202cae:	48 89 e5             	mov    %rsp,%rbp
  8004202cb1:	53                   	push   %rbx
  8004202cb2:	48 83 ec 68          	sub    $0x68,%rsp
  8004202cb6:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004202cba:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004202cbe:	89 55 9c             	mov    %edx,-0x64(%rbp)
	uint64_t temp_pml = PML4(va);
  8004202cc1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202cc5:	48 c1 e8 27          	shr    $0x27,%rax
  8004202cc9:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202cce:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	//pdpe does not exist and create == false
	if (!*pml4e && !create){
  8004202cd2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202cd6:	48 8b 00             	mov    (%rax),%rax
  8004202cd9:	48 85 c0             	test   %rax,%rax
  8004202cdc:	75 10                	jne    8004202cee <pml4e_walk+0x41>
  8004202cde:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  8004202ce2:	75 0a                	jne    8004202cee <pml4e_walk+0x41>
		return NULL;
  8004202ce4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ce9:	e9 31 02 00 00       	jmpq   8004202f1f <pml4e_walk+0x272>
	}

	pte_t *ptr_pte = NULL;
  8004202cee:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004202cf5:	00 
        pdpe_t *ptr_pdpe = NULL;
  8004202cf6:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004202cfd:	00 

	//pdpe already eacsts
	if(pml4e[PML4(va)] & PTE_P){
  8004202cfe:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202d02:	48 c1 e8 27          	shr    $0x27,%rax
  8004202d06:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202d0b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202d12:	00 
  8004202d13:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202d17:	48 01 d0             	add    %rdx,%rax
  8004202d1a:	48 8b 00             	mov    (%rax),%rax
  8004202d1d:	83 e0 01             	and    $0x1,%eax
  8004202d20:	48 85 c0             	test   %rax,%rax
  8004202d23:	0f 84 ba 00 00 00    	je     8004202de3 <pml4e_walk+0x136>

		ptr_pdpe = (pdpe_t *)KADDR(PTE_ADDR(pml4e[PML4(va)]));
  8004202d29:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202d2d:	48 c1 e8 27          	shr    $0x27,%rax
  8004202d31:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202d36:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202d3d:	00 
  8004202d3e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202d42:	48 01 d0             	add    %rdx,%rax
  8004202d45:	48 8b 00             	mov    (%rax),%rax
  8004202d48:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202d4e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202d52:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d56:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d5a:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004202d5d:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004202d60:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004202d67:	00 00 00 
  8004202d6a:	48 8b 00             	mov    (%rax),%rax
  8004202d6d:	48 39 c2             	cmp    %rax,%rdx
  8004202d70:	72 32                	jb     8004202da4 <pml4e_walk+0xf7>
  8004202d72:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d76:	48 89 c1             	mov    %rax,%rcx
  8004202d79:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004202d80:	00 00 00 
  8004202d83:	be 57 02 00 00       	mov    $0x257,%esi
  8004202d88:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004202d8f:	00 00 00 
  8004202d92:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d97:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004202d9e:	00 00 00 
  8004202da1:	41 ff d0             	callq  *%r8
  8004202da4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202dab:	00 00 00 
  8004202dae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202db2:	48 01 d0             	add    %rdx,%rax
  8004202db5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		ptr_pte = pdpe_walk(ptr_pdpe, va, create);
  8004202db9:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004202dbc:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004202dc0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202dc4:	48 89 ce             	mov    %rcx,%rsi
  8004202dc7:	48 89 c7             	mov    %rax,%rdi
  8004202dca:	48 b8 26 2f 20 04 80 	movabs $0x8004202f26,%rax
  8004202dd1:	00 00 00 
  8004202dd4:	ff d0                	callq  *%rax
  8004202dd6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		return ptr_pte;
  8004202dda:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202dde:	e9 3c 01 00 00       	jmpq   8004202f1f <pml4e_walk+0x272>

	//allocates new PDPE page with page_alloc
	}else if (create){
  8004202de3:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  8004202de7:	0f 84 2d 01 00 00    	je     8004202f1a <pml4e_walk+0x26d>
		struct PageInfo *page = page_alloc(ALLOC_ZERO);
  8004202ded:	bf 01 00 00 00       	mov    $0x1,%edi
  8004202df2:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004202df9:	00 00 00 
  8004202dfc:	ff d0                	callq  *%rax
  8004202dfe:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		//allocation returns null
		if(page==NULL){
  8004202e02:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004202e07:	75 0a                	jne    8004202e13 <pml4e_walk+0x166>
			return NULL;
  8004202e09:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e0e:	e9 0c 01 00 00       	jmpq   8004202f1f <pml4e_walk+0x272>
		}

		//the new page's reference count is incremented,
		page->pp_ref++;
  8004202e13:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202e17:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202e1b:	8d 50 01             	lea    0x1(%rax),%edx
  8004202e1e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202e22:	66 89 50 08          	mov    %dx,0x8(%rax)


		//assign to page to pdpe and then pte poiinter
		pml4e[PML4(va)] = (page2pa(page) & ~0xFFF) | PTE_U | PTE_P | PTE_W;
  8004202e26:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202e2a:	48 c1 e8 27          	shr    $0x27,%rax
  8004202e2e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202e33:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202e3a:	00 
  8004202e3b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202e3f:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004202e43:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202e47:	48 89 c7             	mov    %rax,%rdi
  8004202e4a:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004202e51:	00 00 00 
  8004202e54:	ff d0                	callq  *%rax
  8004202e56:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202e5c:	48 83 c8 07          	or     $0x7,%rax
  8004202e60:	48 89 03             	mov    %rax,(%rbx)

		ptr_pdpe = (pdpe_t *) KADDR(PTE_ADDR(pml4e[PML4(va)]));
  8004202e63:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202e67:	48 c1 e8 27          	shr    $0x27,%rax
  8004202e6b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202e70:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202e77:	00 
  8004202e78:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202e7c:	48 01 d0             	add    %rdx,%rax
  8004202e7f:	48 8b 00             	mov    (%rax),%rax
  8004202e82:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202e88:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004202e8c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202e90:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e94:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004202e97:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004202e9a:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004202ea1:	00 00 00 
  8004202ea4:	48 8b 00             	mov    (%rax),%rax
  8004202ea7:	48 39 c2             	cmp    %rax,%rdx
  8004202eaa:	72 32                	jb     8004202ede <pml4e_walk+0x231>
  8004202eac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202eb0:	48 89 c1             	mov    %rax,%rcx
  8004202eb3:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004202eba:	00 00 00 
  8004202ebd:	be 6b 02 00 00       	mov    $0x26b,%esi
  8004202ec2:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004202ec9:	00 00 00 
  8004202ecc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ed1:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004202ed8:	00 00 00 
  8004202edb:	41 ff d0             	callq  *%r8
  8004202ede:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202ee5:	00 00 00 
  8004202ee8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202eec:	48 01 d0             	add    %rdx,%rax
  8004202eef:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		ptr_pte = pdpe_walk(ptr_pdpe, va, create);
  8004202ef3:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004202ef6:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004202efa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202efe:	48 89 ce             	mov    %rcx,%rsi
  8004202f01:	48 89 c7             	mov    %rax,%rdi
  8004202f04:	48 b8 26 2f 20 04 80 	movabs $0x8004202f26,%rax
  8004202f0b:	00 00 00 
  8004202f0e:	ff d0                	callq  *%rax
  8004202f10:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		return ptr_pte;
  8004202f14:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202f18:	eb 05                	jmp    8004202f1f <pml4e_walk+0x272>
	}

	//return ptr_pte;
	return NULL;
  8004202f1a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004202f1f:	48 83 c4 68          	add    $0x68,%rsp
  8004202f23:	5b                   	pop    %rbx
  8004202f24:	5d                   	pop    %rbp
  8004202f25:	c3                   	retq   

0000008004202f26 <pdpe_walk>:
// Given a pdpe i.e page directory pointer pdpe_walk returns the pointer to page table entry
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create){
  8004202f26:	55                   	push   %rbp
  8004202f27:	48 89 e5             	mov    %rsp,%rbp
  8004202f2a:	53                   	push   %rbx
  8004202f2b:	48 83 ec 68          	sub    $0x68,%rsp
  8004202f2f:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004202f33:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004202f37:	89 55 9c             	mov    %edx,-0x64(%rbp)

	uint64_t temp_pdpe = PDPE(va);
  8004202f3a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202f3e:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202f42:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202f47:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("va= %p\t%x\n", va, PDPE(va));

	if(!*pdpe && !create){
  8004202f4b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202f4f:	48 8b 00             	mov    (%rax),%rax
  8004202f52:	48 85 c0             	test   %rax,%rax
  8004202f55:	75 10                	jne    8004202f67 <pdpe_walk+0x41>
  8004202f57:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  8004202f5b:	75 0a                	jne    8004202f67 <pdpe_walk+0x41>
		return NULL;
  8004202f5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f62:	e9 7b 02 00 00       	jmpq   80042031e2 <pdpe_walk+0x2bc>
	}

        pte_t *ptr_pte = NULL;
  8004202f67:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004202f6e:	00 
        pde_t *ptr_pde = NULL;
  8004202f6f:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004202f76:	00 


        if(pdpe[PDPE(va)] & PTE_P){
  8004202f77:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202f7b:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202f7f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202f84:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202f8b:	00 
  8004202f8c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202f90:	48 01 d0             	add    %rdx,%rax
  8004202f93:	48 8b 00             	mov    (%rax),%rax
  8004202f96:	83 e0 01             	and    $0x1,%eax
  8004202f99:	48 85 c0             	test   %rax,%rax
  8004202f9c:	0f 84 04 01 00 00    	je     80042030a6 <pdpe_walk+0x180>
		pdpe[PDPE(va)] = (pdpe[PDPE(va)] & ~0xFFF) | PTE_U | PTE_P | PTE_W;
  8004202fa2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202fa6:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202faa:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202faf:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004202fb6:	00 
  8004202fb7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202fbb:	48 01 d0             	add    %rdx,%rax
  8004202fbe:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004202fc2:	48 c1 ea 1e          	shr    $0x1e,%rdx
  8004202fc6:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004202fcc:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
  8004202fd3:	00 
  8004202fd4:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004202fd8:	48 01 ca             	add    %rcx,%rdx
  8004202fdb:	48 8b 12             	mov    (%rdx),%rdx
  8004202fde:	48 81 e2 00 f0 ff ff 	and    $0xfffffffffffff000,%rdx
  8004202fe5:	48 83 ca 07          	or     $0x7,%rdx
  8004202fe9:	48 89 10             	mov    %rdx,(%rax)

		ptr_pde = (pde_t *)KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004202fec:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202ff0:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004202ff4:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202ff9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203000:	00 
  8004203001:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203005:	48 01 d0             	add    %rdx,%rax
  8004203008:	48 8b 00             	mov    (%rax),%rax
  800420300b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203011:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004203015:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203019:	48 c1 e8 0c          	shr    $0xc,%rax
  800420301d:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004203020:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004203023:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  800420302a:	00 00 00 
  800420302d:	48 8b 00             	mov    (%rax),%rax
  8004203030:	48 39 c2             	cmp    %rax,%rdx
  8004203033:	72 32                	jb     8004203067 <pdpe_walk+0x141>
  8004203035:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203039:	48 89 c1             	mov    %rax,%rcx
  800420303c:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004203043:	00 00 00 
  8004203046:	be 8a 02 00 00       	mov    $0x28a,%esi
  800420304b:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203052:	00 00 00 
  8004203055:	b8 00 00 00 00       	mov    $0x0,%eax
  800420305a:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004203061:	00 00 00 
  8004203064:	41 ff d0             	callq  *%r8
  8004203067:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420306e:	00 00 00 
  8004203071:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203075:	48 01 d0             	add    %rdx,%rax
  8004203078:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		//cprintf("%p\n", pdpe[PDPE(va)]);
                ptr_pte = pgdir_walk(ptr_pde, va, create);
  800420307c:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420307f:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004203083:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203087:	48 89 ce             	mov    %rcx,%rsi
  800420308a:	48 89 c7             	mov    %rax,%rdi
  800420308d:	48 b8 e9 31 20 04 80 	movabs $0x80042031e9,%rax
  8004203094:	00 00 00 
  8004203097:	ff d0                	callq  *%rax
  8004203099:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		return ptr_pte;
  800420309d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042030a1:	e9 3c 01 00 00       	jmpq   80042031e2 <pdpe_walk+0x2bc>
        //allocates new Pgdir page with page_alloc
        }else if (create){
  80042030a6:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042030aa:	0f 84 2d 01 00 00    	je     80042031dd <pdpe_walk+0x2b7>
                struct PageInfo *page = page_alloc(ALLOC_ZERO);
  80042030b0:	bf 01 00 00 00       	mov    $0x1,%edi
  80042030b5:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  80042030bc:	00 00 00 
  80042030bf:	ff d0                	callq  *%rax
  80042030c1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

                //allocation returns null
                if(page==NULL){
  80042030c5:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042030ca:	75 0a                	jne    80042030d6 <pdpe_walk+0x1b0>
                        return NULL;
  80042030cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030d1:	e9 0c 01 00 00       	jmpq   80042031e2 <pdpe_walk+0x2bc>
                }

                //the new page's reference count is incremented,
                page->pp_ref++;
  80042030d6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042030da:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042030de:	8d 50 01             	lea    0x1(%rax),%edx
  80042030e1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042030e5:	66 89 50 08          	mov    %dx,0x8(%rax)


                pdpe[PDPE(va)] = (page2pa(page) & ~0xFFF) | PTE_U | PTE_P | PTE_W;
  80042030e9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042030ed:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042030f1:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042030f6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042030fd:	00 
  80042030fe:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203102:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203106:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420310a:	48 89 c7             	mov    %rax,%rdi
  800420310d:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203114:	00 00 00 
  8004203117:	ff d0                	callq  *%rax
  8004203119:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420311f:	48 83 c8 07          	or     $0x7,%rax
  8004203123:	48 89 03             	mov    %rax,(%rbx)
		ptr_pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004203126:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420312a:	48 c1 e8 1e          	shr    $0x1e,%rax
  800420312e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203133:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420313a:	00 
  800420313b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420313f:	48 01 d0             	add    %rdx,%rax
  8004203142:	48 8b 00             	mov    (%rax),%rax
  8004203145:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420314b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  800420314f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203153:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203157:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  800420315a:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  800420315d:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004203164:	00 00 00 
  8004203167:	48 8b 00             	mov    (%rax),%rax
  800420316a:	48 39 c2             	cmp    %rax,%rdx
  800420316d:	72 32                	jb     80042031a1 <pdpe_walk+0x27b>
  800420316f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203173:	48 89 c1             	mov    %rax,%rcx
  8004203176:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  800420317d:	00 00 00 
  8004203180:	be 9d 02 00 00       	mov    $0x29d,%esi
  8004203185:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420318c:	00 00 00 
  800420318f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203194:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420319b:	00 00 00 
  800420319e:	41 ff d0             	callq  *%r8
  80042031a1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042031a8:	00 00 00 
  80042031ab:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042031af:	48 01 d0             	add    %rdx,%rax
  80042031b2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

		ptr_pte = pgdir_walk(ptr_pde, va, create);
  80042031b6:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042031b9:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042031bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042031c1:	48 89 ce             	mov    %rcx,%rsi
  80042031c4:	48 89 c7             	mov    %rax,%rdi
  80042031c7:	48 b8 e9 31 20 04 80 	movabs $0x80042031e9,%rax
  80042031ce:	00 00 00 
  80042031d1:	ff d0                	callq  *%rax
  80042031d3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        	return ptr_pte;
  80042031d7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042031db:	eb 05                	jmp    80042031e2 <pdpe_walk+0x2bc>
	}

        return NULL;
  80042031dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042031e2:	48 83 c4 68          	add    $0x68,%rsp
  80042031e6:	5b                   	pop    %rbx
  80042031e7:	5d                   	pop    %rbp
  80042031e8:	c3                   	retq   

00000080042031e9 <pgdir_walk>:

// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  80042031e9:	55                   	push   %rbp
  80042031ea:	48 89 e5             	mov    %rsp,%rbp
  80042031ed:	53                   	push   %rbx
  80042031ee:	48 83 ec 58          	sub    $0x58,%rsp
  80042031f2:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042031f6:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80042031fa:	89 55 ac             	mov    %edx,-0x54(%rbp)


	pte_t *ptr_pte = NULL;
  80042031fd:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203204:	00 
	if((pgdir[PDX(va)] & PTE_P))
  8004203205:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203209:	48 c1 e8 15          	shr    $0x15,%rax
  800420320d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203212:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203219:	00 
  800420321a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420321e:	48 01 d0             	add    %rdx,%rax
  8004203221:	48 8b 00             	mov    (%rax),%rax
  8004203224:	83 e0 01             	and    $0x1,%eax
  8004203227:	48 85 c0             	test   %rax,%rax
  800420322a:	0f 84 b0 00 00 00    	je     80042032e0 <pgdir_walk+0xf7>
	{
		ptr_pte = (pte_t*)KADDR((PTE_ADDR(pgdir[PDX(va)]) & ~0xFFF) + PTX(va)*8);
  8004203230:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203234:	48 c1 e8 15          	shr    $0x15,%rax
  8004203238:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420323d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203244:	00 
  8004203245:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203249:	48 01 d0             	add    %rdx,%rax
  800420324c:	48 8b 00             	mov    (%rax),%rax
  800420324f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203255:	48 89 c2             	mov    %rax,%rdx
  8004203258:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420325c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203260:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203265:	48 c1 e0 03          	shl    $0x3,%rax
  8004203269:	48 01 d0             	add    %rdx,%rax
  800420326c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203270:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203274:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203278:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420327b:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420327e:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004203285:	00 00 00 
  8004203288:	48 8b 00             	mov    (%rax),%rax
  800420328b:	48 39 c2             	cmp    %rax,%rdx
  800420328e:	72 32                	jb     80042032c2 <pgdir_walk+0xd9>
  8004203290:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203294:	48 89 c1             	mov    %rax,%rcx
  8004203297:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  800420329e:	00 00 00 
  80042032a1:	be b3 02 00 00       	mov    $0x2b3,%esi
  80042032a6:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042032ad:	00 00 00 
  80042032b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032b5:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042032bc:	00 00 00 
  80042032bf:	41 ff d0             	callq  *%r8
  80042032c2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042032c9:	00 00 00 
  80042032cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042032d0:	48 01 d0             	add    %rdx,%rax
  80042032d3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		return ptr_pte;
  80042032d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042032db:	e9 89 01 00 00       	jmpq   8004203469 <pgdir_walk+0x280>
	}
	else if(create)
  80042032e0:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042032e4:	0f 84 7a 01 00 00    	je     8004203464 <pgdir_walk+0x27b>
	{
		struct PageInfo* page = page_alloc(ALLOC_ZERO);
  80042032ea:	bf 01 00 00 00       	mov    $0x1,%edi
  80042032ef:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  80042032f6:	00 00 00 
  80042032f9:	ff d0                	callq  *%rax
  80042032fb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if (page == NULL){
  80042032ff:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004203304:	75 0a                	jne    8004203310 <pgdir_walk+0x127>
			return NULL;
  8004203306:	b8 00 00 00 00       	mov    $0x0,%eax
  800420330b:	e9 59 01 00 00       	jmpq   8004203469 <pgdir_walk+0x280>
		}
		page->pp_ref++;	// reference ctr incremented by 1
  8004203310:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203314:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203318:	8d 50 01             	lea    0x1(%rax),%edx
  800420331b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420331f:	66 89 50 08          	mov    %dx,0x8(%rax)
		pgdir[PDX(va)] = (page2pa(page) & ~0xFFF) | PTE_U | PTE_P | PTE_W;
  8004203323:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203327:	48 c1 e8 15          	shr    $0x15,%rax
  800420332b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203330:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203337:	00 
  8004203338:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420333c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203340:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203344:	48 89 c7             	mov    %rax,%rdi
  8004203347:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  800420334e:	00 00 00 
  8004203351:	ff d0                	callq  *%rax
  8004203353:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203359:	48 83 c8 07          	or     $0x7,%rax
  800420335d:	48 89 03             	mov    %rax,(%rbx)
		ptr_pte = (pte_t*)KADDR((PTE_ADDR(pgdir[PDX(va)]) & ~0xFFF) + PTX(va)*8);
  8004203360:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203364:	48 c1 e8 15          	shr    $0x15,%rax
  8004203368:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420336d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203374:	00 
  8004203375:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203379:	48 01 d0             	add    %rdx,%rax
  800420337c:	48 8b 00             	mov    (%rax),%rax
  800420337f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203385:	48 89 c2             	mov    %rax,%rdx
  8004203388:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420338c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203390:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203395:	48 c1 e0 03          	shl    $0x3,%rax
  8004203399:	48 01 d0             	add    %rdx,%rax
  800420339c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042033a0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042033a4:	48 c1 e8 0c          	shr    $0xc,%rax
  80042033a8:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042033ab:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042033ae:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042033b5:	00 00 00 
  80042033b8:	48 8b 00             	mov    (%rax),%rax
  80042033bb:	48 39 c2             	cmp    %rax,%rdx
  80042033be:	72 32                	jb     80042033f2 <pgdir_walk+0x209>
  80042033c0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042033c4:	48 89 c1             	mov    %rax,%rcx
  80042033c7:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  80042033ce:	00 00 00 
  80042033d1:	be be 02 00 00       	mov    $0x2be,%esi
  80042033d6:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042033dd:	00 00 00 
  80042033e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033e5:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042033ec:	00 00 00 
  80042033ef:	41 ff d0             	callq  *%r8
  80042033f2:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042033f9:	00 00 00 
  80042033fc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203400:	48 01 d0             	add    %rdx,%rax
  8004203403:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(ptr_pte == NULL)
  8004203407:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420340c:	75 50                	jne    800420345e <pgdir_walk+0x275>
		{
			page->pp_ref--;
  800420340e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203412:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203416:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004203419:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420341d:	66 89 50 08          	mov    %dx,0x8(%rax)
			page_free(page);
  8004203421:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203425:	48 89 c7             	mov    %rax,%rdi
  8004203428:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  800420342f:	00 00 00 
  8004203432:	ff d0                	callq  *%rax
			pgdir[PDX(va)] = 0;
  8004203434:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203438:	48 c1 e8 15          	shr    $0x15,%rax
  800420343c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203441:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203448:	00 
  8004203449:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420344d:	48 01 d0             	add    %rdx,%rax
  8004203450:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			return NULL;
  8004203457:	b8 00 00 00 00       	mov    $0x0,%eax
  800420345c:	eb 0b                	jmp    8004203469 <pgdir_walk+0x280>
		}
		return ptr_pte;
  800420345e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203462:	eb 05                	jmp    8004203469 <pgdir_walk+0x280>
	}
	else
		return NULL;
  8004203464:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203469:	48 83 c4 58          	add    $0x58,%rsp
  800420346d:	5b                   	pop    %rbx
  800420346e:	5d                   	pop    %rbp
  800420346f:	c3                   	retq   

0000008004203470 <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  8004203470:	55                   	push   %rbp
  8004203471:	48 89 e5             	mov    %rsp,%rbp
  8004203474:	48 83 ec 40          	sub    $0x40,%rsp
  8004203478:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420347c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203480:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004203484:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004203488:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)

	//for every page in the size given
	for (int i = 0; i < size/PGSIZE; i++) {
  800420348c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004203493:	eb 4e                	jmp    80042034e3 <boot_map_region+0x73>
		//walk to existing page
		pte_t *ptr_pte = pml4e_walk(pml4e,(void *) la, 1);
  8004203495:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203499:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420349d:	ba 01 00 00 00       	mov    $0x1,%edx
  80042034a2:	48 89 ce             	mov    %rcx,%rsi
  80042034a5:	48 89 c7             	mov    %rax,%rdi
  80042034a8:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  80042034af:	00 00 00 
  80042034b2:	ff d0                	callq  *%rax
  80042034b4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		//set permission bits
		*ptr_pte = pa | perm | PTE_P;
  80042034b8:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042034bb:	48 98                	cltq   
  80042034bd:	48 0b 45 d0          	or     -0x30(%rbp),%rax
  80042034c1:	48 83 c8 01          	or     $0x1,%rax
  80042034c5:	48 89 c2             	mov    %rax,%rdx
  80042034c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042034cc:	48 89 10             	mov    %rdx,(%rax)

		//map next page
		la = la+PGSIZE;
  80042034cf:	48 81 45 e0 00 10 00 	addq   $0x1000,-0x20(%rbp)
  80042034d6:	00 
		pa = pa+PGSIZE;
  80042034d7:	48 81 45 d0 00 10 00 	addq   $0x1000,-0x30(%rbp)
  80042034de:	00 
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{

	//for every page in the size given
	for (int i = 0; i < size/PGSIZE; i++) {
  80042034df:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042034e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042034e6:	48 98                	cltq   
  80042034e8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042034ec:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042034f0:	48 39 d0             	cmp    %rdx,%rax
  80042034f3:	72 a0                	jb     8004203495 <boot_map_region+0x25>
		//map next page
		la = la+PGSIZE;
		pa = pa+PGSIZE;
	}

}
  80042034f5:	90                   	nop
  80042034f6:	c9                   	leaveq 
  80042034f7:	c3                   	retq   

00000080042034f8 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  80042034f8:	55                   	push   %rbp
  80042034f9:	48 89 e5             	mov    %rsp,%rbp
  80042034fc:	48 83 ec 30          	sub    $0x30,%rsp
  8004203500:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203504:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203508:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420350c:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	//find page in mapping
	pte_t *ptr_pte = pml4e_walk(pml4e, va, 1);
  800420350f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203513:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203517:	ba 01 00 00 00       	mov    $0x1,%edx
  800420351c:	48 89 ce             	mov    %rcx,%rsi
  800420351f:	48 89 c7             	mov    %rax,%rdi
  8004203522:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  8004203529:	00 00 00 
  800420352c:	ff d0                	callq  *%rax
  800420352e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	//memory doesn'te xist
	if (ptr_pte==NULL){
  8004203532:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203537:	75 0a                	jne    8004203543 <page_insert+0x4b>
		return -E_NO_MEM;
  8004203539:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420353e:	e9 80 00 00 00       	jmpq   80042035c3 <page_insert+0xcb>
	}
	//page already in that spot but not the one we want to map
	if (*ptr_pte & PTE_P){
  8004203543:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203547:	48 8b 00             	mov    (%rax),%rax
  800420354a:	83 e0 01             	and    $0x1,%eax
  800420354d:	48 85 c0             	test   %rax,%rax
  8004203550:	74 1a                	je     800420356c <page_insert+0x74>

		page_remove(pml4e, va);
  8004203552:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203556:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420355a:	48 89 d6             	mov    %rdx,%rsi
  800420355d:	48 89 c7             	mov    %rax,%rdi
  8004203560:	48 b8 49 36 20 04 80 	movabs $0x8004203649,%rax
  8004203567:	00 00 00 
  800420356a:	ff d0                	callq  *%rax
		//map pp to va
	}

	//permissions
	*ptr_pte = *ptr_pte & ~0xFFF;
  800420356c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203570:	48 8b 00             	mov    (%rax),%rax
  8004203573:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203579:	48 89 c2             	mov    %rax,%rdx
  800420357c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203580:	48 89 10             	mov    %rdx,(%rax)
	*ptr_pte = ((uint64_t)page2pa(pp)) | (perm|PTE_P);
  8004203583:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203587:	48 89 c7             	mov    %rax,%rdi
  800420358a:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203591:	00 00 00 
  8004203594:	ff d0                	callq  *%rax
  8004203596:	48 89 c2             	mov    %rax,%rdx
  8004203599:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420359c:	83 c8 01             	or     $0x1,%eax
  800420359f:	48 98                	cltq   
  80042035a1:	48 09 c2             	or     %rax,%rdx
  80042035a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035a8:	48 89 10             	mov    %rdx,(%rax)

	//pp_Ref incremented if successfull
	pp->pp_ref++;
  80042035ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042035af:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042035b3:	8d 50 01             	lea    0x1(%rax),%edx
  80042035b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042035ba:	66 89 50 08          	mov    %dx,0x8(%rax)
	//cprintf("\n\ndid this\n\n");
	return 0;
  80042035be:	b8 00 00 00 00       	mov    $0x0,%eax

}
  80042035c3:	c9                   	leaveq 
  80042035c4:	c3                   	retq   

00000080042035c5 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  80042035c5:	55                   	push   %rbp
  80042035c6:	48 89 e5             	mov    %rsp,%rbp
  80042035c9:	48 83 ec 30          	sub    $0x30,%rsp
  80042035cd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042035d1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042035d5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t *ptr_pte = pml4e_walk(pml4e, va, 0);
  80042035d9:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80042035dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042035e1:	ba 00 00 00 00       	mov    $0x0,%edx
  80042035e6:	48 89 ce             	mov    %rcx,%rsi
  80042035e9:	48 89 c7             	mov    %rax,%rdi
  80042035ec:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  80042035f3:	00 00 00 
  80042035f6:	ff d0                	callq  *%rax
  80042035f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if((ptr_pte == NULL) || !(*ptr_pte & PTE_P)){
  80042035fc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203601:	74 0f                	je     8004203612 <page_lookup+0x4d>
  8004203603:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203607:	48 8b 00             	mov    (%rax),%rax
  800420360a:	83 e0 01             	and    $0x1,%eax
  800420360d:	48 85 c0             	test   %rax,%rax
  8004203610:	75 07                	jne    8004203619 <page_lookup+0x54>
		return NULL;
  8004203612:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203617:	eb 2e                	jmp    8004203647 <page_lookup+0x82>
	}
	//store address of pte in it
	if (pte_store!=NULL){
  8004203619:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420361e:	74 0b                	je     800420362b <page_lookup+0x66>
		*pte_store = ptr_pte;
  8004203620:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203624:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203628:	48 89 10             	mov    %rdx,(%rax)
	}
	
	//return page
	return pa2page((physaddr_t)PTE_ADDR(*ptr_pte));
  800420362b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420362f:	48 8b 00             	mov    (%rax),%rax
  8004203632:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203638:	48 89 c7             	mov    %rax,%rdi
  800420363b:	48 b8 3d 19 20 04 80 	movabs $0x800420193d,%rax
  8004203642:	00 00 00 
  8004203645:	ff d0                	callq  *%rax
}
  8004203647:	c9                   	leaveq 
  8004203648:	c3                   	retq   

0000008004203649 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004203649:	55                   	push   %rbp
  800420364a:	48 89 e5             	mov    %rsp,%rbp
  800420364d:	48 83 ec 20          	sub    $0x20,%rsp
  8004203651:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203655:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	pte_t *ptr_pte = pml4e_walk(pml4e, va, 0);
  8004203659:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420365d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203661:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203666:	48 89 ce             	mov    %rcx,%rsi
  8004203669:	48 89 c7             	mov    %rax,%rdi
  800420366c:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  8004203673:	00 00 00 
  8004203676:	ff d0                	callq  *%rax
  8004203678:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (ptr_pte==NULL){
  800420367c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203680:	48 85 c0             	test   %rax,%rax
  8004203683:	74 5c                	je     80042036e1 <page_remove+0x98>
		return; //silently does nothing -wow-
	}

	//remove page here
	struct PageInfo *page = page_lookup(pml4e, va, &ptr_pte);
  8004203685:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203689:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420368d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203691:	48 89 ce             	mov    %rcx,%rsi
  8004203694:	48 89 c7             	mov    %rax,%rdi
  8004203697:	48 b8 c5 35 20 04 80 	movabs $0x80042035c5,%rax
  800420369e:	00 00 00 
  80042036a1:	ff d0                	callq  *%rax
  80042036a3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	page_decref(page);
  80042036a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042036ab:	48 89 c7             	mov    %rax,%rdi
  80042036ae:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  80042036b5:	00 00 00 
  80042036b8:	ff d0                	callq  *%rax
	*ptr_pte = 0;
  80042036ba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042036be:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	tlb_invalidate(pml4e, va);
  80042036c5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042036c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042036cd:	48 89 d6             	mov    %rdx,%rsi
  80042036d0:	48 89 c7             	mov    %rax,%rdi
  80042036d3:	48 b8 e4 36 20 04 80 	movabs $0x80042036e4,%rax
  80042036da:	00 00 00 
  80042036dd:	ff d0                	callq  *%rax
  80042036df:	eb 01                	jmp    80042036e2 <page_remove+0x99>
page_remove(pml4e_t *pml4e, void *va)
{
	// Fill this function in
	pte_t *ptr_pte = pml4e_walk(pml4e, va, 0);
	if (ptr_pte==NULL){
		return; //silently does nothing -wow-
  80042036e1:	90                   	nop
	struct PageInfo *page = page_lookup(pml4e, va, &ptr_pte);
	page_decref(page);
	*ptr_pte = 0;
	tlb_invalidate(pml4e, va);

}
  80042036e2:	c9                   	leaveq 
  80042036e3:	c3                   	retq   

00000080042036e4 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  80042036e4:	55                   	push   %rbp
  80042036e5:	48 89 e5             	mov    %rsp,%rbp
  80042036e8:	48 83 ec 20          	sub    $0x20,%rsp
  80042036ec:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042036f0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  80042036f4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042036f9:	75 35                	jne    8004203730 <tlb_invalidate+0x4c>
  80042036fb:	48 b9 c3 67 21 04 80 	movabs $0x80042167c3,%rcx
  8004203702:	00 00 00 
  8004203705:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420370c:	00 00 00 
  800420370f:	be 62 03 00 00       	mov    $0x362,%esi
  8004203714:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420371b:	00 00 00 
  800420371e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203723:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420372a:	00 00 00 
  800420372d:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203730:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004203737:	00 00 00 
  800420373a:	ff d0                	callq  *%rax
  800420373c:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  8004203743:	00 00 00 
  8004203746:	48 98                	cltq   
  8004203748:	48 89 c2             	mov    %rax,%rdx
  800420374b:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004203752:	00 
  8004203753:	48 89 c2             	mov    %rax,%rdx
  8004203756:	48 89 d0             	mov    %rdx,%rax
  8004203759:	48 c1 e0 04          	shl    $0x4,%rax
  800420375d:	48 29 d0             	sub    %rdx,%rax
  8004203760:	48 01 c8             	add    %rcx,%rax
  8004203763:	48 83 c0 08          	add    $0x8,%rax
  8004203767:	48 8b 00             	mov    (%rax),%rax
  800420376a:	48 85 c0             	test   %rax,%rax
  800420376d:	74 47                	je     80042037b6 <tlb_invalidate+0xd2>
  800420376f:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004203776:	00 00 00 
  8004203779:	ff d0                	callq  *%rax
  800420377b:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  8004203782:	00 00 00 
  8004203785:	48 98                	cltq   
  8004203787:	48 89 c2             	mov    %rax,%rdx
  800420378a:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004203791:	00 
  8004203792:	48 89 c2             	mov    %rax,%rdx
  8004203795:	48 89 d0             	mov    %rdx,%rax
  8004203798:	48 c1 e0 04          	shl    $0x4,%rax
  800420379c:	48 29 d0             	sub    %rdx,%rax
  800420379f:	48 01 c8             	add    %rcx,%rax
  80042037a2:	48 83 c0 08          	add    $0x8,%rax
  80042037a6:	48 8b 00             	mov    (%rax),%rax
  80042037a9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042037b0:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042037b4:	75 0f                	jne    80042037c5 <tlb_invalidate+0xe1>
  80042037b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042037ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  80042037be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042037c2:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  80042037c5:	90                   	nop
  80042037c6:	c9                   	leaveq 
  80042037c7:	c3                   	retq   

00000080042037c8 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  80042037c8:	55                   	push   %rbp
  80042037c9:	48 89 e5             	mov    %rsp,%rbp
  80042037cc:	48 83 ec 40          	sub    $0x40,%rsp
  80042037d0:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042037d4:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
	// okay to simply panic if this happens).
	//
	// Hint: The staff solution uses boot_map_region.
	//

	physaddr_t pa_rounded = ROUNDDOWN(pa, PGSIZE);
  80042037d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042037dc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042037e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042037e4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042037ea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	size_t size_rounded = ROUNDUP(size, PGSIZE);
  80042037ee:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  80042037f5:	00 
  80042037f6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042037fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037fe:	48 01 d0             	add    %rdx,%rax
  8004203801:	48 83 e8 01          	sub    $0x1,%rax
  8004203805:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203809:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420380d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203812:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004203816:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420381a:	48 29 d0             	sub    %rdx,%rax
  800420381d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	if (base+size_rounded>MMIOLIM){
  8004203821:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  8004203828:	00 00 00 
  800420382b:	48 8b 10             	mov    (%rax),%rdx
  800420382e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203832:	48 01 c2             	add    %rax,%rdx
  8004203835:	48 b8 00 00 e0 03 80 	movabs $0x8003e00000,%rax
  800420383c:	00 00 00 
  800420383f:	48 39 c2             	cmp    %rax,%rdx
  8004203842:	76 2a                	jbe    800420386e <mmio_map_region+0xa6>
		panic("MMIO no more memory");
  8004203844:	48 ba cf 67 21 04 80 	movabs $0x80042167cf,%rdx
  800420384b:	00 00 00 
  800420384e:	be 8b 03 00 00       	mov    $0x38b,%esi
  8004203853:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420385a:	00 00 00 
  800420385d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203862:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  8004203869:	00 00 00 
  800420386c:	ff d1                	callq  *%rcx
	}

	boot_map_region(boot_pml4e, base, size_rounded, pa_rounded, PTE_PCD|PTE_PWT|PTE_W);
  800420386e:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  8004203875:	00 00 00 
  8004203878:	48 8b 30             	mov    (%rax),%rsi
  800420387b:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004203882:	00 00 00 
  8004203885:	48 8b 00             	mov    (%rax),%rax
  8004203888:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420388c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203890:	41 b8 1a 00 00 00    	mov    $0x1a,%r8d
  8004203896:	48 89 c7             	mov    %rax,%rdi
  8004203899:	48 b8 70 34 20 04 80 	movabs $0x8004203470,%rax
  80042038a0:	00 00 00 
  80042038a3:	ff d0                	callq  *%rax

	// Your code here:
	//panic("mmio_map_region not implemented");i
	
	base = base + size_rounded;	
  80042038a5:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  80042038ac:	00 00 00 
  80042038af:	48 8b 10             	mov    (%rax),%rdx
  80042038b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042038b6:	48 01 c2             	add    %rax,%rdx
  80042038b9:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  80042038c0:	00 00 00 
  80042038c3:	48 89 10             	mov    %rdx,(%rax)
	
	return (void *)(base-size_rounded);
  80042038c6:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  80042038cd:	00 00 00 
  80042038d0:	48 8b 00             	mov    (%rax),%rax
  80042038d3:	48 2b 45 d8          	sub    -0x28(%rbp),%rax
}
  80042038d7:	c9                   	leaveq 
  80042038d8:	c3                   	retq   

00000080042038d9 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  80042038d9:	55                   	push   %rbp
  80042038da:	48 89 e5             	mov    %rsp,%rbp
  80042038dd:	48 83 ec 60          	sub    $0x60,%rsp
  80042038e1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  80042038e5:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  80042038e9:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042038ed:	89 4d a4             	mov    %ecx,-0x5c(%rbp)
	// LAB 3: Your code here.

	//reset permissions
	int new_perm = perm | PTE_P;	
  80042038f0:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80042038f3:	83 c8 01             	or     $0x1,%eax
  80042038f6:	89 45 f4             	mov    %eax,-0xc(%rbp)
	
	void *end = ROUNDUP((void *)va + len, PGSIZE);
  80042038f9:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004203900:	00 
  8004203901:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004203905:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203909:	48 01 d0             	add    %rdx,%rax
  800420390c:	48 89 c2             	mov    %rax,%rdx
  800420390f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203913:	48 01 d0             	add    %rdx,%rax
  8004203916:	48 83 e8 01          	sub    $0x1,%rax
  800420391a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420391e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203922:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203927:	48 f7 75 e8          	divq   -0x18(%rbp)
  800420392b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420392f:	48 29 d0             	sub    %rdx,%rax
  8004203932:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	void *start = ROUNDDOWN((void *)va, PGSIZE);
  8004203936:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420393a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420393e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203942:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203948:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	for(; start < end; start += PGSIZE) {
  800420394c:	e9 fe 00 00 00       	jmpq   8004203a4f <user_mem_check+0x176>
		if ((uint64_t)start >= ULIM){
  8004203951:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203955:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420395c:	00 00 00 
  800420395f:	48 39 c2             	cmp    %rax,%rdx
  8004203962:	76 1b                	jbe    800420397f <user_mem_check+0xa6>
			user_mem_check_addr = (uint64_t)start;
  8004203964:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203968:	48 b8 40 22 36 04 80 	movabs $0x8004362240,%rax
  800420396f:	00 00 00 
  8004203972:	48 89 10             	mov    %rdx,(%rax)
                        return -E_FAULT;
  8004203975:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  800420397a:	e9 e3 00 00 00       	jmpq   8004203a62 <user_mem_check+0x189>
		}

		pte_t *ptr_pte = pml4e_walk(env->env_pml4e, start, 0);
  800420397f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203983:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420398a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420398e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203993:	48 89 ce             	mov    %rcx,%rsi
  8004203996:	48 89 c7             	mov    %rax,%rdi
  8004203999:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  80042039a0:	00 00 00 
  80042039a3:	ff d0                	callq  *%rax
  80042039a5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		if (ptr_pte==NULL){
  80042039a9:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042039ae:	75 3f                	jne    80042039ef <user_mem_check+0x116>
        		user_mem_check_addr = (uint64_t)start;
  80042039b0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042039b4:	48 b8 40 22 36 04 80 	movabs $0x8004362240,%rax
  80042039bb:	00 00 00 
  80042039be:	48 89 10             	mov    %rdx,(%rax)

			//make sure rounding down didn't get wrong faulty addr
			if (user_mem_check_addr < (uintptr_t)va){
  80042039c1:	48 b8 40 22 36 04 80 	movabs $0x8004362240,%rax
  80042039c8:	00 00 00 
  80042039cb:	48 8b 10             	mov    (%rax),%rdx
  80042039ce:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042039d2:	48 39 c2             	cmp    %rax,%rdx
  80042039d5:	73 11                	jae    80042039e8 <user_mem_check+0x10f>
				 user_mem_check_addr = (uint64_t)va;
  80042039d7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042039db:	48 b8 40 22 36 04 80 	movabs $0x8004362240,%rax
  80042039e2:	00 00 00 
  80042039e5:	48 89 10             	mov    %rdx,(%rax)
			}	
	
			return -E_FAULT;
  80042039e8:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  80042039ed:	eb 73                	jmp    8004203a62 <user_mem_check+0x189>
		}
		if ((*ptr_pte & new_perm)!=new_perm){
  80042039ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042039f3:	48 8b 10             	mov    (%rax),%rdx
  80042039f6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042039f9:	48 98                	cltq   
  80042039fb:	48 21 c2             	and    %rax,%rdx
  80042039fe:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004203a01:	48 98                	cltq   
  8004203a03:	48 39 c2             	cmp    %rax,%rdx
  8004203a06:	74 3f                	je     8004203a47 <user_mem_check+0x16e>

			//make sure rounding down didn't get wrong faulty addr
			user_mem_check_addr = (uint64_t)start;
  8004203a08:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203a0c:	48 b8 40 22 36 04 80 	movabs $0x8004362240,%rax
  8004203a13:	00 00 00 
  8004203a16:	48 89 10             	mov    %rdx,(%rax)
                        if (user_mem_check_addr < (uintptr_t)va){
  8004203a19:	48 b8 40 22 36 04 80 	movabs $0x8004362240,%rax
  8004203a20:	00 00 00 
  8004203a23:	48 8b 10             	mov    (%rax),%rdx
  8004203a26:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203a2a:	48 39 c2             	cmp    %rax,%rdx
  8004203a2d:	73 11                	jae    8004203a40 <user_mem_check+0x167>
                                 user_mem_check_addr = (uint64_t)va;
  8004203a2f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004203a33:	48 b8 40 22 36 04 80 	movabs $0x8004362240,%rax
  8004203a3a:	00 00 00 
  8004203a3d:	48 89 10             	mov    %rdx,(%rax)
                        }
			return -E_FAULT;
  8004203a40:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203a45:	eb 1b                	jmp    8004203a62 <user_mem_check+0x189>
	int new_perm = perm | PTE_P;	
	
	void *end = ROUNDUP((void *)va + len, PGSIZE);
	void *start = ROUNDDOWN((void *)va, PGSIZE);

	for(; start < end; start += PGSIZE) {
  8004203a47:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203a4e:	00 
  8004203a4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a53:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203a57:	0f 82 f4 fe ff ff    	jb     8004203951 <user_mem_check+0x78>
                                 user_mem_check_addr = (uint64_t)va;
                        }
			return -E_FAULT;
		}
	}
	return 0;
  8004203a5d:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004203a62:	c9                   	leaveq 
  8004203a63:	c3                   	retq   

0000008004203a64 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  8004203a64:	55                   	push   %rbp
  8004203a65:	48 89 e5             	mov    %rsp,%rbp
  8004203a68:	48 83 ec 20          	sub    $0x20,%rsp
  8004203a6c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203a70:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004203a74:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203a78:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203a7b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203a7e:	83 c8 04             	or     $0x4,%eax
  8004203a81:	89 c1                	mov    %eax,%ecx
  8004203a83:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203a87:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004203a8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a8f:	48 89 c7             	mov    %rax,%rdi
  8004203a92:	48 b8 d9 38 20 04 80 	movabs $0x80042038d9,%rax
  8004203a99:	00 00 00 
  8004203a9c:	ff d0                	callq  *%rax
  8004203a9e:	85 c0                	test   %eax,%eax
  8004203aa0:	79 47                	jns    8004203ae9 <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004203aa2:	48 b8 40 22 36 04 80 	movabs $0x8004362240,%rax
  8004203aa9:	00 00 00 
  8004203aac:	48 8b 10             	mov    (%rax),%rdx
  8004203aaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ab3:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004203ab9:	89 c6                	mov    %eax,%esi
  8004203abb:	48 bf e8 67 21 04 80 	movabs $0x80042167e8,%rdi
  8004203ac2:	00 00 00 
  8004203ac5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203aca:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  8004203ad1:	00 00 00 
  8004203ad4:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  8004203ad6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ada:	48 89 c7             	mov    %rax,%rdi
  8004203add:	48 b8 61 86 20 04 80 	movabs $0x8004208661,%rax
  8004203ae4:	00 00 00 
  8004203ae7:	ff d0                	callq  *%rax
	}
}
  8004203ae9:	90                   	nop
  8004203aea:	c9                   	leaveq 
  8004203aeb:	c3                   	retq   

0000008004203aec <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004203aec:	55                   	push   %rbp
  8004203aed:	48 89 e5             	mov    %rsp,%rbp
  8004203af0:	48 83 ec 60          	sub    $0x60,%rsp
  8004203af4:	89 f8                	mov    %edi,%eax
  8004203af6:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004203af9:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203afd:	74 07                	je     8004203b06 <check_page_free_list+0x1a>
  8004203aff:	b8 01 00 00 00       	mov    $0x1,%eax
  8004203b04:	eb 05                	jmp    8004203b0b <check_page_free_list+0x1f>
  8004203b06:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203b0b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203b0e:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203b15:	00 
  8004203b16:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203b1d:	00 
	char *first_free_page;

	if (!page_free_list)
  8004203b1e:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004203b25:	00 00 00 
  8004203b28:	48 8b 00             	mov    (%rax),%rax
  8004203b2b:	48 85 c0             	test   %rax,%rax
  8004203b2e:	75 2a                	jne    8004203b5a <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004203b30:	48 ba 20 68 21 04 80 	movabs $0x8004216820,%rdx
  8004203b37:	00 00 00 
  8004203b3a:	be fe 03 00 00       	mov    $0x3fe,%esi
  8004203b3f:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203b46:	00 00 00 
  8004203b49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b4e:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  8004203b55:	00 00 00 
  8004203b58:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203b5a:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203b5e:	0f 84 a9 00 00 00    	je     8004203c0d <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  8004203b64:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203b68:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203b6c:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004203b70:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203b74:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004203b7b:	00 00 00 
  8004203b7e:	48 8b 00             	mov    (%rax),%rax
  8004203b81:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203b85:	eb 58                	jmp    8004203bdf <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  8004203b87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b8b:	48 89 c7             	mov    %rax,%rdi
  8004203b8e:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203b95:	00 00 00 
  8004203b98:	ff d0                	callq  *%rax
  8004203b9a:	48 c1 e8 15          	shr    $0x15,%rax
  8004203b9e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203ba3:	48 89 c2             	mov    %rax,%rdx
  8004203ba6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203ba9:	48 39 c2             	cmp    %rax,%rdx
  8004203bac:	0f 93 c0             	setae  %al
  8004203baf:	0f b6 c0             	movzbl %al,%eax
  8004203bb2:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004203bb5:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203bb8:	48 98                	cltq   
  8004203bba:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  8004203bbf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203bc3:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004203bc6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203bca:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203bcd:	48 98                	cltq   
  8004203bcf:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203bd4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203bd8:	48 8b 00             	mov    (%rax),%rax
  8004203bdb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203bdf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203be4:	75 a1                	jne    8004203b87 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004203be6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203bea:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004203bf1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203bf5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203bf9:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004203bfc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203c00:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004203c07:	00 00 00 
  8004203c0a:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203c0d:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004203c14:	00 00 00 
  8004203c17:	48 8b 00             	mov    (%rax),%rax
  8004203c1a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203c1e:	eb 5e                	jmp    8004203c7e <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004203c20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c24:	48 89 c7             	mov    %rax,%rdi
  8004203c27:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203c2e:	00 00 00 
  8004203c31:	ff d0                	callq  *%rax
  8004203c33:	48 c1 e8 15          	shr    $0x15,%rax
  8004203c37:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203c3c:	48 89 c2             	mov    %rax,%rdx
  8004203c3f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203c42:	48 39 c2             	cmp    %rax,%rdx
  8004203c45:	73 2c                	jae    8004203c73 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004203c47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c4b:	48 89 c7             	mov    %rax,%rdi
  8004203c4e:	48 b8 ae 19 20 04 80 	movabs $0x80042019ae,%rax
  8004203c55:	00 00 00 
  8004203c58:	ff d0                	callq  *%rax
  8004203c5a:	ba 80 00 00 00       	mov    $0x80,%edx
  8004203c5f:	be 97 00 00 00       	mov    $0x97,%esi
  8004203c64:	48 89 c7             	mov    %rax,%rdi
  8004203c67:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004203c6e:	00 00 00 
  8004203c71:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203c73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c77:	48 8b 00             	mov    (%rax),%rax
  8004203c7a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203c7e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203c83:	75 9b                	jne    8004203c20 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  8004203c85:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203c8a:	48 b8 d5 22 20 04 80 	movabs $0x80042022d5,%rax
  8004203c91:	00 00 00 
  8004203c94:	ff d0                	callq  *%rax
  8004203c96:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203c9a:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004203ca1:	00 00 00 
  8004203ca4:	48 8b 00             	mov    (%rax),%rax
  8004203ca7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203cab:	e9 20 03 00 00       	jmpq   8004203fd0 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004203cb0:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004203cb7:	00 00 00 
  8004203cba:	48 8b 00             	mov    (%rax),%rax
  8004203cbd:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203cc1:	73 35                	jae    8004203cf8 <check_page_free_list+0x20c>
  8004203cc3:	48 b9 44 68 21 04 80 	movabs $0x8004216844,%rcx
  8004203cca:	00 00 00 
  8004203ccd:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004203cd4:	00 00 00 
  8004203cd7:	be 18 04 00 00       	mov    $0x418,%esi
  8004203cdc:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203ce3:	00 00 00 
  8004203ce6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ceb:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004203cf2:	00 00 00 
  8004203cf5:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004203cf8:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004203cff:	00 00 00 
  8004203d02:	48 8b 10             	mov    (%rax),%rdx
  8004203d05:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004203d0c:	00 00 00 
  8004203d0f:	48 8b 00             	mov    (%rax),%rax
  8004203d12:	48 c1 e0 04          	shl    $0x4,%rax
  8004203d16:	48 01 d0             	add    %rdx,%rax
  8004203d19:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203d1d:	77 35                	ja     8004203d54 <check_page_free_list+0x268>
  8004203d1f:	48 b9 50 68 21 04 80 	movabs $0x8004216850,%rcx
  8004203d26:	00 00 00 
  8004203d29:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004203d30:	00 00 00 
  8004203d33:	be 19 04 00 00       	mov    $0x419,%esi
  8004203d38:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203d3f:	00 00 00 
  8004203d42:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d47:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004203d4e:	00 00 00 
  8004203d51:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004203d54:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203d58:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004203d5f:	00 00 00 
  8004203d62:	48 8b 00             	mov    (%rax),%rax
  8004203d65:	48 29 c2             	sub    %rax,%rdx
  8004203d68:	48 89 d0             	mov    %rdx,%rax
  8004203d6b:	83 e0 0f             	and    $0xf,%eax
  8004203d6e:	48 85 c0             	test   %rax,%rax
  8004203d71:	74 35                	je     8004203da8 <check_page_free_list+0x2bc>
  8004203d73:	48 b9 68 68 21 04 80 	movabs $0x8004216868,%rcx
  8004203d7a:	00 00 00 
  8004203d7d:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004203d84:	00 00 00 
  8004203d87:	be 1a 04 00 00       	mov    $0x41a,%esi
  8004203d8c:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203d93:	00 00 00 
  8004203d96:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d9b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004203da2:	00 00 00 
  8004203da5:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  8004203da8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203dac:	48 89 c7             	mov    %rax,%rdi
  8004203daf:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203db6:	00 00 00 
  8004203db9:	ff d0                	callq  *%rax
  8004203dbb:	48 85 c0             	test   %rax,%rax
  8004203dbe:	75 35                	jne    8004203df5 <check_page_free_list+0x309>
  8004203dc0:	48 b9 9a 68 21 04 80 	movabs $0x800421689a,%rcx
  8004203dc7:	00 00 00 
  8004203dca:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004203dd1:	00 00 00 
  8004203dd4:	be 1d 04 00 00       	mov    $0x41d,%esi
  8004203dd9:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203de0:	00 00 00 
  8004203de3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203de8:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004203def:	00 00 00 
  8004203df2:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  8004203df5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203df9:	48 89 c7             	mov    %rax,%rdi
  8004203dfc:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203e03:	00 00 00 
  8004203e06:	ff d0                	callq  *%rax
  8004203e08:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004203e0e:	75 35                	jne    8004203e45 <check_page_free_list+0x359>
  8004203e10:	48 b9 ab 68 21 04 80 	movabs $0x80042168ab,%rcx
  8004203e17:	00 00 00 
  8004203e1a:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004203e21:	00 00 00 
  8004203e24:	be 1e 04 00 00       	mov    $0x41e,%esi
  8004203e29:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203e30:	00 00 00 
  8004203e33:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e38:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004203e3f:	00 00 00 
  8004203e42:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004203e45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e49:	48 89 c7             	mov    %rax,%rdi
  8004203e4c:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203e53:	00 00 00 
  8004203e56:	ff d0                	callq  *%rax
  8004203e58:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004203e5e:	75 35                	jne    8004203e95 <check_page_free_list+0x3a9>
  8004203e60:	48 b9 c8 68 21 04 80 	movabs $0x80042168c8,%rcx
  8004203e67:	00 00 00 
  8004203e6a:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004203e71:	00 00 00 
  8004203e74:	be 1f 04 00 00       	mov    $0x41f,%esi
  8004203e79:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203e80:	00 00 00 
  8004203e83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e88:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004203e8f:	00 00 00 
  8004203e92:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  8004203e95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e99:	48 89 c7             	mov    %rax,%rdi
  8004203e9c:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203ea3:	00 00 00 
  8004203ea6:	ff d0                	callq  *%rax
  8004203ea8:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004203eae:	75 35                	jne    8004203ee5 <check_page_free_list+0x3f9>
  8004203eb0:	48 b9 eb 68 21 04 80 	movabs $0x80042168eb,%rcx
  8004203eb7:	00 00 00 
  8004203eba:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004203ec1:	00 00 00 
  8004203ec4:	be 20 04 00 00       	mov    $0x420,%esi
  8004203ec9:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203ed0:	00 00 00 
  8004203ed3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ed8:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004203edf:	00 00 00 
  8004203ee2:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  8004203ee5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ee9:	48 89 c7             	mov    %rax,%rdi
  8004203eec:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203ef3:	00 00 00 
  8004203ef6:	ff d0                	callq  *%rax
  8004203ef8:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203efe:	76 4e                	jbe    8004203f4e <check_page_free_list+0x462>
  8004203f00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f04:	48 89 c7             	mov    %rax,%rdi
  8004203f07:	48 b8 ae 19 20 04 80 	movabs $0x80042019ae,%rax
  8004203f0e:	00 00 00 
  8004203f11:	ff d0                	callq  *%rax
  8004203f13:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203f17:	73 35                	jae    8004203f4e <check_page_free_list+0x462>
  8004203f19:	48 b9 08 69 21 04 80 	movabs $0x8004216908,%rcx
  8004203f20:	00 00 00 
  8004203f23:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004203f2a:	00 00 00 
  8004203f2d:	be 21 04 00 00       	mov    $0x421,%esi
  8004203f32:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203f39:	00 00 00 
  8004203f3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f41:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004203f48:	00 00 00 
  8004203f4b:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004203f4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f52:	48 89 c7             	mov    %rax,%rdi
  8004203f55:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203f5c:	00 00 00 
  8004203f5f:	ff d0                	callq  *%rax
  8004203f61:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004203f67:	75 35                	jne    8004203f9e <check_page_free_list+0x4b2>
  8004203f69:	48 b9 4d 69 21 04 80 	movabs $0x800421694d,%rcx
  8004203f70:	00 00 00 
  8004203f73:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004203f7a:	00 00 00 
  8004203f7d:	be 23 04 00 00       	mov    $0x423,%esi
  8004203f82:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004203f89:	00 00 00 
  8004203f8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f91:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004203f98:	00 00 00 
  8004203f9b:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004203f9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203fa2:	48 89 c7             	mov    %rax,%rdi
  8004203fa5:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004203fac:	00 00 00 
  8004203faf:	ff d0                	callq  *%rax
  8004203fb1:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203fb7:	77 07                	ja     8004203fc0 <check_page_free_list+0x4d4>
			++nfree_basemem;
  8004203fb9:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004203fbe:	eb 05                	jmp    8004203fc5 <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  8004203fc0:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203fc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203fc9:	48 8b 00             	mov    (%rax),%rax
  8004203fcc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203fd0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203fd5:	0f 85 d5 fc ff ff    	jne    8004203cb0 <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  8004203fdb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203fe0:	75 35                	jne    8004204017 <check_page_free_list+0x52b>
  8004203fe2:	48 b9 6a 69 21 04 80 	movabs $0x800421696a,%rcx
  8004203fe9:	00 00 00 
  8004203fec:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004203ff3:	00 00 00 
  8004203ff6:	be 2b 04 00 00       	mov    $0x42b,%esi
  8004203ffb:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204002:	00 00 00 
  8004204005:	b8 00 00 00 00       	mov    $0x0,%eax
  800420400a:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204011:	00 00 00 
  8004204014:	41 ff d0             	callq  *%r8
}
  8004204017:	90                   	nop
  8004204018:	c9                   	leaveq 
  8004204019:	c3                   	retq   

000000800420401a <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  800420401a:	55                   	push   %rbp
  800420401b:	48 89 e5             	mov    %rsp,%rbp
  800420401e:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204022:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004204029:	00 00 00 
  800420402c:	48 8b 00             	mov    (%rax),%rax
  800420402f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204033:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  800420403a:	eb 37                	jmp    8004204073 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  800420403c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204040:	48 89 c7             	mov    %rax,%rdi
  8004204043:	48 b8 ae 19 20 04 80 	movabs $0x80042019ae,%rax
  800420404a:	00 00 00 
  800420404d:	ff d0                	callq  *%rax
  800420404f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204054:	be 97 00 00 00       	mov    $0x97,%esi
  8004204059:	48 89 c7             	mov    %rax,%rdi
  800420405c:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004204063:	00 00 00 
  8004204066:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204068:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420406c:	48 8b 00             	mov    (%rax),%rax
  800420406f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204073:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204078:	75 c2                	jne    800420403c <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420407a:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004204081:	00 00 00 
  8004204084:	48 8b 00             	mov    (%rax),%rax
  8004204087:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420408b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204092:	e9 ec 01 00 00       	jmpq   8004204283 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  8004204097:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  800420409e:	00 00 00 
  80042040a1:	48 8b 00             	mov    (%rax),%rax
  80042040a4:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042040a8:	73 35                	jae    80042040df <check_page_alloc+0xc5>
  80042040aa:	48 b9 7b 69 21 04 80 	movabs $0x800421697b,%rcx
  80042040b1:	00 00 00 
  80042040b4:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042040bb:	00 00 00 
  80042040be:	be 45 04 00 00       	mov    $0x445,%esi
  80042040c3:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042040ca:	00 00 00 
  80042040cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040d2:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042040d9:	00 00 00 
  80042040dc:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  80042040df:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  80042040e6:	00 00 00 
  80042040e9:	48 8b 10             	mov    (%rax),%rdx
  80042040ec:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042040f3:	00 00 00 
  80042040f6:	48 8b 00             	mov    (%rax),%rax
  80042040f9:	48 c1 e0 04          	shl    $0x4,%rax
  80042040fd:	48 01 d0             	add    %rdx,%rax
  8004204100:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204104:	77 35                	ja     800420413b <check_page_alloc+0x121>
  8004204106:	48 b9 88 69 21 04 80 	movabs $0x8004216988,%rcx
  800420410d:	00 00 00 
  8004204110:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204117:	00 00 00 
  800420411a:	be 46 04 00 00       	mov    $0x446,%esi
  800420411f:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204126:	00 00 00 
  8004204129:	b8 00 00 00 00       	mov    $0x0,%eax
  800420412e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204135:	00 00 00 
  8004204138:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  800420413b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420413f:	48 89 c7             	mov    %rax,%rdi
  8004204142:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004204149:	00 00 00 
  800420414c:	ff d0                	callq  *%rax
  800420414e:	48 85 c0             	test   %rax,%rax
  8004204151:	75 35                	jne    8004204188 <check_page_alloc+0x16e>
  8004204153:	48 b9 9d 69 21 04 80 	movabs $0x800421699d,%rcx
  800420415a:	00 00 00 
  800420415d:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204164:	00 00 00 
  8004204167:	be 49 04 00 00       	mov    $0x449,%esi
  800420416c:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204173:	00 00 00 
  8004204176:	b8 00 00 00 00       	mov    $0x0,%eax
  800420417b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204182:	00 00 00 
  8004204185:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  8004204188:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420418c:	48 89 c7             	mov    %rax,%rdi
  800420418f:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004204196:	00 00 00 
  8004204199:	ff d0                	callq  *%rax
  800420419b:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042041a1:	75 35                	jne    80042041d8 <check_page_alloc+0x1be>
  80042041a3:	48 b9 af 69 21 04 80 	movabs $0x80042169af,%rcx
  80042041aa:	00 00 00 
  80042041ad:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042041b4:	00 00 00 
  80042041b7:	be 4a 04 00 00       	mov    $0x44a,%esi
  80042041bc:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042041c3:	00 00 00 
  80042041c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041cb:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042041d2:	00 00 00 
  80042041d5:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  80042041d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041dc:	48 89 c7             	mov    %rax,%rdi
  80042041df:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  80042041e6:	00 00 00 
  80042041e9:	ff d0                	callq  *%rax
  80042041eb:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  80042041f1:	75 35                	jne    8004204228 <check_page_alloc+0x20e>
  80042041f3:	48 b9 d0 69 21 04 80 	movabs $0x80042169d0,%rcx
  80042041fa:	00 00 00 
  80042041fd:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204204:	00 00 00 
  8004204207:	be 4b 04 00 00       	mov    $0x44b,%esi
  800420420c:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204213:	00 00 00 
  8004204216:	b8 00 00 00 00       	mov    $0x0,%eax
  800420421b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204222:	00 00 00 
  8004204225:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004204228:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420422c:	48 89 c7             	mov    %rax,%rdi
  800420422f:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004204236:	00 00 00 
  8004204239:	ff d0                	callq  *%rax
  800420423b:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204241:	75 35                	jne    8004204278 <check_page_alloc+0x25e>
  8004204243:	48 b9 f4 69 21 04 80 	movabs $0x80042169f4,%rcx
  800420424a:	00 00 00 
  800420424d:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204254:	00 00 00 
  8004204257:	be 4c 04 00 00       	mov    $0x44c,%esi
  800420425c:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204263:	00 00 00 
  8004204266:	b8 00 00 00 00       	mov    $0x0,%eax
  800420426b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204272:	00 00 00 
  8004204275:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204278:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420427c:	48 8b 00             	mov    (%rax),%rax
  800420427f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204283:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204288:	0f 85 09 fe ff ff    	jne    8004204097 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  800420428e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204295:	00 
  8004204296:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420429a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420429e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042042a2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  80042042a6:	bf 00 00 00 00       	mov    $0x0,%edi
  80042042ab:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  80042042b2:	00 00 00 
  80042042b5:	ff d0                	callq  *%rax
  80042042b7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042042bb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042042c0:	75 35                	jne    80042042f7 <check_page_alloc+0x2dd>
  80042042c2:	48 b9 0f 6a 21 04 80 	movabs $0x8004216a0f,%rcx
  80042042c9:	00 00 00 
  80042042cc:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042042d3:	00 00 00 
  80042042d6:	be 50 04 00 00       	mov    $0x450,%esi
  80042042db:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042042e2:	00 00 00 
  80042042e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042ea:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042042f1:	00 00 00 
  80042042f4:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  80042042f7:	bf 00 00 00 00       	mov    $0x0,%edi
  80042042fc:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004204303:	00 00 00 
  8004204306:	ff d0                	callq  *%rax
  8004204308:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420430c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204311:	75 35                	jne    8004204348 <check_page_alloc+0x32e>
  8004204313:	48 b9 25 6a 21 04 80 	movabs $0x8004216a25,%rcx
  800420431a:	00 00 00 
  800420431d:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204324:	00 00 00 
  8004204327:	be 51 04 00 00       	mov    $0x451,%esi
  800420432c:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204333:	00 00 00 
  8004204336:	b8 00 00 00 00       	mov    $0x0,%eax
  800420433b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204342:	00 00 00 
  8004204345:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204348:	bf 00 00 00 00       	mov    $0x0,%edi
  800420434d:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004204354:	00 00 00 
  8004204357:	ff d0                	callq  *%rax
  8004204359:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420435d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204362:	75 35                	jne    8004204399 <check_page_alloc+0x37f>
  8004204364:	48 b9 3b 6a 21 04 80 	movabs $0x8004216a3b,%rcx
  800420436b:	00 00 00 
  800420436e:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204375:	00 00 00 
  8004204378:	be 52 04 00 00       	mov    $0x452,%esi
  800420437d:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204384:	00 00 00 
  8004204387:	b8 00 00 00 00       	mov    $0x0,%eax
  800420438c:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204393:	00 00 00 
  8004204396:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204399:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420439e:	75 35                	jne    80042043d5 <check_page_alloc+0x3bb>
  80042043a0:	48 b9 51 6a 21 04 80 	movabs $0x8004216a51,%rcx
  80042043a7:	00 00 00 
  80042043aa:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042043b1:	00 00 00 
  80042043b4:	be 53 04 00 00       	mov    $0x453,%esi
  80042043b9:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042043c0:	00 00 00 
  80042043c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043c8:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042043cf:	00 00 00 
  80042043d2:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  80042043d5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042043da:	74 0a                	je     80042043e6 <check_page_alloc+0x3cc>
  80042043dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042043e0:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042043e4:	75 35                	jne    800420441b <check_page_alloc+0x401>
  80042043e6:	48 b9 55 6a 21 04 80 	movabs $0x8004216a55,%rcx
  80042043ed:	00 00 00 
  80042043f0:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042043f7:	00 00 00 
  80042043fa:	be 54 04 00 00       	mov    $0x454,%esi
  80042043ff:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204406:	00 00 00 
  8004204409:	b8 00 00 00 00       	mov    $0x0,%eax
  800420440e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204415:	00 00 00 
  8004204418:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  800420441b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204420:	74 14                	je     8004204436 <check_page_alloc+0x41c>
  8004204422:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204426:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420442a:	74 0a                	je     8004204436 <check_page_alloc+0x41c>
  800420442c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204430:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204434:	75 35                	jne    800420446b <check_page_alloc+0x451>
  8004204436:	48 b9 68 6a 21 04 80 	movabs $0x8004216a68,%rcx
  800420443d:	00 00 00 
  8004204440:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204447:	00 00 00 
  800420444a:	be 55 04 00 00       	mov    $0x455,%esi
  800420444f:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204456:	00 00 00 
  8004204459:	b8 00 00 00 00       	mov    $0x0,%eax
  800420445e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204465:	00 00 00 
  8004204468:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  800420446b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420446f:	48 89 c7             	mov    %rax,%rdi
  8004204472:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004204479:	00 00 00 
  800420447c:	ff d0                	callq  *%rax
  800420447e:	48 89 c2             	mov    %rax,%rdx
  8004204481:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004204488:	00 00 00 
  800420448b:	48 8b 00             	mov    (%rax),%rax
  800420448e:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204492:	48 39 c2             	cmp    %rax,%rdx
  8004204495:	72 35                	jb     80042044cc <check_page_alloc+0x4b2>
  8004204497:	48 b9 88 6a 21 04 80 	movabs $0x8004216a88,%rcx
  800420449e:	00 00 00 
  80042044a1:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042044a8:	00 00 00 
  80042044ab:	be 56 04 00 00       	mov    $0x456,%esi
  80042044b0:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042044b7:	00 00 00 
  80042044ba:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044bf:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042044c6:	00 00 00 
  80042044c9:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  80042044cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042044d0:	48 89 c7             	mov    %rax,%rdi
  80042044d3:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  80042044da:	00 00 00 
  80042044dd:	ff d0                	callq  *%rax
  80042044df:	48 89 c2             	mov    %rax,%rdx
  80042044e2:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042044e9:	00 00 00 
  80042044ec:	48 8b 00             	mov    (%rax),%rax
  80042044ef:	48 c1 e0 0c          	shl    $0xc,%rax
  80042044f3:	48 39 c2             	cmp    %rax,%rdx
  80042044f6:	72 35                	jb     800420452d <check_page_alloc+0x513>
  80042044f8:	48 b9 a5 6a 21 04 80 	movabs $0x8004216aa5,%rcx
  80042044ff:	00 00 00 
  8004204502:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204509:	00 00 00 
  800420450c:	be 57 04 00 00       	mov    $0x457,%esi
  8004204511:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204518:	00 00 00 
  800420451b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204520:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204527:	00 00 00 
  800420452a:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  800420452d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204531:	48 89 c7             	mov    %rax,%rdi
  8004204534:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  800420453b:	00 00 00 
  800420453e:	ff d0                	callq  *%rax
  8004204540:	48 89 c2             	mov    %rax,%rdx
  8004204543:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  800420454a:	00 00 00 
  800420454d:	48 8b 00             	mov    (%rax),%rax
  8004204550:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204554:	48 39 c2             	cmp    %rax,%rdx
  8004204557:	72 35                	jb     800420458e <check_page_alloc+0x574>
  8004204559:	48 b9 c2 6a 21 04 80 	movabs $0x8004216ac2,%rcx
  8004204560:	00 00 00 
  8004204563:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420456a:	00 00 00 
  800420456d:	be 58 04 00 00       	mov    $0x458,%esi
  8004204572:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204579:	00 00 00 
  800420457c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204581:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204588:	00 00 00 
  800420458b:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  800420458e:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004204595:	00 00 00 
  8004204598:	48 8b 00             	mov    (%rax),%rax
  800420459b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  800420459f:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  80042045a6:	00 00 00 
  80042045a9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  80042045b0:	bf 00 00 00 00       	mov    $0x0,%edi
  80042045b5:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  80042045bc:	00 00 00 
  80042045bf:	ff d0                	callq  *%rax
  80042045c1:	48 85 c0             	test   %rax,%rax
  80042045c4:	74 35                	je     80042045fb <check_page_alloc+0x5e1>
  80042045c6:	48 b9 df 6a 21 04 80 	movabs $0x8004216adf,%rcx
  80042045cd:	00 00 00 
  80042045d0:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042045d7:	00 00 00 
  80042045da:	be 5f 04 00 00       	mov    $0x45f,%esi
  80042045df:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042045e6:	00 00 00 
  80042045e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045ee:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042045f5:	00 00 00 
  80042045f8:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  80042045fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045ff:	48 89 c7             	mov    %rax,%rdi
  8004204602:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  8004204609:	00 00 00 
  800420460c:	ff d0                	callq  *%rax
	page_free(pp1);
  800420460e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204612:	48 89 c7             	mov    %rax,%rdi
  8004204615:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  800420461c:	00 00 00 
  800420461f:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204621:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204625:	48 89 c7             	mov    %rax,%rdi
  8004204628:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  800420462f:	00 00 00 
  8004204632:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204634:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420463b:	00 
  800420463c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204640:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204644:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204648:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  800420464c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204651:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004204658:	00 00 00 
  800420465b:	ff d0                	callq  *%rax
  800420465d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204661:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204666:	75 35                	jne    800420469d <check_page_alloc+0x683>
  8004204668:	48 b9 0f 6a 21 04 80 	movabs $0x8004216a0f,%rcx
  800420466f:	00 00 00 
  8004204672:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204679:	00 00 00 
  800420467c:	be 66 04 00 00       	mov    $0x466,%esi
  8004204681:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204688:	00 00 00 
  800420468b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204690:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204697:	00 00 00 
  800420469a:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  800420469d:	bf 00 00 00 00       	mov    $0x0,%edi
  80042046a2:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  80042046a9:	00 00 00 
  80042046ac:	ff d0                	callq  *%rax
  80042046ae:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042046b2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042046b7:	75 35                	jne    80042046ee <check_page_alloc+0x6d4>
  80042046b9:	48 b9 25 6a 21 04 80 	movabs $0x8004216a25,%rcx
  80042046c0:	00 00 00 
  80042046c3:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042046ca:	00 00 00 
  80042046cd:	be 67 04 00 00       	mov    $0x467,%esi
  80042046d2:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042046d9:	00 00 00 
  80042046dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046e1:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042046e8:	00 00 00 
  80042046eb:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  80042046ee:	bf 00 00 00 00       	mov    $0x0,%edi
  80042046f3:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  80042046fa:	00 00 00 
  80042046fd:	ff d0                	callq  *%rax
  80042046ff:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204703:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204708:	75 35                	jne    800420473f <check_page_alloc+0x725>
  800420470a:	48 b9 3b 6a 21 04 80 	movabs $0x8004216a3b,%rcx
  8004204711:	00 00 00 
  8004204714:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420471b:	00 00 00 
  800420471e:	be 68 04 00 00       	mov    $0x468,%esi
  8004204723:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420472a:	00 00 00 
  800420472d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204732:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204739:	00 00 00 
  800420473c:	41 ff d0             	callq  *%r8
	assert(pp0);
  800420473f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204744:	75 35                	jne    800420477b <check_page_alloc+0x761>
  8004204746:	48 b9 51 6a 21 04 80 	movabs $0x8004216a51,%rcx
  800420474d:	00 00 00 
  8004204750:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204757:	00 00 00 
  800420475a:	be 69 04 00 00       	mov    $0x469,%esi
  800420475f:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204766:	00 00 00 
  8004204769:	b8 00 00 00 00       	mov    $0x0,%eax
  800420476e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204775:	00 00 00 
  8004204778:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  800420477b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204780:	74 0a                	je     800420478c <check_page_alloc+0x772>
  8004204782:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204786:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420478a:	75 35                	jne    80042047c1 <check_page_alloc+0x7a7>
  800420478c:	48 b9 55 6a 21 04 80 	movabs $0x8004216a55,%rcx
  8004204793:	00 00 00 
  8004204796:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420479d:	00 00 00 
  80042047a0:	be 6a 04 00 00       	mov    $0x46a,%esi
  80042047a5:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042047ac:	00 00 00 
  80042047af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047b4:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042047bb:	00 00 00 
  80042047be:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  80042047c1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042047c6:	74 14                	je     80042047dc <check_page_alloc+0x7c2>
  80042047c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042047cc:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042047d0:	74 0a                	je     80042047dc <check_page_alloc+0x7c2>
  80042047d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042047d6:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042047da:	75 35                	jne    8004204811 <check_page_alloc+0x7f7>
  80042047dc:	48 b9 68 6a 21 04 80 	movabs $0x8004216a68,%rcx
  80042047e3:	00 00 00 
  80042047e6:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042047ed:	00 00 00 
  80042047f0:	be 6b 04 00 00       	mov    $0x46b,%esi
  80042047f5:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042047fc:	00 00 00 
  80042047ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204804:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420480b:	00 00 00 
  800420480e:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204811:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204816:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  800420481d:	00 00 00 
  8004204820:	ff d0                	callq  *%rax
  8004204822:	48 85 c0             	test   %rax,%rax
  8004204825:	74 35                	je     800420485c <check_page_alloc+0x842>
  8004204827:	48 b9 df 6a 21 04 80 	movabs $0x8004216adf,%rcx
  800420482e:	00 00 00 
  8004204831:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204838:	00 00 00 
  800420483b:	be 6c 04 00 00       	mov    $0x46c,%esi
  8004204840:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204847:	00 00 00 
  800420484a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420484f:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204856:	00 00 00 
  8004204859:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  800420485c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204860:	48 89 c7             	mov    %rax,%rdi
  8004204863:	48 b8 ae 19 20 04 80 	movabs $0x80042019ae,%rax
  800420486a:	00 00 00 
  800420486d:	ff d0                	callq  *%rax
  800420486f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204874:	be 01 00 00 00       	mov    $0x1,%esi
  8004204879:	48 89 c7             	mov    %rax,%rdi
  800420487c:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004204883:	00 00 00 
  8004204886:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204888:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420488c:	48 89 c7             	mov    %rax,%rdi
  800420488f:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  8004204896:	00 00 00 
  8004204899:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  800420489b:	bf 01 00 00 00       	mov    $0x1,%edi
  80042048a0:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  80042048a7:	00 00 00 
  80042048aa:	ff d0                	callq  *%rax
  80042048ac:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042048b0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042048b5:	75 35                	jne    80042048ec <check_page_alloc+0x8d2>
  80042048b7:	48 b9 ee 6a 21 04 80 	movabs $0x8004216aee,%rcx
  80042048be:	00 00 00 
  80042048c1:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042048c8:	00 00 00 
  80042048cb:	be 71 04 00 00       	mov    $0x471,%esi
  80042048d0:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042048d7:	00 00 00 
  80042048da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048df:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042048e6:	00 00 00 
  80042048e9:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  80042048ec:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042048f1:	74 0a                	je     80042048fd <check_page_alloc+0x8e3>
  80042048f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048f7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042048fb:	74 35                	je     8004204932 <check_page_alloc+0x918>
  80042048fd:	48 b9 0c 6b 21 04 80 	movabs $0x8004216b0c,%rcx
  8004204904:	00 00 00 
  8004204907:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420490e:	00 00 00 
  8004204911:	be 72 04 00 00       	mov    $0x472,%esi
  8004204916:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420491d:	00 00 00 
  8004204920:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204925:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420492c:	00 00 00 
  800420492f:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004204932:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204936:	48 89 c7             	mov    %rax,%rdi
  8004204939:	48 b8 ae 19 20 04 80 	movabs $0x80042019ae,%rax
  8004204940:	00 00 00 
  8004204943:	ff d0                	callq  *%rax
  8004204945:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004204949:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204950:	eb 4d                	jmp    800420499f <check_page_alloc+0x985>
		assert(c[i] == 0);
  8004204952:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004204955:	48 63 d0             	movslq %eax,%rdx
  8004204958:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420495c:	48 01 d0             	add    %rdx,%rax
  800420495f:	0f b6 00             	movzbl (%rax),%eax
  8004204962:	84 c0                	test   %al,%al
  8004204964:	74 35                	je     800420499b <check_page_alloc+0x981>
  8004204966:	48 b9 1c 6b 21 04 80 	movabs $0x8004216b1c,%rcx
  800420496d:	00 00 00 
  8004204970:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204977:	00 00 00 
  800420497a:	be 75 04 00 00       	mov    $0x475,%esi
  800420497f:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204986:	00 00 00 
  8004204989:	b8 00 00 00 00       	mov    $0x0,%eax
  800420498e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204995:	00 00 00 
  8004204998:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  800420499b:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800420499f:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  80042049a6:	7e aa                	jle    8004204952 <check_page_alloc+0x938>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  80042049a8:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  80042049af:	00 00 00 
  80042049b2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042049b6:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  80042049b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042049bd:	48 89 c7             	mov    %rax,%rdi
  80042049c0:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  80042049c7:	00 00 00 
  80042049ca:	ff d0                	callq  *%rax
	page_free(pp1);
  80042049cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042049d0:	48 89 c7             	mov    %rax,%rdi
  80042049d3:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  80042049da:	00 00 00 
  80042049dd:	ff d0                	callq  *%rax
	page_free(pp2);
  80042049df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042049e3:	48 89 c7             	mov    %rax,%rdi
  80042049e6:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  80042049ed:	00 00 00 
  80042049f0:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  80042049f2:	48 bf 28 6b 21 04 80 	movabs $0x8004216b28,%rdi
  80042049f9:	00 00 00 
  80042049fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a01:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004204a08:	00 00 00 
  8004204a0b:	ff d2                	callq  *%rdx
}
  8004204a0d:	90                   	nop
  8004204a0e:	c9                   	leaveq 
  8004204a0f:	c3                   	retq   

0000008004204a10 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004204a10:	55                   	push   %rbp
  8004204a11:	48 89 e5             	mov    %rsp,%rbp
  8004204a14:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004204a1b:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004204a22:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004204a29:	00 00 00 
  8004204a2c:	48 8b 00             	mov    (%rax),%rax
  8004204a2f:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004204a36:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004204a3d:	00 
  8004204a3e:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004204a45:	00 00 00 
  8004204a48:	48 8b 00             	mov    (%rax),%rax
  8004204a4b:	48 c1 e0 04          	shl    $0x4,%rax
  8004204a4f:	48 89 c2             	mov    %rax,%rdx
  8004204a52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a56:	48 01 d0             	add    %rdx,%rax
  8004204a59:	48 83 e8 01          	sub    $0x1,%rax
  8004204a5d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204a61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a65:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204a6a:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004204a6e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a72:	48 29 d0             	sub    %rdx,%rax
  8004204a75:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004204a79:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204a80:	00 
  8004204a81:	e9 da 00 00 00       	jmpq   8004204b60 <check_boot_pml4e+0x150>
		//cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204a86:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  8004204a8d:	00 00 00 
  8004204a90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a94:	48 01 c2             	add    %rax,%rdx
  8004204a97:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204a9e:	48 89 d6             	mov    %rdx,%rsi
  8004204aa1:	48 89 c7             	mov    %rax,%rdi
  8004204aa4:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004204aab:	00 00 00 
  8004204aae:	ff d0                	callq  *%rax
  8004204ab0:	48 89 c1             	mov    %rax,%rcx
  8004204ab3:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  8004204aba:	00 00 00 
  8004204abd:	48 8b 00             	mov    (%rax),%rax
  8004204ac0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204ac4:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004204acb:	00 00 00 
  8004204ace:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004204ad2:	77 32                	ja     8004204b06 <check_boot_pml4e+0xf6>
  8004204ad4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204ad8:	48 89 c1             	mov    %rax,%rcx
  8004204adb:	48 ba 70 67 21 04 80 	movabs $0x8004216770,%rdx
  8004204ae2:	00 00 00 
  8004204ae5:	be 95 04 00 00       	mov    $0x495,%esi
  8004204aea:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204af1:	00 00 00 
  8004204af4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204af9:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204b00:	00 00 00 
  8004204b03:	41 ff d0             	callq  *%r8
  8004204b06:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004204b0d:	ff ff ff 
  8004204b10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204b14:	48 01 c2             	add    %rax,%rdx
  8004204b17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b1b:	48 01 d0             	add    %rdx,%rax
  8004204b1e:	48 39 c1             	cmp    %rax,%rcx
  8004204b21:	74 35                	je     8004204b58 <check_boot_pml4e+0x148>
  8004204b23:	48 b9 48 6b 21 04 80 	movabs $0x8004216b48,%rcx
  8004204b2a:	00 00 00 
  8004204b2d:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204b34:	00 00 00 
  8004204b37:	be 95 04 00 00       	mov    $0x495,%esi
  8004204b3c:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204b43:	00 00 00 
  8004204b46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b4b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204b52:	00 00 00 
  8004204b55:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204b58:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204b5f:	00 
  8004204b60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b64:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204b68:	0f 82 18 ff ff ff    	jb     8004204a86 <check_boot_pml4e+0x76>
		//cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004204b6e:	48 c7 45 d0 00 10 00 	movq   $0x1000,-0x30(%rbp)
  8004204b75:	00 
  8004204b76:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204b7a:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  8004204b80:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204b84:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204b88:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204b8d:	48 f7 75 d0          	divq   -0x30(%rbp)
  8004204b91:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204b95:	48 29 d0             	sub    %rdx,%rax
  8004204b98:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  8004204b9c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204ba3:	00 
  8004204ba4:	e9 da 00 00 00       	jmpq   8004204c83 <check_boot_pml4e+0x273>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004204ba9:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8004204bb0:	00 00 00 
  8004204bb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204bb7:	48 01 c2             	add    %rax,%rdx
  8004204bba:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204bc1:	48 89 d6             	mov    %rdx,%rsi
  8004204bc4:	48 89 c7             	mov    %rax,%rdi
  8004204bc7:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004204bce:	00 00 00 
  8004204bd1:	ff d0                	callq  *%rax
  8004204bd3:	48 89 c1             	mov    %rax,%rcx
  8004204bd6:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  8004204bdd:	00 00 00 
  8004204be0:	48 8b 00             	mov    (%rax),%rax
  8004204be3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204be7:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004204bee:	00 00 00 
  8004204bf1:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004204bf5:	77 32                	ja     8004204c29 <check_boot_pml4e+0x219>
  8004204bf7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204bfb:	48 89 c1             	mov    %rax,%rcx
  8004204bfe:	48 ba 70 67 21 04 80 	movabs $0x8004216770,%rdx
  8004204c05:	00 00 00 
  8004204c08:	be 9b 04 00 00       	mov    $0x49b,%esi
  8004204c0d:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204c14:	00 00 00 
  8004204c17:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c1c:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204c23:	00 00 00 
  8004204c26:	41 ff d0             	callq  *%r8
  8004204c29:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004204c30:	ff ff ff 
  8004204c33:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204c37:	48 01 c2             	add    %rax,%rdx
  8004204c3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c3e:	48 01 d0             	add    %rdx,%rax
  8004204c41:	48 39 c1             	cmp    %rax,%rcx
  8004204c44:	74 35                	je     8004204c7b <check_boot_pml4e+0x26b>
  8004204c46:	48 b9 80 6b 21 04 80 	movabs $0x8004216b80,%rcx
  8004204c4d:	00 00 00 
  8004204c50:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204c57:	00 00 00 
  8004204c5a:	be 9b 04 00 00       	mov    $0x49b,%esi
  8004204c5f:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204c66:	00 00 00 
  8004204c69:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c6e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204c75:	00 00 00 
  8004204c78:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004204c7b:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204c82:	00 
  8004204c83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c87:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204c8b:	0f 82 18 ff ff ff    	jb     8004204ba9 <check_boot_pml4e+0x199>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204c91:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204c98:	00 
  8004204c99:	eb 6d                	jmp    8004204d08 <check_boot_pml4e+0x2f8>
		//if (check_va2pa(pml4e, KERNBASE + i)!=i)
		//	cprintf("va: %p i: %d\n", check_va2pa(pml4e, KERNBASE + i), i);
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  8004204c9b:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204ca2:	00 00 00 
  8004204ca5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ca9:	48 01 c2             	add    %rax,%rdx
  8004204cac:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204cb3:	48 89 d6             	mov    %rdx,%rsi
  8004204cb6:	48 89 c7             	mov    %rax,%rdi
  8004204cb9:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004204cc0:	00 00 00 
  8004204cc3:	ff d0                	callq  *%rax
  8004204cc5:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204cc9:	74 35                	je     8004204d00 <check_boot_pml4e+0x2f0>
  8004204ccb:	48 b9 b8 6b 21 04 80 	movabs $0x8004216bb8,%rcx
  8004204cd2:	00 00 00 
  8004204cd5:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204cdc:	00 00 00 
  8004204cdf:	be a1 04 00 00       	mov    $0x4a1,%esi
  8004204ce4:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204ceb:	00 00 00 
  8004204cee:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cf3:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204cfa:	00 00 00 
  8004204cfd:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204d00:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204d07:	00 
  8004204d08:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004204d0f:	00 00 00 
  8004204d12:	48 8b 00             	mov    (%rax),%rax
  8004204d15:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204d19:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204d1d:	0f 87 78 ff ff ff    	ja     8004204c9b <check_boot_pml4e+0x28b>
		//	cprintf("va: %p i: %d\n", check_va2pa(pml4e, KERNBASE + i), i);
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004204d23:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004204d2a:	00 
  8004204d2b:	e9 aa 01 00 00       	jmpq   8004204eda <check_boot_pml4e+0x4ca>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004204d30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204d34:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004204d38:	48 89 d0             	mov    %rdx,%rax
  8004204d3b:	48 01 c0             	add    %rax,%rax
  8004204d3e:	48 01 d0             	add    %rdx,%rax
  8004204d41:	48 c1 e0 0f          	shl    $0xf,%rax
  8004204d45:	48 89 c2             	mov    %rax,%rdx
  8004204d48:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004204d4f:	00 00 00 
  8004204d52:	48 29 d0             	sub    %rdx,%rax
  8004204d55:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204d59:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204d60:	00 
  8004204d61:	e9 e6 00 00 00       	jmpq   8004204e4c <check_boot_pml4e+0x43c>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004204d66:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004204d6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d6e:	48 01 d0             	add    %rdx,%rax
  8004204d71:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004204d78:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204d7f:	48 89 d6             	mov    %rdx,%rsi
  8004204d82:	48 89 c7             	mov    %rax,%rdi
  8004204d85:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004204d8c:	00 00 00 
  8004204d8f:	ff d0                	callq  *%rax
  8004204d91:	48 89 c1             	mov    %rax,%rcx
  8004204d94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004204d98:	48 c1 e0 10          	shl    $0x10,%rax
  8004204d9c:	48 89 c2             	mov    %rax,%rdx
  8004204d9f:	48 b8 00 60 36 04 80 	movabs $0x8004366000,%rax
  8004204da6:	00 00 00 
  8004204da9:	48 01 d0             	add    %rdx,%rax
  8004204dac:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004204db0:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004204db7:	00 00 00 
  8004204dba:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  8004204dbe:	77 32                	ja     8004204df2 <check_boot_pml4e+0x3e2>
  8004204dc0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004204dc4:	48 89 c1             	mov    %rax,%rcx
  8004204dc7:	48 ba 70 67 21 04 80 	movabs $0x8004216770,%rdx
  8004204dce:	00 00 00 
  8004204dd1:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004204dd6:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204ddd:	00 00 00 
  8004204de0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204de5:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204dec:	00 00 00 
  8004204def:	41 ff d0             	callq  *%r8
  8004204df2:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004204df9:	ff ff ff 
  8004204dfc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004204e00:	48 01 c2             	add    %rax,%rdx
  8004204e03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e07:	48 01 d0             	add    %rdx,%rax
  8004204e0a:	48 39 c1             	cmp    %rax,%rcx
  8004204e0d:	74 35                	je     8004204e44 <check_boot_pml4e+0x434>
  8004204e0f:	48 b9 e0 6b 21 04 80 	movabs $0x8004216be0,%rcx
  8004204e16:	00 00 00 
  8004204e19:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204e20:	00 00 00 
  8004204e23:	be a9 04 00 00       	mov    $0x4a9,%esi
  8004204e28:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204e2f:	00 00 00 
  8004204e32:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e37:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204e3e:	00 00 00 
  8004204e41:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204e44:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204e4b:	00 
  8004204e4c:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  8004204e53:	00 
  8004204e54:	0f 86 0c ff ff ff    	jbe    8004204d66 <check_boot_pml4e+0x356>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004204e5a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204e61:	00 
  8004204e62:	eb 67                	jmp    8004204ecb <check_boot_pml4e+0x4bb>
			assert(check_va2pa(pml4e, base + i) == ~0);
  8004204e64:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004204e68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e6c:	48 01 c2             	add    %rax,%rdx
  8004204e6f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204e76:	48 89 d6             	mov    %rdx,%rsi
  8004204e79:	48 89 c7             	mov    %rax,%rdi
  8004204e7c:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004204e83:	00 00 00 
  8004204e86:	ff d0                	callq  *%rax
  8004204e88:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004204e8c:	74 35                	je     8004204ec3 <check_boot_pml4e+0x4b3>
  8004204e8e:	48 b9 28 6c 21 04 80 	movabs $0x8004216c28,%rcx
  8004204e95:	00 00 00 
  8004204e98:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004204e9f:	00 00 00 
  8004204ea2:	be ab 04 00 00       	mov    $0x4ab,%esi
  8004204ea7:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204eae:	00 00 00 
  8004204eb1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204eb6:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204ebd:	00 00 00 
  8004204ec0:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004204ec3:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204eca:	00 
  8004204ecb:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  8004204ed2:	00 
  8004204ed3:	76 8f                	jbe    8004204e64 <check_boot_pml4e+0x454>
		//	cprintf("va: %p i: %d\n", check_va2pa(pml4e, KERNBASE + i), i);
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004204ed5:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004204eda:	48 83 7d f0 07       	cmpq   $0x7,-0x10(%rbp)
  8004204edf:	0f 86 4b fe ff ff    	jbe    8004204d30 <check_boot_pml4e+0x320>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  8004204ee5:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004204eec:	00 00 00 
  8004204eef:	48 8b 00             	mov    (%rax),%rax
  8004204ef2:	48 83 c0 08          	add    $0x8,%rax
  8004204ef6:	48 8b 00             	mov    (%rax),%rax
  8004204ef9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204eff:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004204f03:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204f07:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204f0b:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004204f0e:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004204f11:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004204f18:	00 00 00 
  8004204f1b:	48 8b 00             	mov    (%rax),%rax
  8004204f1e:	48 39 c2             	cmp    %rax,%rdx
  8004204f21:	72 32                	jb     8004204f55 <check_boot_pml4e+0x545>
  8004204f23:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204f27:	48 89 c1             	mov    %rax,%rcx
  8004204f2a:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004204f31:	00 00 00 
  8004204f34:	be ae 04 00 00       	mov    $0x4ae,%esi
  8004204f39:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204f40:	00 00 00 
  8004204f43:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f48:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204f4f:	00 00 00 
  8004204f52:	41 ff d0             	callq  *%r8
  8004204f55:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204f5c:	00 00 00 
  8004204f5f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204f63:	48 01 d0             	add    %rdx,%rax
  8004204f66:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004204f6a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004204f6e:	48 8b 00             	mov    (%rax),%rax
  8004204f71:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204f77:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004204f7b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004204f7f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204f83:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004204f86:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004204f89:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004204f90:	00 00 00 
  8004204f93:	48 8b 00             	mov    (%rax),%rax
  8004204f96:	48 39 c2             	cmp    %rax,%rdx
  8004204f99:	72 32                	jb     8004204fcd <check_boot_pml4e+0x5bd>
  8004204f9b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004204f9f:	48 89 c1             	mov    %rax,%rcx
  8004204fa2:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004204fa9:	00 00 00 
  8004204fac:	be af 04 00 00       	mov    $0x4af,%esi
  8004204fb1:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004204fb8:	00 00 00 
  8004204fbb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fc0:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004204fc7:	00 00 00 
  8004204fca:	41 ff d0             	callq  *%r8
  8004204fcd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204fd4:	00 00 00 
  8004204fd7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004204fdb:	48 01 d0             	add    %rdx,%rax
  8004204fde:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004204fe2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204fe9:	00 
  8004204fea:	e9 46 01 00 00       	jmpq   8004205135 <check_boot_pml4e+0x725>
		switch (i) {
  8004204fef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ff3:	48 83 f8 04          	cmp    $0x4,%rax
  8004204ff7:	72 63                	jb     800420505c <check_boot_pml4e+0x64c>
  8004204ff9:	48 83 f8 05          	cmp    $0x5,%rax
  8004204ffd:	76 06                	jbe    8004205005 <check_boot_pml4e+0x5f5>
  8004204fff:	48 83 f8 1f          	cmp    $0x1f,%rax
  8004205003:	75 57                	jne    800420505c <check_boot_pml4e+0x64c>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  8004205005:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205009:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205010:	00 
  8004205011:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205015:	48 01 d0             	add    %rdx,%rax
  8004205018:	48 8b 00             	mov    (%rax),%rax
  800420501b:	83 e0 01             	and    $0x1,%eax
  800420501e:	48 85 c0             	test   %rax,%rax
  8004205021:	0f 85 05 01 00 00    	jne    800420512c <check_boot_pml4e+0x71c>
  8004205027:	48 b9 4b 6c 21 04 80 	movabs $0x8004216c4b,%rcx
  800420502e:	00 00 00 
  8004205031:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205038:	00 00 00 
  800420503b:	be b7 04 00 00       	mov    $0x4b7,%esi
  8004205040:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205047:	00 00 00 
  800420504a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420504f:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205056:	00 00 00 
  8004205059:	41 ff d0             	callq  *%r8
			break;
		default:
			if (i >= PDX(KERNBASE)) {
  800420505c:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004205061:	0f 86 c8 00 00 00    	jbe    800420512f <check_boot_pml4e+0x71f>
				if (pgdir[i] & PTE_P)
  8004205067:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420506b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205072:	00 
  8004205073:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205077:	48 01 d0             	add    %rdx,%rax
  800420507a:	48 8b 00             	mov    (%rax),%rax
  800420507d:	83 e0 01             	and    $0x1,%eax
  8004205080:	48 85 c0             	test   %rax,%rax
  8004205083:	74 57                	je     80042050dc <check_boot_pml4e+0x6cc>
					assert(pgdir[i] & PTE_W);
  8004205085:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205089:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205090:	00 
  8004205091:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205095:	48 01 d0             	add    %rdx,%rax
  8004205098:	48 8b 00             	mov    (%rax),%rax
  800420509b:	83 e0 02             	and    $0x2,%eax
  800420509e:	48 85 c0             	test   %rax,%rax
  80042050a1:	0f 85 88 00 00 00    	jne    800420512f <check_boot_pml4e+0x71f>
  80042050a7:	48 b9 5c 6c 21 04 80 	movabs $0x8004216c5c,%rcx
  80042050ae:	00 00 00 
  80042050b1:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042050b8:	00 00 00 
  80042050bb:	be bc 04 00 00       	mov    $0x4bc,%esi
  80042050c0:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042050c7:	00 00 00 
  80042050ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050cf:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042050d6:	00 00 00 
  80042050d9:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  80042050dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042050e0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042050e7:	00 
  80042050e8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042050ec:	48 01 d0             	add    %rdx,%rax
  80042050ef:	48 8b 00             	mov    (%rax),%rax
  80042050f2:	48 85 c0             	test   %rax,%rax
  80042050f5:	74 38                	je     800420512f <check_boot_pml4e+0x71f>
  80042050f7:	48 b9 6d 6c 21 04 80 	movabs $0x8004216c6d,%rcx
  80042050fe:	00 00 00 
  8004205101:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205108:	00 00 00 
  800420510b:	be be 04 00 00       	mov    $0x4be,%esi
  8004205110:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205117:	00 00 00 
  800420511a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420511f:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205126:	00 00 00 
  8004205129:	41 ff d0             	callq  *%r8
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
			break;
  800420512c:	90                   	nop
  800420512d:	eb 01                	jmp    8004205130 <check_boot_pml4e+0x720>
				if (pgdir[i] & PTE_P)
					assert(pgdir[i] & PTE_W);
				else
					assert(pgdir[i] == 0);
			}
			break;
  800420512f:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004205130:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004205135:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  800420513c:	00 
  800420513d:	0f 86 ac fe ff ff    	jbe    8004204fef <check_boot_pml4e+0x5df>
					assert(pgdir[i] == 0);
			}
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004205143:	48 bf 80 6c 21 04 80 	movabs $0x8004216c80,%rdi
  800420514a:	00 00 00 
  800420514d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205152:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004205159:	00 00 00 
  800420515c:	ff d2                	callq  *%rdx
}
  800420515e:	90                   	nop
  800420515f:	c9                   	leaveq 
  8004205160:	c3                   	retq   

0000008004205161 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004205161:	55                   	push   %rbp
  8004205162:	48 89 e5             	mov    %rsp,%rbp
  8004205165:	48 83 ec 60          	sub    $0x60,%rsp
  8004205169:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420516d:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  8004205171:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205175:	48 c1 e8 27          	shr    $0x27,%rax
  8004205179:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420517e:	48 c1 e0 03          	shl    $0x3,%rax
  8004205182:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  8004205186:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420518a:	48 8b 00             	mov    (%rax),%rax
  800420518d:	83 e0 01             	and    $0x1,%eax
  8004205190:	48 85 c0             	test   %rax,%rax
  8004205193:	75 0c                	jne    80042051a1 <check_va2pa+0x40>
		return ~0;
  8004205195:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420519c:	e9 38 02 00 00       	jmpq   80042053d9 <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  80042051a1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042051a5:	48 8b 00             	mov    (%rax),%rax
  80042051a8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042051ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042051b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042051b6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042051ba:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042051bd:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042051c0:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042051c7:	00 00 00 
  80042051ca:	48 8b 00             	mov    (%rax),%rax
  80042051cd:	48 39 c2             	cmp    %rax,%rdx
  80042051d0:	72 32                	jb     8004205204 <check_va2pa+0xa3>
  80042051d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042051d6:	48 89 c1             	mov    %rax,%rcx
  80042051d9:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  80042051e0:	00 00 00 
  80042051e3:	be d6 04 00 00       	mov    $0x4d6,%esi
  80042051e8:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042051ef:	00 00 00 
  80042051f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051f7:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042051fe:	00 00 00 
  8004205201:	41 ff d0             	callq  *%r8
  8004205204:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420520b:	00 00 00 
  800420520e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205212:	48 01 d0             	add    %rdx,%rax
  8004205215:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  8004205219:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420521d:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205221:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205226:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420522d:	00 
  800420522e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205232:	48 01 d0             	add    %rdx,%rax
  8004205235:	48 8b 00             	mov    (%rax),%rax
  8004205238:	83 e0 01             	and    $0x1,%eax
  800420523b:	48 85 c0             	test   %rax,%rax
  800420523e:	75 0c                	jne    800420524c <check_va2pa+0xeb>
		return ~0;
  8004205240:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205247:	e9 8d 01 00 00       	jmpq   80042053d9 <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  800420524c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205250:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205254:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205259:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205260:	00 
  8004205261:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205265:	48 01 d0             	add    %rdx,%rax
  8004205268:	48 8b 00             	mov    (%rax),%rax
  800420526b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205271:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205275:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205279:	48 c1 e8 0c          	shr    $0xc,%rax
  800420527d:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004205280:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004205283:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  800420528a:	00 00 00 
  800420528d:	48 8b 00             	mov    (%rax),%rax
  8004205290:	48 39 c2             	cmp    %rax,%rdx
  8004205293:	72 32                	jb     80042052c7 <check_va2pa+0x166>
  8004205295:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205299:	48 89 c1             	mov    %rax,%rcx
  800420529c:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  80042052a3:	00 00 00 
  80042052a6:	be da 04 00 00       	mov    $0x4da,%esi
  80042052ab:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042052b2:	00 00 00 
  80042052b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042052ba:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042052c1:	00 00 00 
  80042052c4:	41 ff d0             	callq  *%r8
  80042052c7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042052ce:	00 00 00 
  80042052d1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042052d5:	48 01 d0             	add    %rdx,%rax
  80042052d8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  80042052dc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042052e0:	48 c1 e8 15          	shr    $0x15,%rax
  80042052e4:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042052e9:	48 c1 e0 03          	shl    $0x3,%rax
  80042052ed:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  80042052f1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042052f5:	48 8b 00             	mov    (%rax),%rax
  80042052f8:	83 e0 01             	and    $0x1,%eax
  80042052fb:	48 85 c0             	test   %rax,%rax
  80042052fe:	75 0c                	jne    800420530c <check_va2pa+0x1ab>
		return ~0;
  8004205300:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205307:	e9 cd 00 00 00       	jmpq   80042053d9 <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  800420530c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205310:	48 8b 00             	mov    (%rax),%rax
  8004205313:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205319:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420531d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205321:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205325:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004205328:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420532b:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004205332:	00 00 00 
  8004205335:	48 8b 00             	mov    (%rax),%rax
  8004205338:	48 39 c2             	cmp    %rax,%rdx
  800420533b:	72 32                	jb     800420536f <check_va2pa+0x20e>
  800420533d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205341:	48 89 c1             	mov    %rax,%rcx
  8004205344:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  800420534b:	00 00 00 
  800420534e:	be df 04 00 00       	mov    $0x4df,%esi
  8004205353:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420535a:	00 00 00 
  800420535d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205362:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205369:	00 00 00 
  800420536c:	41 ff d0             	callq  *%r8
  800420536f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205376:	00 00 00 
  8004205379:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420537d:	48 01 d0             	add    %rdx,%rax
  8004205380:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	//cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  8004205384:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205388:	48 c1 e8 0c          	shr    $0xc,%rax
  800420538c:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205391:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205398:	00 
  8004205399:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420539d:	48 01 d0             	add    %rdx,%rax
  80042053a0:	48 8b 00             	mov    (%rax),%rax
  80042053a3:	83 e0 01             	and    $0x1,%eax
  80042053a6:	48 85 c0             	test   %rax,%rax
  80042053a9:	75 09                	jne    80042053b4 <check_va2pa+0x253>
		return ~0;
  80042053ab:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042053b2:	eb 25                	jmp    80042053d9 <check_va2pa+0x278>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  80042053b4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042053b8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042053bc:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042053c1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042053c8:	00 
  80042053c9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042053cd:	48 01 d0             	add    %rdx,%rax
  80042053d0:	48 8b 00             	mov    (%rax),%rax
  80042053d3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  80042053d9:	c9                   	leaveq 
  80042053da:	c3                   	retq   

00000080042053db <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  80042053db:	55                   	push   %rbp
  80042053dc:	48 89 e5             	mov    %rsp,%rbp
  80042053df:	53                   	push   %rbx
  80042053e0:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  80042053e7:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042053ee:	00 
  80042053ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042053f3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042053f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042053fb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042053ff:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205403:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205407:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420540b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420540f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205413:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004205417:	bf 00 00 00 00       	mov    $0x0,%edi
  800420541c:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004205423:	00 00 00 
  8004205426:	ff d0                	callq  *%rax
  8004205428:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  800420542c:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205431:	75 35                	jne    8004205468 <page_check+0x8d>
  8004205433:	48 b9 9f 6c 21 04 80 	movabs $0x8004216c9f,%rcx
  800420543a:	00 00 00 
  800420543d:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205444:	00 00 00 
  8004205447:	be f6 04 00 00       	mov    $0x4f6,%esi
  800420544c:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205453:	00 00 00 
  8004205456:	b8 00 00 00 00       	mov    $0x0,%eax
  800420545b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205462:	00 00 00 
  8004205465:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  8004205468:	bf 00 00 00 00       	mov    $0x0,%edi
  800420546d:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004205474:	00 00 00 
  8004205477:	ff d0                	callq  *%rax
  8004205479:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420547d:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205482:	75 35                	jne    80042054b9 <page_check+0xde>
  8004205484:	48 b9 b3 6c 21 04 80 	movabs $0x8004216cb3,%rcx
  800420548b:	00 00 00 
  800420548e:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205495:	00 00 00 
  8004205498:	be f7 04 00 00       	mov    $0x4f7,%esi
  800420549d:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042054a4:	00 00 00 
  80042054a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054ac:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042054b3:	00 00 00 
  80042054b6:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  80042054b9:	bf 00 00 00 00       	mov    $0x0,%edi
  80042054be:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  80042054c5:	00 00 00 
  80042054c8:	ff d0                	callq  *%rax
  80042054ca:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042054ce:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042054d3:	75 35                	jne    800420550a <page_check+0x12f>
  80042054d5:	48 b9 c7 6c 21 04 80 	movabs $0x8004216cc7,%rcx
  80042054dc:	00 00 00 
  80042054df:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042054e6:	00 00 00 
  80042054e9:	be f8 04 00 00       	mov    $0x4f8,%esi
  80042054ee:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042054f5:	00 00 00 
  80042054f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054fd:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205504:	00 00 00 
  8004205507:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  800420550a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420550f:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004205516:	00 00 00 
  8004205519:	ff d0                	callq  *%rax
  800420551b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420551f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205524:	75 35                	jne    800420555b <page_check+0x180>
  8004205526:	48 b9 db 6c 21 04 80 	movabs $0x8004216cdb,%rcx
  800420552d:	00 00 00 
  8004205530:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205537:	00 00 00 
  800420553a:	be f9 04 00 00       	mov    $0x4f9,%esi
  800420553f:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205546:	00 00 00 
  8004205549:	b8 00 00 00 00       	mov    $0x0,%eax
  800420554e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205555:	00 00 00 
  8004205558:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  800420555b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205560:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004205567:	00 00 00 
  800420556a:	ff d0                	callq  *%rax
  800420556c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205570:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205575:	75 35                	jne    80042055ac <page_check+0x1d1>
  8004205577:	48 b9 ef 6c 21 04 80 	movabs $0x8004216cef,%rcx
  800420557e:	00 00 00 
  8004205581:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205588:	00 00 00 
  800420558b:	be fa 04 00 00       	mov    $0x4fa,%esi
  8004205590:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205597:	00 00 00 
  800420559a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420559f:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042055a6:	00 00 00 
  80042055a9:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  80042055ac:	bf 00 00 00 00       	mov    $0x0,%edi
  80042055b1:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  80042055b8:	00 00 00 
  80042055bb:	ff d0                	callq  *%rax
  80042055bd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042055c1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042055c6:	75 35                	jne    80042055fd <page_check+0x222>
  80042055c8:	48 b9 03 6d 21 04 80 	movabs $0x8004216d03,%rcx
  80042055cf:	00 00 00 
  80042055d2:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042055d9:	00 00 00 
  80042055dc:	be fb 04 00 00       	mov    $0x4fb,%esi
  80042055e1:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042055e8:	00 00 00 
  80042055eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055f0:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042055f7:	00 00 00 
  80042055fa:	41 ff d0             	callq  *%r8

	assert(pp0);
  80042055fd:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205602:	75 35                	jne    8004205639 <page_check+0x25e>
  8004205604:	48 b9 51 6a 21 04 80 	movabs $0x8004216a51,%rcx
  800420560b:	00 00 00 
  800420560e:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205615:	00 00 00 
  8004205618:	be fd 04 00 00       	mov    $0x4fd,%esi
  800420561d:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205624:	00 00 00 
  8004205627:	b8 00 00 00 00       	mov    $0x0,%eax
  800420562c:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205633:	00 00 00 
  8004205636:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205639:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800420563e:	74 0a                	je     800420564a <page_check+0x26f>
  8004205640:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205644:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205648:	75 35                	jne    800420567f <page_check+0x2a4>
  800420564a:	48 b9 55 6a 21 04 80 	movabs $0x8004216a55,%rcx
  8004205651:	00 00 00 
  8004205654:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420565b:	00 00 00 
  800420565e:	be fe 04 00 00       	mov    $0x4fe,%esi
  8004205663:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420566a:	00 00 00 
  800420566d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205672:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205679:	00 00 00 
  800420567c:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  800420567f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205684:	74 14                	je     800420569a <page_check+0x2bf>
  8004205686:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420568a:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420568e:	74 0a                	je     800420569a <page_check+0x2bf>
  8004205690:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205694:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205698:	75 35                	jne    80042056cf <page_check+0x2f4>
  800420569a:	48 b9 68 6a 21 04 80 	movabs $0x8004216a68,%rcx
  80042056a1:	00 00 00 
  80042056a4:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042056ab:	00 00 00 
  80042056ae:	be ff 04 00 00       	mov    $0x4ff,%esi
  80042056b3:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042056ba:	00 00 00 
  80042056bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056c2:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042056c9:	00 00 00 
  80042056cc:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  80042056cf:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042056d4:	74 1e                	je     80042056f4 <page_check+0x319>
  80042056d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042056da:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042056de:	74 14                	je     80042056f4 <page_check+0x319>
  80042056e0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042056e4:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042056e8:	74 0a                	je     80042056f4 <page_check+0x319>
  80042056ea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042056ee:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042056f2:	75 35                	jne    8004205729 <page_check+0x34e>
  80042056f4:	48 b9 18 6d 21 04 80 	movabs $0x8004216d18,%rcx
  80042056fb:	00 00 00 
  80042056fe:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205705:	00 00 00 
  8004205708:	be 00 05 00 00       	mov    $0x500,%esi
  800420570d:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205714:	00 00 00 
  8004205717:	b8 00 00 00 00       	mov    $0x0,%eax
  800420571c:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205723:	00 00 00 
  8004205726:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205729:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420572e:	74 28                	je     8004205758 <page_check+0x37d>
  8004205730:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205734:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205738:	74 1e                	je     8004205758 <page_check+0x37d>
  800420573a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420573e:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205742:	74 14                	je     8004205758 <page_check+0x37d>
  8004205744:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205748:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  800420574c:	74 0a                	je     8004205758 <page_check+0x37d>
  800420574e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205752:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205756:	75 35                	jne    800420578d <page_check+0x3b2>
  8004205758:	48 b9 48 6d 21 04 80 	movabs $0x8004216d48,%rcx
  800420575f:	00 00 00 
  8004205762:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205769:	00 00 00 
  800420576c:	be 01 05 00 00       	mov    $0x501,%esi
  8004205771:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205778:	00 00 00 
  800420577b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205780:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205787:	00 00 00 
  800420578a:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  800420578d:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205792:	74 32                	je     80042057c6 <page_check+0x3eb>
  8004205794:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205798:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420579c:	74 28                	je     80042057c6 <page_check+0x3eb>
  800420579e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042057a2:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042057a6:	74 1e                	je     80042057c6 <page_check+0x3eb>
  80042057a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042057ac:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042057b0:	74 14                	je     80042057c6 <page_check+0x3eb>
  80042057b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042057b6:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042057ba:	74 0a                	je     80042057c6 <page_check+0x3eb>
  80042057bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042057c0:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042057c4:	75 35                	jne    80042057fb <page_check+0x420>
  80042057c6:	48 b9 88 6d 21 04 80 	movabs $0x8004216d88,%rcx
  80042057cd:	00 00 00 
  80042057d0:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042057d7:	00 00 00 
  80042057da:	be 02 05 00 00       	mov    $0x502,%esi
  80042057df:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042057e6:	00 00 00 
  80042057e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057ee:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042057f5:	00 00 00 
  80042057f8:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  80042057fb:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004205802:	00 00 00 
  8004205805:	48 8b 00             	mov    (%rax),%rax
  8004205808:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  800420580c:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004205813:	00 00 00 
  8004205816:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  800420581d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205822:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004205829:	00 00 00 
  800420582c:	ff d0                	callq  *%rax
  800420582e:	48 85 c0             	test   %rax,%rax
  8004205831:	74 35                	je     8004205868 <page_check+0x48d>
  8004205833:	48 b9 df 6a 21 04 80 	movabs $0x8004216adf,%rcx
  800420583a:	00 00 00 
  800420583d:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205844:	00 00 00 
  8004205847:	be 09 05 00 00       	mov    $0x509,%esi
  800420584c:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205853:	00 00 00 
  8004205856:	b8 00 00 00 00       	mov    $0x0,%eax
  800420585b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205862:	00 00 00 
  8004205865:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	//cprintf("WOW\n");
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205868:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  800420586f:	00 00 00 
  8004205872:	48 8b 00             	mov    (%rax),%rax
  8004205875:	48 8d 95 e0 fe ff ff 	lea    -0x120(%rbp),%rdx
  800420587c:	be 00 00 00 00       	mov    $0x0,%esi
  8004205881:	48 89 c7             	mov    %rax,%rdi
  8004205884:	48 b8 c5 35 20 04 80 	movabs $0x80042035c5,%rax
  800420588b:	00 00 00 
  800420588e:	ff d0                	callq  *%rax
  8004205890:	48 85 c0             	test   %rax,%rax
  8004205893:	74 35                	je     80042058ca <page_check+0x4ef>
  8004205895:	48 b9 d8 6d 21 04 80 	movabs $0x8004216dd8,%rcx
  800420589c:	00 00 00 
  800420589f:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042058a6:	00 00 00 
  80042058a9:	be 0d 05 00 00       	mov    $0x50d,%esi
  80042058ae:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042058b5:	00 00 00 
  80042058b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058bd:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042058c4:	00 00 00 
  80042058c7:	41 ff d0             	callq  *%r8
	//cprintf("WOWZA\n");
	// there is no free memory, so we can't allocate a page table
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  80042058ca:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042058d1:	00 00 00 
  80042058d4:	48 8b 00             	mov    (%rax),%rax
  80042058d7:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042058db:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042058e0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042058e5:	48 89 c7             	mov    %rax,%rdi
  80042058e8:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  80042058ef:	00 00 00 
  80042058f2:	ff d0                	callq  *%rax
  80042058f4:	85 c0                	test   %eax,%eax
  80042058f6:	78 35                	js     800420592d <page_check+0x552>
  80042058f8:	48 b9 10 6e 21 04 80 	movabs $0x8004216e10,%rcx
  80042058ff:	00 00 00 
  8004205902:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205909:	00 00 00 
  800420590c:	be 10 05 00 00       	mov    $0x510,%esi
  8004205911:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205918:	00 00 00 
  800420591b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205920:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205927:	00 00 00 
  800420592a:	41 ff d0             	callq  *%r8
	//cprintf("HERE\n");

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  800420592d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205931:	48 89 c7             	mov    %rax,%rdi
  8004205934:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  800420593b:	00 00 00 
  800420593e:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205940:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004205947:	00 00 00 
  800420594a:	48 8b 00             	mov    (%rax),%rax
  800420594d:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205951:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205956:	ba 00 00 00 00       	mov    $0x0,%edx
  800420595b:	48 89 c7             	mov    %rax,%rdi
  800420595e:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  8004205965:	00 00 00 
  8004205968:	ff d0                	callq  *%rax
  800420596a:	85 c0                	test   %eax,%eax
  800420596c:	78 35                	js     80042059a3 <page_check+0x5c8>
  800420596e:	48 b9 10 6e 21 04 80 	movabs $0x8004216e10,%rcx
  8004205975:	00 00 00 
  8004205978:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420597f:	00 00 00 
  8004205982:	be 15 05 00 00       	mov    $0x515,%esi
  8004205987:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420598e:	00 00 00 
  8004205991:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205996:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420599d:	00 00 00 
  80042059a0:	41 ff d0             	callq  *%r8
	page_free(pp2);
  80042059a3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042059a7:	48 89 c7             	mov    %rax,%rdi
  80042059aa:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  80042059b1:	00 00 00 
  80042059b4:	ff d0                	callq  *%rax
	page_free(pp3);
  80042059b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059ba:	48 89 c7             	mov    %rax,%rdi
  80042059bd:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  80042059c4:	00 00 00 
  80042059c7:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  80042059c9:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042059d0:	00 00 00 
  80042059d3:	48 8b 00             	mov    (%rax),%rax
  80042059d6:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042059da:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042059df:	ba 00 00 00 00       	mov    $0x0,%edx
  80042059e4:	48 89 c7             	mov    %rax,%rdi
  80042059e7:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  80042059ee:	00 00 00 
  80042059f1:	ff d0                	callq  *%rax
  80042059f3:	85 c0                	test   %eax,%eax
  80042059f5:	74 35                	je     8004205a2c <page_check+0x651>
  80042059f7:	48 b9 40 6e 21 04 80 	movabs $0x8004216e40,%rcx
  80042059fe:	00 00 00 
  8004205a01:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205a08:	00 00 00 
  8004205a0b:	be 1b 05 00 00       	mov    $0x51b,%esi
  8004205a10:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205a17:	00 00 00 
  8004205a1a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a1f:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205a26:	00 00 00 
  8004205a29:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004205a2c:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004205a33:	00 00 00 
  8004205a36:	48 8b 00             	mov    (%rax),%rax
  8004205a39:	48 8b 00             	mov    (%rax),%rax
  8004205a3c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205a42:	48 89 c3             	mov    %rax,%rbx
  8004205a45:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205a49:	48 89 c7             	mov    %rax,%rdi
  8004205a4c:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004205a53:	00 00 00 
  8004205a56:	ff d0                	callq  *%rax
  8004205a58:	48 39 c3             	cmp    %rax,%rbx
  8004205a5b:	0f 84 97 00 00 00    	je     8004205af8 <page_check+0x71d>
  8004205a61:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004205a68:	00 00 00 
  8004205a6b:	48 8b 00             	mov    (%rax),%rax
  8004205a6e:	48 8b 00             	mov    (%rax),%rax
  8004205a71:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205a77:	48 89 c3             	mov    %rax,%rbx
  8004205a7a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205a7e:	48 89 c7             	mov    %rax,%rdi
  8004205a81:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004205a88:	00 00 00 
  8004205a8b:	ff d0                	callq  *%rax
  8004205a8d:	48 39 c3             	cmp    %rax,%rbx
  8004205a90:	74 66                	je     8004205af8 <page_check+0x71d>
  8004205a92:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004205a99:	00 00 00 
  8004205a9c:	48 8b 00             	mov    (%rax),%rax
  8004205a9f:	48 8b 00             	mov    (%rax),%rax
  8004205aa2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205aa8:	48 89 c3             	mov    %rax,%rbx
  8004205aab:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205aaf:	48 89 c7             	mov    %rax,%rdi
  8004205ab2:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004205ab9:	00 00 00 
  8004205abc:	ff d0                	callq  *%rax
  8004205abe:	48 39 c3             	cmp    %rax,%rbx
  8004205ac1:	74 35                	je     8004205af8 <page_check+0x71d>
  8004205ac3:	48 b9 70 6e 21 04 80 	movabs $0x8004216e70,%rcx
  8004205aca:	00 00 00 
  8004205acd:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205ad4:	00 00 00 
  8004205ad7:	be 1c 05 00 00       	mov    $0x51c,%esi
  8004205adc:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205ae3:	00 00 00 
  8004205ae6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205aeb:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205af2:	00 00 00 
  8004205af5:	41 ff d0             	callq  *%r8

	//cprintf("\n%x \t %x\n", check_va2pa(boot_pml4e, 0x0), page2pa(pp1));

	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004205af8:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004205aff:	00 00 00 
  8004205b02:	48 8b 00             	mov    (%rax),%rax
  8004205b05:	be 00 00 00 00       	mov    $0x0,%esi
  8004205b0a:	48 89 c7             	mov    %rax,%rdi
  8004205b0d:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004205b14:	00 00 00 
  8004205b17:	ff d0                	callq  *%rax
  8004205b19:	48 89 c3             	mov    %rax,%rbx
  8004205b1c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205b20:	48 89 c7             	mov    %rax,%rdi
  8004205b23:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004205b2a:	00 00 00 
  8004205b2d:	ff d0                	callq  *%rax
  8004205b2f:	48 39 c3             	cmp    %rax,%rbx
  8004205b32:	74 35                	je     8004205b69 <page_check+0x78e>
  8004205b34:	48 b9 f8 6e 21 04 80 	movabs $0x8004216ef8,%rcx
  8004205b3b:	00 00 00 
  8004205b3e:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205b45:	00 00 00 
  8004205b48:	be 20 05 00 00       	mov    $0x520,%esi
  8004205b4d:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205b54:	00 00 00 
  8004205b57:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b5c:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205b63:	00 00 00 
  8004205b66:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205b69:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205b6d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205b71:	66 83 f8 01          	cmp    $0x1,%ax
  8004205b75:	74 35                	je     8004205bac <page_check+0x7d1>
  8004205b77:	48 b9 25 6f 21 04 80 	movabs $0x8004216f25,%rcx
  8004205b7e:	00 00 00 
  8004205b81:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205b88:	00 00 00 
  8004205b8b:	be 21 05 00 00       	mov    $0x521,%esi
  8004205b90:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205b97:	00 00 00 
  8004205b9a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b9f:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205ba6:	00 00 00 
  8004205ba9:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004205bac:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205bb0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205bb4:	66 83 f8 01          	cmp    $0x1,%ax
  8004205bb8:	74 35                	je     8004205bef <page_check+0x814>
  8004205bba:	48 b9 36 6f 21 04 80 	movabs $0x8004216f36,%rcx
  8004205bc1:	00 00 00 
  8004205bc4:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205bcb:	00 00 00 
  8004205bce:	be 22 05 00 00       	mov    $0x522,%esi
  8004205bd3:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205bda:	00 00 00 
  8004205bdd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205be2:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205be9:	00 00 00 
  8004205bec:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004205bef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205bf3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205bf7:	66 83 f8 01          	cmp    $0x1,%ax
  8004205bfb:	74 35                	je     8004205c32 <page_check+0x857>
  8004205bfd:	48 b9 47 6f 21 04 80 	movabs $0x8004216f47,%rcx
  8004205c04:	00 00 00 
  8004205c07:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205c0e:	00 00 00 
  8004205c11:	be 23 05 00 00       	mov    $0x523,%esi
  8004205c16:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205c1d:	00 00 00 
  8004205c20:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c25:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205c2c:	00 00 00 
  8004205c2f:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	//cprintf("%p \n", page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0));
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205c32:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004205c39:	00 00 00 
  8004205c3c:	48 8b 00             	mov    (%rax),%rax
  8004205c3f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205c43:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205c48:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205c4d:	48 89 c7             	mov    %rax,%rdi
  8004205c50:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  8004205c57:	00 00 00 
  8004205c5a:	ff d0                	callq  *%rax
  8004205c5c:	85 c0                	test   %eax,%eax
  8004205c5e:	74 35                	je     8004205c95 <page_check+0x8ba>
  8004205c60:	48 b9 58 6f 21 04 80 	movabs $0x8004216f58,%rcx
  8004205c67:	00 00 00 
  8004205c6a:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205c71:	00 00 00 
  8004205c74:	be 26 05 00 00       	mov    $0x526,%esi
  8004205c79:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205c80:	00 00 00 
  8004205c83:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c88:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205c8f:	00 00 00 
  8004205c92:	41 ff d0             	callq  *%r8
	//cprintf("\n%p\t%p\n",check_va2pa(boot_pml4e, PGSIZE), page2pa(pp3));
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205c95:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004205c9c:	00 00 00 
  8004205c9f:	48 8b 00             	mov    (%rax),%rax
  8004205ca2:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205ca7:	48 89 c7             	mov    %rax,%rdi
  8004205caa:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004205cb1:	00 00 00 
  8004205cb4:	ff d0                	callq  *%rax
  8004205cb6:	48 89 c3             	mov    %rax,%rbx
  8004205cb9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205cbd:	48 89 c7             	mov    %rax,%rdi
  8004205cc0:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004205cc7:	00 00 00 
  8004205cca:	ff d0                	callq  *%rax
  8004205ccc:	48 39 c3             	cmp    %rax,%rbx
  8004205ccf:	74 35                	je     8004205d06 <page_check+0x92b>
  8004205cd1:	48 b9 90 6f 21 04 80 	movabs $0x8004216f90,%rcx
  8004205cd8:	00 00 00 
  8004205cdb:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205ce2:	00 00 00 
  8004205ce5:	be 28 05 00 00       	mov    $0x528,%esi
  8004205cea:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205cf1:	00 00 00 
  8004205cf4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cf9:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205d00:	00 00 00 
  8004205d03:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205d06:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d0a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205d0e:	66 83 f8 02          	cmp    $0x2,%ax
  8004205d12:	74 35                	je     8004205d49 <page_check+0x96e>
  8004205d14:	48 b9 c0 6f 21 04 80 	movabs $0x8004216fc0,%rcx
  8004205d1b:	00 00 00 
  8004205d1e:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205d25:	00 00 00 
  8004205d28:	be 29 05 00 00       	mov    $0x529,%esi
  8004205d2d:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205d34:	00 00 00 
  8004205d37:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d3c:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205d43:	00 00 00 
  8004205d46:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  8004205d49:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205d4e:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004205d55:	00 00 00 
  8004205d58:	ff d0                	callq  *%rax
  8004205d5a:	48 85 c0             	test   %rax,%rax
  8004205d5d:	74 35                	je     8004205d94 <page_check+0x9b9>
  8004205d5f:	48 b9 df 6a 21 04 80 	movabs $0x8004216adf,%rcx
  8004205d66:	00 00 00 
  8004205d69:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205d70:	00 00 00 
  8004205d73:	be 2c 05 00 00       	mov    $0x52c,%esi
  8004205d78:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205d7f:	00 00 00 
  8004205d82:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d87:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205d8e:	00 00 00 
  8004205d91:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205d94:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004205d9b:	00 00 00 
  8004205d9e:	48 8b 00             	mov    (%rax),%rax
  8004205da1:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205da5:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205daa:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205daf:	48 89 c7             	mov    %rax,%rdi
  8004205db2:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  8004205db9:	00 00 00 
  8004205dbc:	ff d0                	callq  *%rax
  8004205dbe:	85 c0                	test   %eax,%eax
  8004205dc0:	74 35                	je     8004205df7 <page_check+0xa1c>
  8004205dc2:	48 b9 58 6f 21 04 80 	movabs $0x8004216f58,%rcx
  8004205dc9:	00 00 00 
  8004205dcc:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205dd3:	00 00 00 
  8004205dd6:	be 2f 05 00 00       	mov    $0x52f,%esi
  8004205ddb:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205de2:	00 00 00 
  8004205de5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205dea:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205df1:	00 00 00 
  8004205df4:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205df7:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004205dfe:	00 00 00 
  8004205e01:	48 8b 00             	mov    (%rax),%rax
  8004205e04:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205e09:	48 89 c7             	mov    %rax,%rdi
  8004205e0c:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004205e13:	00 00 00 
  8004205e16:	ff d0                	callq  *%rax
  8004205e18:	48 89 c3             	mov    %rax,%rbx
  8004205e1b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205e1f:	48 89 c7             	mov    %rax,%rdi
  8004205e22:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004205e29:	00 00 00 
  8004205e2c:	ff d0                	callq  *%rax
  8004205e2e:	48 39 c3             	cmp    %rax,%rbx
  8004205e31:	74 35                	je     8004205e68 <page_check+0xa8d>
  8004205e33:	48 b9 90 6f 21 04 80 	movabs $0x8004216f90,%rcx
  8004205e3a:	00 00 00 
  8004205e3d:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205e44:	00 00 00 
  8004205e47:	be 30 05 00 00       	mov    $0x530,%esi
  8004205e4c:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205e53:	00 00 00 
  8004205e56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e5b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205e62:	00 00 00 
  8004205e65:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205e68:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205e6c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205e70:	66 83 f8 02          	cmp    $0x2,%ax
  8004205e74:	74 35                	je     8004205eab <page_check+0xad0>
  8004205e76:	48 b9 c0 6f 21 04 80 	movabs $0x8004216fc0,%rcx
  8004205e7d:	00 00 00 
  8004205e80:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205e87:	00 00 00 
  8004205e8a:	be 31 05 00 00       	mov    $0x531,%esi
  8004205e8f:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205e96:	00 00 00 
  8004205e99:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e9e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205ea5:	00 00 00 
  8004205ea8:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  8004205eab:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205eb0:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004205eb7:	00 00 00 
  8004205eba:	ff d0                	callq  *%rax
  8004205ebc:	48 85 c0             	test   %rax,%rax
  8004205ebf:	74 35                	je     8004205ef6 <page_check+0xb1b>
  8004205ec1:	48 b9 df 6a 21 04 80 	movabs $0x8004216adf,%rcx
  8004205ec8:	00 00 00 
  8004205ecb:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004205ed2:	00 00 00 
  8004205ed5:	be 35 05 00 00       	mov    $0x535,%esi
  8004205eda:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205ee1:	00 00 00 
  8004205ee4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ee9:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205ef0:	00 00 00 
  8004205ef3:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  8004205ef6:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004205efd:	00 00 00 
  8004205f00:	48 8b 00             	mov    (%rax),%rax
  8004205f03:	48 8b 00             	mov    (%rax),%rax
  8004205f06:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205f0c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004205f10:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205f14:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205f18:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004205f1b:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004205f1e:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004205f25:	00 00 00 
  8004205f28:	48 8b 00             	mov    (%rax),%rax
  8004205f2b:	48 39 c2             	cmp    %rax,%rdx
  8004205f2e:	72 32                	jb     8004205f62 <page_check+0xb87>
  8004205f30:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205f34:	48 89 c1             	mov    %rax,%rcx
  8004205f37:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004205f3e:	00 00 00 
  8004205f41:	be 37 05 00 00       	mov    $0x537,%esi
  8004205f46:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205f4d:	00 00 00 
  8004205f50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f55:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205f5c:	00 00 00 
  8004205f5f:	41 ff d0             	callq  *%r8
  8004205f62:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205f69:	00 00 00 
  8004205f6c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205f70:	48 01 d0             	add    %rdx,%rax
  8004205f73:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004205f77:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004205f7b:	48 8b 00             	mov    (%rax),%rax
  8004205f7e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205f84:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004205f88:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205f8c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205f90:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004205f93:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004205f96:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004205f9d:	00 00 00 
  8004205fa0:	48 8b 00             	mov    (%rax),%rax
  8004205fa3:	48 39 c2             	cmp    %rax,%rdx
  8004205fa6:	72 32                	jb     8004205fda <page_check+0xbff>
  8004205fa8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205fac:	48 89 c1             	mov    %rax,%rcx
  8004205faf:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004205fb6:	00 00 00 
  8004205fb9:	be 38 05 00 00       	mov    $0x538,%esi
  8004205fbe:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004205fc5:	00 00 00 
  8004205fc8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fcd:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004205fd4:	00 00 00 
  8004205fd7:	41 ff d0             	callq  *%r8
  8004205fda:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205fe1:	00 00 00 
  8004205fe4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205fe8:	48 01 d0             	add    %rdx,%rax
  8004205feb:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004205fef:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004205ff3:	48 8b 00             	mov    (%rax),%rax
  8004205ff6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205ffc:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004206003:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420600a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420600e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004206014:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  800420601a:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004206021:	00 00 00 
  8004206024:	48 8b 00             	mov    (%rax),%rax
  8004206027:	48 39 c2             	cmp    %rax,%rdx
  800420602a:	72 35                	jb     8004206061 <page_check+0xc86>
  800420602c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206033:	48 89 c1             	mov    %rax,%rcx
  8004206036:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  800420603d:	00 00 00 
  8004206040:	be 39 05 00 00       	mov    $0x539,%esi
  8004206045:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420604c:	00 00 00 
  800420604f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206054:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420605b:	00 00 00 
  800420605e:	41 ff d0             	callq  *%r8
  8004206061:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206068:	00 00 00 
  800420606b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206072:	48 01 d0             	add    %rdx,%rax
  8004206075:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  800420607c:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206083:	00 00 00 
  8004206086:	48 8b 00             	mov    (%rax),%rax
  8004206089:	ba 00 00 00 00       	mov    $0x0,%edx
  800420608e:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206093:	48 89 c7             	mov    %rax,%rdi
  8004206096:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  800420609d:	00 00 00 
  80042060a0:	ff d0                	callq  *%rax
  80042060a2:	48 89 c2             	mov    %rax,%rdx
  80042060a5:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  80042060ac:	48 83 c0 08          	add    $0x8,%rax
  80042060b0:	48 39 c2             	cmp    %rax,%rdx
  80042060b3:	74 35                	je     80042060ea <page_check+0xd0f>
  80042060b5:	48 b9 d8 6f 21 04 80 	movabs $0x8004216fd8,%rcx
  80042060bc:	00 00 00 
  80042060bf:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042060c6:	00 00 00 
  80042060c9:	be 3a 05 00 00       	mov    $0x53a,%esi
  80042060ce:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042060d5:	00 00 00 
  80042060d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060dd:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042060e4:	00 00 00 
  80042060e7:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  80042060ea:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042060f1:	00 00 00 
  80042060f4:	48 8b 00             	mov    (%rax),%rax
  80042060f7:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042060fb:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004206100:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206105:	48 89 c7             	mov    %rax,%rdi
  8004206108:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  800420610f:	00 00 00 
  8004206112:	ff d0                	callq  *%rax
  8004206114:	85 c0                	test   %eax,%eax
  8004206116:	74 35                	je     800420614d <page_check+0xd72>
  8004206118:	48 b9 18 70 21 04 80 	movabs $0x8004217018,%rcx
  800420611f:	00 00 00 
  8004206122:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206129:	00 00 00 
  800420612c:	be 3d 05 00 00       	mov    $0x53d,%esi
  8004206131:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206138:	00 00 00 
  800420613b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206140:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206147:	00 00 00 
  800420614a:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420614d:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206154:	00 00 00 
  8004206157:	48 8b 00             	mov    (%rax),%rax
  800420615a:	be 00 10 00 00       	mov    $0x1000,%esi
  800420615f:	48 89 c7             	mov    %rax,%rdi
  8004206162:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004206169:	00 00 00 
  800420616c:	ff d0                	callq  *%rax
  800420616e:	48 89 c3             	mov    %rax,%rbx
  8004206171:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206175:	48 89 c7             	mov    %rax,%rdi
  8004206178:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  800420617f:	00 00 00 
  8004206182:	ff d0                	callq  *%rax
  8004206184:	48 39 c3             	cmp    %rax,%rbx
  8004206187:	74 35                	je     80042061be <page_check+0xde3>
  8004206189:	48 b9 90 6f 21 04 80 	movabs $0x8004216f90,%rcx
  8004206190:	00 00 00 
  8004206193:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420619a:	00 00 00 
  800420619d:	be 3e 05 00 00       	mov    $0x53e,%esi
  80042061a2:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042061a9:	00 00 00 
  80042061ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061b1:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042061b8:	00 00 00 
  80042061bb:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042061be:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042061c2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042061c6:	66 83 f8 02          	cmp    $0x2,%ax
  80042061ca:	74 35                	je     8004206201 <page_check+0xe26>
  80042061cc:	48 b9 c0 6f 21 04 80 	movabs $0x8004216fc0,%rcx
  80042061d3:	00 00 00 
  80042061d6:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042061dd:	00 00 00 
  80042061e0:	be 3f 05 00 00       	mov    $0x53f,%esi
  80042061e5:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042061ec:	00 00 00 
  80042061ef:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061f4:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042061fb:	00 00 00 
  80042061fe:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004206201:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206208:	00 00 00 
  800420620b:	48 8b 00             	mov    (%rax),%rax
  800420620e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206213:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206218:	48 89 c7             	mov    %rax,%rdi
  800420621b:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  8004206222:	00 00 00 
  8004206225:	ff d0                	callq  *%rax
  8004206227:	48 8b 00             	mov    (%rax),%rax
  800420622a:	83 e0 04             	and    $0x4,%eax
  800420622d:	48 85 c0             	test   %rax,%rax
  8004206230:	75 35                	jne    8004206267 <page_check+0xe8c>
  8004206232:	48 b9 58 70 21 04 80 	movabs $0x8004217058,%rcx
  8004206239:	00 00 00 
  800420623c:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206243:	00 00 00 
  8004206246:	be 40 05 00 00       	mov    $0x540,%esi
  800420624b:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206252:	00 00 00 
  8004206255:	b8 00 00 00 00       	mov    $0x0,%eax
  800420625a:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206261:	00 00 00 
  8004206264:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004206267:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  800420626e:	00 00 00 
  8004206271:	48 8b 00             	mov    (%rax),%rax
  8004206274:	48 8b 00             	mov    (%rax),%rax
  8004206277:	83 e0 04             	and    $0x4,%eax
  800420627a:	48 85 c0             	test   %rax,%rax
  800420627d:	75 35                	jne    80042062b4 <page_check+0xed9>
  800420627f:	48 b9 8b 70 21 04 80 	movabs $0x800421708b,%rcx
  8004206286:	00 00 00 
  8004206289:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206290:	00 00 00 
  8004206293:	be 41 05 00 00       	mov    $0x541,%esi
  8004206298:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420629f:	00 00 00 
  80042062a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062a7:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042062ae:	00 00 00 
  80042062b1:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  80042062b4:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042062bb:	00 00 00 
  80042062be:	48 8b 00             	mov    (%rax),%rax
  80042062c1:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042062c5:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042062ca:	ba 00 00 20 00       	mov    $0x200000,%edx
  80042062cf:	48 89 c7             	mov    %rax,%rdi
  80042062d2:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  80042062d9:	00 00 00 
  80042062dc:	ff d0                	callq  *%rax
  80042062de:	85 c0                	test   %eax,%eax
  80042062e0:	78 35                	js     8004206317 <page_check+0xf3c>
  80042062e2:	48 b9 a8 70 21 04 80 	movabs $0x80042170a8,%rcx
  80042062e9:	00 00 00 
  80042062ec:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042062f3:	00 00 00 
  80042062f6:	be 45 05 00 00       	mov    $0x545,%esi
  80042062fb:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206302:	00 00 00 
  8004206305:	b8 00 00 00 00       	mov    $0x0,%eax
  800420630a:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206311:	00 00 00 
  8004206314:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206317:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  800420631e:	00 00 00 
  8004206321:	48 8b 00             	mov    (%rax),%rax
  8004206324:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206328:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420632d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206332:	48 89 c7             	mov    %rax,%rdi
  8004206335:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  800420633c:	00 00 00 
  800420633f:	ff d0                	callq  *%rax
  8004206341:	85 c0                	test   %eax,%eax
  8004206343:	74 35                	je     800420637a <page_check+0xf9f>
  8004206345:	48 b9 e0 70 21 04 80 	movabs $0x80042170e0,%rcx
  800420634c:	00 00 00 
  800420634f:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206356:	00 00 00 
  8004206359:	be 48 05 00 00       	mov    $0x548,%esi
  800420635e:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206365:	00 00 00 
  8004206368:	b8 00 00 00 00       	mov    $0x0,%eax
  800420636d:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206374:	00 00 00 
  8004206377:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  800420637a:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206381:	00 00 00 
  8004206384:	48 8b 00             	mov    (%rax),%rax
  8004206387:	ba 00 00 00 00       	mov    $0x0,%edx
  800420638c:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206391:	48 89 c7             	mov    %rax,%rdi
  8004206394:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  800420639b:	00 00 00 
  800420639e:	ff d0                	callq  *%rax
  80042063a0:	48 8b 00             	mov    (%rax),%rax
  80042063a3:	83 e0 04             	and    $0x4,%eax
  80042063a6:	48 85 c0             	test   %rax,%rax
  80042063a9:	74 35                	je     80042063e0 <page_check+0x1005>
  80042063ab:	48 b9 18 71 21 04 80 	movabs $0x8004217118,%rcx
  80042063b2:	00 00 00 
  80042063b5:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042063bc:	00 00 00 
  80042063bf:	be 49 05 00 00       	mov    $0x549,%esi
  80042063c4:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042063cb:	00 00 00 
  80042063ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063d3:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042063da:	00 00 00 
  80042063dd:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  80042063e0:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042063e7:	00 00 00 
  80042063ea:	48 8b 00             	mov    (%rax),%rax
  80042063ed:	be 00 00 00 00       	mov    $0x0,%esi
  80042063f2:	48 89 c7             	mov    %rax,%rdi
  80042063f5:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  80042063fc:	00 00 00 
  80042063ff:	ff d0                	callq  *%rax
  8004206401:	48 89 c3             	mov    %rax,%rbx
  8004206404:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206408:	48 89 c7             	mov    %rax,%rdi
  800420640b:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004206412:	00 00 00 
  8004206415:	ff d0                	callq  *%rax
  8004206417:	48 39 c3             	cmp    %rax,%rbx
  800420641a:	74 35                	je     8004206451 <page_check+0x1076>
  800420641c:	48 b9 50 71 21 04 80 	movabs $0x8004217150,%rcx
  8004206423:	00 00 00 
  8004206426:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420642d:	00 00 00 
  8004206430:	be 4c 05 00 00       	mov    $0x54c,%esi
  8004206435:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420643c:	00 00 00 
  800420643f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206444:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420644b:	00 00 00 
  800420644e:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206451:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206458:	00 00 00 
  800420645b:	48 8b 00             	mov    (%rax),%rax
  800420645e:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206463:	48 89 c7             	mov    %rax,%rdi
  8004206466:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  800420646d:	00 00 00 
  8004206470:	ff d0                	callq  *%rax
  8004206472:	48 89 c3             	mov    %rax,%rbx
  8004206475:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206479:	48 89 c7             	mov    %rax,%rdi
  800420647c:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  8004206483:	00 00 00 
  8004206486:	ff d0                	callq  *%rax
  8004206488:	48 39 c3             	cmp    %rax,%rbx
  800420648b:	74 35                	je     80042064c2 <page_check+0x10e7>
  800420648d:	48 b9 80 71 21 04 80 	movabs $0x8004217180,%rcx
  8004206494:	00 00 00 
  8004206497:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420649e:	00 00 00 
  80042064a1:	be 4d 05 00 00       	mov    $0x54d,%esi
  80042064a6:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042064ad:	00 00 00 
  80042064b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064b5:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042064bc:	00 00 00 
  80042064bf:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  80042064c2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042064c6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042064ca:	66 83 f8 02          	cmp    $0x2,%ax
  80042064ce:	74 35                	je     8004206505 <page_check+0x112a>
  80042064d0:	48 b9 b0 71 21 04 80 	movabs $0x80042171b0,%rcx
  80042064d7:	00 00 00 
  80042064da:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042064e1:	00 00 00 
  80042064e4:	be 4f 05 00 00       	mov    $0x54f,%esi
  80042064e9:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042064f0:	00 00 00 
  80042064f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064f8:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042064ff:	00 00 00 
  8004206502:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206505:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206509:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420650d:	66 83 f8 01          	cmp    $0x1,%ax
  8004206511:	74 35                	je     8004206548 <page_check+0x116d>
  8004206513:	48 b9 c1 71 21 04 80 	movabs $0x80042171c1,%rcx
  800420651a:	00 00 00 
  800420651d:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206524:	00 00 00 
  8004206527:	be 50 05 00 00       	mov    $0x550,%esi
  800420652c:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206533:	00 00 00 
  8004206536:	b8 00 00 00 00       	mov    $0x0,%eax
  800420653b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206542:	00 00 00 
  8004206545:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206548:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  800420654f:	00 00 00 
  8004206552:	48 8b 00             	mov    (%rax),%rax
  8004206555:	be 00 00 00 00       	mov    $0x0,%esi
  800420655a:	48 89 c7             	mov    %rax,%rdi
  800420655d:	48 b8 49 36 20 04 80 	movabs $0x8004203649,%rax
  8004206564:	00 00 00 
  8004206567:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206569:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206570:	00 00 00 
  8004206573:	48 8b 00             	mov    (%rax),%rax
  8004206576:	be 00 00 00 00       	mov    $0x0,%esi
  800420657b:	48 89 c7             	mov    %rax,%rdi
  800420657e:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004206585:	00 00 00 
  8004206588:	ff d0                	callq  *%rax
  800420658a:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420658e:	74 35                	je     80042065c5 <page_check+0x11ea>
  8004206590:	48 b9 d8 71 21 04 80 	movabs $0x80042171d8,%rcx
  8004206597:	00 00 00 
  800420659a:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042065a1:	00 00 00 
  80042065a4:	be 55 05 00 00       	mov    $0x555,%esi
  80042065a9:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042065b0:	00 00 00 
  80042065b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065b8:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042065bf:	00 00 00 
  80042065c2:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  80042065c5:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042065cc:	00 00 00 
  80042065cf:	48 8b 00             	mov    (%rax),%rax
  80042065d2:	be 00 10 00 00       	mov    $0x1000,%esi
  80042065d7:	48 89 c7             	mov    %rax,%rdi
  80042065da:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  80042065e1:	00 00 00 
  80042065e4:	ff d0                	callq  *%rax
  80042065e6:	48 89 c3             	mov    %rax,%rbx
  80042065e9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042065ed:	48 89 c7             	mov    %rax,%rdi
  80042065f0:	48 b8 18 19 20 04 80 	movabs $0x8004201918,%rax
  80042065f7:	00 00 00 
  80042065fa:	ff d0                	callq  *%rax
  80042065fc:	48 39 c3             	cmp    %rax,%rbx
  80042065ff:	74 35                	je     8004206636 <page_check+0x125b>
  8004206601:	48 b9 80 71 21 04 80 	movabs $0x8004217180,%rcx
  8004206608:	00 00 00 
  800420660b:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206612:	00 00 00 
  8004206615:	be 56 05 00 00       	mov    $0x556,%esi
  800420661a:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206621:	00 00 00 
  8004206624:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206629:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206630:	00 00 00 
  8004206633:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206636:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420663a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420663e:	66 83 f8 01          	cmp    $0x1,%ax
  8004206642:	74 35                	je     8004206679 <page_check+0x129e>
  8004206644:	48 b9 25 6f 21 04 80 	movabs $0x8004216f25,%rcx
  800420664b:	00 00 00 
  800420664e:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206655:	00 00 00 
  8004206658:	be 57 05 00 00       	mov    $0x557,%esi
  800420665d:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206664:	00 00 00 
  8004206667:	b8 00 00 00 00       	mov    $0x0,%eax
  800420666c:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206673:	00 00 00 
  8004206676:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206679:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420667d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206681:	66 83 f8 01          	cmp    $0x1,%ax
  8004206685:	74 35                	je     80042066bc <page_check+0x12e1>
  8004206687:	48 b9 c1 71 21 04 80 	movabs $0x80042171c1,%rcx
  800420668e:	00 00 00 
  8004206691:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206698:	00 00 00 
  800420669b:	be 58 05 00 00       	mov    $0x558,%esi
  80042066a0:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042066a7:	00 00 00 
  80042066aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066af:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042066b6:	00 00 00 
  80042066b9:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  80042066bc:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042066c3:	00 00 00 
  80042066c6:	48 8b 00             	mov    (%rax),%rax
  80042066c9:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042066cd:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042066d2:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042066d7:	48 89 c7             	mov    %rax,%rdi
  80042066da:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  80042066e1:	00 00 00 
  80042066e4:	ff d0                	callq  *%rax
  80042066e6:	85 c0                	test   %eax,%eax
  80042066e8:	74 35                	je     800420671f <page_check+0x1344>
  80042066ea:	48 b9 e0 70 21 04 80 	movabs $0x80042170e0,%rcx
  80042066f1:	00 00 00 
  80042066f4:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042066fb:	00 00 00 
  80042066fe:	be 5c 05 00 00       	mov    $0x55c,%esi
  8004206703:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420670a:	00 00 00 
  800420670d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206712:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206719:	00 00 00 
  800420671c:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  800420671f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206723:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206727:	66 85 c0             	test   %ax,%ax
  800420672a:	75 35                	jne    8004206761 <page_check+0x1386>
  800420672c:	48 b9 fb 71 21 04 80 	movabs $0x80042171fb,%rcx
  8004206733:	00 00 00 
  8004206736:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420673d:	00 00 00 
  8004206740:	be 5d 05 00 00       	mov    $0x55d,%esi
  8004206745:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420674c:	00 00 00 
  800420674f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206754:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420675b:	00 00 00 
  800420675e:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206761:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206765:	48 8b 00             	mov    (%rax),%rax
  8004206768:	48 85 c0             	test   %rax,%rax
  800420676b:	74 35                	je     80042067a2 <page_check+0x13c7>
  800420676d:	48 b9 07 72 21 04 80 	movabs $0x8004217207,%rcx
  8004206774:	00 00 00 
  8004206777:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420677e:	00 00 00 
  8004206781:	be 5e 05 00 00       	mov    $0x55e,%esi
  8004206786:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420678d:	00 00 00 
  8004206790:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206795:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420679c:	00 00 00 
  800420679f:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  80042067a2:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042067a9:	00 00 00 
  80042067ac:	48 8b 00             	mov    (%rax),%rax
  80042067af:	be 00 10 00 00       	mov    $0x1000,%esi
  80042067b4:	48 89 c7             	mov    %rax,%rdi
  80042067b7:	48 b8 49 36 20 04 80 	movabs $0x8004203649,%rax
  80042067be:	00 00 00 
  80042067c1:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  80042067c3:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042067ca:	00 00 00 
  80042067cd:	48 8b 00             	mov    (%rax),%rax
  80042067d0:	be 00 00 00 00       	mov    $0x0,%esi
  80042067d5:	48 89 c7             	mov    %rax,%rdi
  80042067d8:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  80042067df:	00 00 00 
  80042067e2:	ff d0                	callq  *%rax
  80042067e4:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042067e8:	74 35                	je     800420681f <page_check+0x1444>
  80042067ea:	48 b9 d8 71 21 04 80 	movabs $0x80042171d8,%rcx
  80042067f1:	00 00 00 
  80042067f4:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042067fb:	00 00 00 
  80042067fe:	be 62 05 00 00       	mov    $0x562,%esi
  8004206803:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420680a:	00 00 00 
  800420680d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206812:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206819:	00 00 00 
  800420681c:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  800420681f:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206826:	00 00 00 
  8004206829:	48 8b 00             	mov    (%rax),%rax
  800420682c:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206831:	48 89 c7             	mov    %rax,%rdi
  8004206834:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  800420683b:	00 00 00 
  800420683e:	ff d0                	callq  *%rax
  8004206840:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206844:	74 35                	je     800420687b <page_check+0x14a0>
  8004206846:	48 b9 20 72 21 04 80 	movabs $0x8004217220,%rcx
  800420684d:	00 00 00 
  8004206850:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206857:	00 00 00 
  800420685a:	be 63 05 00 00       	mov    $0x563,%esi
  800420685f:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206866:	00 00 00 
  8004206869:	b8 00 00 00 00       	mov    $0x0,%eax
  800420686e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206875:	00 00 00 
  8004206878:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  800420687b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420687f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206883:	66 85 c0             	test   %ax,%ax
  8004206886:	74 35                	je     80042068bd <page_check+0x14e2>
  8004206888:	48 b9 46 72 21 04 80 	movabs $0x8004217246,%rcx
  800420688f:	00 00 00 
  8004206892:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206899:	00 00 00 
  800420689c:	be 64 05 00 00       	mov    $0x564,%esi
  80042068a1:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042068a8:	00 00 00 
  80042068ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068b0:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042068b7:	00 00 00 
  80042068ba:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042068bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042068c1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042068c5:	66 83 f8 01          	cmp    $0x1,%ax
  80042068c9:	74 35                	je     8004206900 <page_check+0x1525>
  80042068cb:	48 b9 c1 71 21 04 80 	movabs $0x80042171c1,%rcx
  80042068d2:	00 00 00 
  80042068d5:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042068dc:	00 00 00 
  80042068df:	be 65 05 00 00       	mov    $0x565,%esi
  80042068e4:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042068eb:	00 00 00 
  80042068ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068f3:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042068fa:	00 00 00 
  80042068fd:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif
	//cprintf("HERE\n");
	// forcibly take pp3 back
	struct PageInfo *pp_l1 = pa2page(PTE_ADDR(boot_pml4e[0]));
  8004206900:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206907:	00 00 00 
  800420690a:	48 8b 00             	mov    (%rax),%rax
  800420690d:	48 8b 00             	mov    (%rax),%rax
  8004206910:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206916:	48 89 c7             	mov    %rax,%rdi
  8004206919:	48 b8 3d 19 20 04 80 	movabs $0x800420193d,%rax
  8004206920:	00 00 00 
  8004206923:	ff d0                	callq  *%rax
  8004206925:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	boot_pml4e[0] = 0;
  800420692c:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206933:	00 00 00 
  8004206936:	48 8b 00             	mov    (%rax),%rax
  8004206939:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004206940:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206944:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206948:	66 83 f8 01          	cmp    $0x1,%ax
  800420694c:	74 35                	je     8004206983 <page_check+0x15a8>
  800420694e:	48 b9 c1 71 21 04 80 	movabs $0x80042171c1,%rcx
  8004206955:	00 00 00 
  8004206958:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420695f:	00 00 00 
  8004206962:	be 7b 05 00 00       	mov    $0x57b,%esi
  8004206967:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420696e:	00 00 00 
  8004206971:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206976:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420697d:	00 00 00 
  8004206980:	41 ff d0             	callq  *%r8
	page_decref(pp_l1);
  8004206983:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420698a:	48 89 c7             	mov    %rax,%rdi
  800420698d:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  8004206994:	00 00 00 
  8004206997:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	if (pp_l1 != pp3) page_decref(pp3);
  8004206999:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042069a0:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042069a4:	74 13                	je     80042069b9 <page_check+0x15de>
  80042069a6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042069aa:	48 89 c7             	mov    %rax,%rdi
  80042069ad:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  80042069b4:	00 00 00 
  80042069b7:	ff d0                	callq  *%rax
	if (pp_l1 != pp2) page_decref(pp2);
  80042069b9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042069c0:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042069c4:	74 13                	je     80042069d9 <page_check+0x15fe>
  80042069c6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042069ca:	48 89 c7             	mov    %rax,%rdi
  80042069cd:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  80042069d4:	00 00 00 
  80042069d7:	ff d0                	callq  *%rax
	if (pp_l1 != pp0) page_decref(pp0);
  80042069d9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042069e0:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042069e4:	74 13                	je     80042069f9 <page_check+0x161e>
  80042069e6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042069ea:	48 89 c7             	mov    %rax,%rdi
  80042069ed:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  80042069f4:	00 00 00 
  80042069f7:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  80042069f9:	48 c7 85 60 ff ff ff 	movq   $0x64000,-0xa0(%rbp)
  8004206a00:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004206a04:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206a0b:	00 00 00 
  8004206a0e:	48 8b 00             	mov    (%rax),%rax
  8004206a11:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004206a18:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206a1d:	48 89 ce             	mov    %rcx,%rsi
  8004206a20:	48 89 c7             	mov    %rax,%rdi
  8004206a23:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  8004206a2a:	00 00 00 
  8004206a2d:	ff d0                	callq  *%rax
  8004206a2f:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004206a36:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206a3d:	00 00 00 
  8004206a40:	48 8b 00             	mov    (%rax),%rax
  8004206a43:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004206a4a:	48 c1 ea 27          	shr    $0x27,%rdx
  8004206a4e:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004206a54:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206a58:	48 01 d0             	add    %rdx,%rax
  8004206a5b:	48 8b 00             	mov    (%rax),%rax
  8004206a5e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206a64:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004206a6b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004206a72:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206a76:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
  8004206a7c:	8b 95 54 ff ff ff    	mov    -0xac(%rbp),%edx
  8004206a82:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004206a89:	00 00 00 
  8004206a8c:	48 8b 00             	mov    (%rax),%rax
  8004206a8f:	48 39 c2             	cmp    %rax,%rdx
  8004206a92:	72 35                	jb     8004206ac9 <page_check+0x16ee>
  8004206a94:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004206a9b:	48 89 c1             	mov    %rax,%rcx
  8004206a9e:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004206aa5:	00 00 00 
  8004206aa8:	be 83 05 00 00       	mov    $0x583,%esi
  8004206aad:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206ab4:	00 00 00 
  8004206ab7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206abc:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206ac3:	00 00 00 
  8004206ac6:	41 ff d0             	callq  *%r8
  8004206ac9:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206ad0:	00 00 00 
  8004206ad3:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004206ada:	48 01 d0             	add    %rdx,%rax
  8004206add:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004206ae1:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206ae8:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004206aec:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206af1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206af8:	00 
  8004206af9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206afd:	48 01 d0             	add    %rdx,%rax
  8004206b00:	48 8b 00             	mov    (%rax),%rax
  8004206b03:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206b09:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  8004206b10:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004206b17:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206b1b:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004206b21:	8b 95 44 ff ff ff    	mov    -0xbc(%rbp),%edx
  8004206b27:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004206b2e:	00 00 00 
  8004206b31:	48 8b 00             	mov    (%rax),%rax
  8004206b34:	48 39 c2             	cmp    %rax,%rdx
  8004206b37:	72 35                	jb     8004206b6e <page_check+0x1793>
  8004206b39:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004206b40:	48 89 c1             	mov    %rax,%rcx
  8004206b43:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004206b4a:	00 00 00 
  8004206b4d:	be 84 05 00 00       	mov    $0x584,%esi
  8004206b52:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206b59:	00 00 00 
  8004206b5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b61:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206b68:	00 00 00 
  8004206b6b:	41 ff d0             	callq  *%r8
  8004206b6e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206b75:	00 00 00 
  8004206b78:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004206b7f:	48 01 d0             	add    %rdx,%rax
  8004206b82:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004206b86:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206b8d:	48 c1 e8 15          	shr    $0x15,%rax
  8004206b91:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206b96:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206b9d:	00 
  8004206b9e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206ba2:	48 01 d0             	add    %rdx,%rax
  8004206ba5:	48 8b 00             	mov    (%rax),%rax
  8004206ba8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206bae:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004206bb5:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004206bbc:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206bc0:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
  8004206bc6:	8b 95 34 ff ff ff    	mov    -0xcc(%rbp),%edx
  8004206bcc:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004206bd3:	00 00 00 
  8004206bd6:	48 8b 00             	mov    (%rax),%rax
  8004206bd9:	48 39 c2             	cmp    %rax,%rdx
  8004206bdc:	72 35                	jb     8004206c13 <page_check+0x1838>
  8004206bde:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004206be5:	48 89 c1             	mov    %rax,%rcx
  8004206be8:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004206bef:	00 00 00 
  8004206bf2:	be 85 05 00 00       	mov    $0x585,%esi
  8004206bf7:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206bfe:	00 00 00 
  8004206c01:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c06:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206c0d:	00 00 00 
  8004206c10:	41 ff d0             	callq  *%r8
  8004206c13:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206c1a:	00 00 00 
  8004206c1d:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004206c24:	48 01 d0             	add    %rdx,%rax
  8004206c27:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004206c2e:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206c35:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206c39:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206c3e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206c45:	00 
  8004206c46:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206c4d:	48 01 c2             	add    %rax,%rdx
  8004206c50:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004206c57:	48 39 c2             	cmp    %rax,%rdx
  8004206c5a:	74 35                	je     8004206c91 <page_check+0x18b6>
  8004206c5c:	48 b9 57 72 21 04 80 	movabs $0x8004217257,%rcx
  8004206c63:	00 00 00 
  8004206c66:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206c6d:	00 00 00 
  8004206c70:	be 86 05 00 00       	mov    $0x586,%esi
  8004206c75:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206c7c:	00 00 00 
  8004206c7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c84:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206c8b:	00 00 00 
  8004206c8e:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	memset(page2kva(pp4), 0xFF, PGSIZE);
  8004206c91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206c95:	48 89 c7             	mov    %rax,%rdi
  8004206c98:	48 b8 ae 19 20 04 80 	movabs $0x80042019ae,%rax
  8004206c9f:	00 00 00 
  8004206ca2:	ff d0                	callq  *%rax
  8004206ca4:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206ca9:	be ff 00 00 00       	mov    $0xff,%esi
  8004206cae:	48 89 c7             	mov    %rax,%rdi
  8004206cb1:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004206cb8:	00 00 00 
  8004206cbb:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004206cbd:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206cc4:	00 00 00 
  8004206cc7:	48 8b 00             	mov    (%rax),%rax
  8004206cca:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206ccf:	be 00 00 00 00       	mov    $0x0,%esi
  8004206cd4:	48 89 c7             	mov    %rax,%rdi
  8004206cd7:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  8004206cde:	00 00 00 
  8004206ce1:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004206ce3:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206cea:	00 00 00 
  8004206ced:	48 8b 00             	mov    (%rax),%rax
  8004206cf0:	48 8b 00             	mov    (%rax),%rax
  8004206cf3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206cf9:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004206d00:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004206d07:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206d0b:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
  8004206d11:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  8004206d17:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004206d1e:	00 00 00 
  8004206d21:	48 8b 00             	mov    (%rax),%rax
  8004206d24:	48 39 c2             	cmp    %rax,%rdx
  8004206d27:	72 35                	jb     8004206d5e <page_check+0x1983>
  8004206d29:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004206d30:	48 89 c1             	mov    %rax,%rcx
  8004206d33:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004206d3a:	00 00 00 
  8004206d3d:	be 8b 05 00 00       	mov    $0x58b,%esi
  8004206d42:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206d49:	00 00 00 
  8004206d4c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d51:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206d58:	00 00 00 
  8004206d5b:	41 ff d0             	callq  *%r8
  8004206d5e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206d65:	00 00 00 
  8004206d68:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  8004206d6f:	48 01 d0             	add    %rdx,%rax
  8004206d72:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004206d76:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206d7a:	48 8b 00             	mov    (%rax),%rax
  8004206d7d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206d83:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004206d8a:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004206d91:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206d95:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
  8004206d9b:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  8004206da1:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004206da8:	00 00 00 
  8004206dab:	48 8b 00             	mov    (%rax),%rax
  8004206dae:	48 39 c2             	cmp    %rax,%rdx
  8004206db1:	72 35                	jb     8004206de8 <page_check+0x1a0d>
  8004206db3:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004206dba:	48 89 c1             	mov    %rax,%rcx
  8004206dbd:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004206dc4:	00 00 00 
  8004206dc7:	be 8c 05 00 00       	mov    $0x58c,%esi
  8004206dcc:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206dd3:	00 00 00 
  8004206dd6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ddb:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206de2:	00 00 00 
  8004206de5:	41 ff d0             	callq  *%r8
  8004206de8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206def:	00 00 00 
  8004206df2:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004206df9:	48 01 d0             	add    %rdx,%rax
  8004206dfc:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  8004206e00:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206e04:	48 8b 00             	mov    (%rax),%rax
  8004206e07:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206e0d:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004206e14:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004206e1b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206e1f:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
  8004206e25:	8b 95 fc fe ff ff    	mov    -0x104(%rbp),%edx
  8004206e2b:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004206e32:	00 00 00 
  8004206e35:	48 8b 00             	mov    (%rax),%rax
  8004206e38:	48 39 c2             	cmp    %rax,%rdx
  8004206e3b:	72 35                	jb     8004206e72 <page_check+0x1a97>
  8004206e3d:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004206e44:	48 89 c1             	mov    %rax,%rcx
  8004206e47:	48 ba e8 65 21 04 80 	movabs $0x80042165e8,%rdx
  8004206e4e:	00 00 00 
  8004206e51:	be 8d 05 00 00       	mov    $0x58d,%esi
  8004206e56:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206e5d:	00 00 00 
  8004206e60:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e65:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206e6c:	00 00 00 
  8004206e6f:	41 ff d0             	callq  *%r8
  8004206e72:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206e79:	00 00 00 
  8004206e7c:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  8004206e83:	48 01 d0             	add    %rdx,%rax
  8004206e86:	48 89 85 e0 fe ff ff 	mov    %rax,-0x120(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  8004206e8d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004206e94:	eb 58                	jmp    8004206eee <page_check+0x1b13>
		assert((ptep[i] & PTE_P) == 0);
  8004206e96:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
  8004206e9d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004206ea0:	48 63 d2             	movslq %edx,%rdx
  8004206ea3:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206ea7:	48 01 d0             	add    %rdx,%rax
  8004206eaa:	48 8b 00             	mov    (%rax),%rax
  8004206ead:	83 e0 01             	and    $0x1,%eax
  8004206eb0:	48 85 c0             	test   %rax,%rax
  8004206eb3:	74 35                	je     8004206eea <page_check+0x1b0f>
  8004206eb5:	48 b9 6f 72 21 04 80 	movabs $0x800421726f,%rcx
  8004206ebc:	00 00 00 
  8004206ebf:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206ec6:	00 00 00 
  8004206ec9:	be 8f 05 00 00       	mov    $0x58f,%esi
  8004206ece:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206ed5:	00 00 00 
  8004206ed8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206edd:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206ee4:	00 00 00 
  8004206ee7:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  8004206eea:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004206eee:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  8004206ef5:	7e 9f                	jle    8004206e96 <page_check+0x1abb>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  8004206ef7:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004206efe:	00 00 00 
  8004206f01:	48 8b 00             	mov    (%rax),%rax
  8004206f04:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  8004206f0b:	48 b8 38 22 36 04 80 	movabs $0x8004362238,%rax
  8004206f12:	00 00 00 
  8004206f15:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004206f19:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004206f1c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206f20:	48 89 c7             	mov    %rax,%rdi
  8004206f23:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  8004206f2a:	00 00 00 
  8004206f2d:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206f2f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206f33:	48 89 c7             	mov    %rax,%rdi
  8004206f36:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  8004206f3d:	00 00 00 
  8004206f40:	ff d0                	callq  *%rax
	page_decref(pp3);
  8004206f42:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206f46:	48 89 c7             	mov    %rax,%rdi
  8004206f49:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  8004206f50:	00 00 00 
  8004206f53:	ff d0                	callq  *%rax

	// Triple check that we got the ref counts right
	assert(pp0->pp_ref == 0);
  8004206f55:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206f59:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206f5d:	66 85 c0             	test   %ax,%ax
  8004206f60:	74 35                	je     8004206f97 <page_check+0x1bbc>
  8004206f62:	48 b9 86 72 21 04 80 	movabs $0x8004217286,%rcx
  8004206f69:	00 00 00 
  8004206f6c:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206f73:	00 00 00 
  8004206f76:	be 9b 05 00 00       	mov    $0x59b,%esi
  8004206f7b:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206f82:	00 00 00 
  8004206f85:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f8a:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206f91:	00 00 00 
  8004206f94:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206f97:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206f9b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206f9f:	66 85 c0             	test   %ax,%ax
  8004206fa2:	74 35                	je     8004206fd9 <page_check+0x1bfe>
  8004206fa4:	48 b9 46 72 21 04 80 	movabs $0x8004217246,%rcx
  8004206fab:	00 00 00 
  8004206fae:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206fb5:	00 00 00 
  8004206fb8:	be 9c 05 00 00       	mov    $0x59c,%esi
  8004206fbd:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004206fc4:	00 00 00 
  8004206fc7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206fcc:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004206fd3:	00 00 00 
  8004206fd6:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 0);
  8004206fd9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206fdd:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206fe1:	66 85 c0             	test   %ax,%ax
  8004206fe4:	74 35                	je     800420701b <page_check+0x1c40>
  8004206fe6:	48 b9 97 72 21 04 80 	movabs $0x8004217297,%rcx
  8004206fed:	00 00 00 
  8004206ff0:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004206ff7:	00 00 00 
  8004206ffa:	be 9d 05 00 00       	mov    $0x59d,%esi
  8004206fff:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004207006:	00 00 00 
  8004207009:	b8 00 00 00 00       	mov    $0x0,%eax
  800420700e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004207015:	00 00 00 
  8004207018:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 0);
  800420701b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420701f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207023:	66 85 c0             	test   %ax,%ax
  8004207026:	74 35                	je     800420705d <page_check+0x1c82>
  8004207028:	48 b9 a8 72 21 04 80 	movabs $0x80042172a8,%rcx
  800420702f:	00 00 00 
  8004207032:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004207039:	00 00 00 
  800420703c:	be 9e 05 00 00       	mov    $0x59e,%esi
  8004207041:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004207048:	00 00 00 
  800420704b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207050:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004207057:	00 00 00 
  800420705a:	41 ff d0             	callq  *%r8
	assert(pp4->pp_ref == 0);
  800420705d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207061:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207065:	66 85 c0             	test   %ax,%ax
  8004207068:	74 35                	je     800420709f <page_check+0x1cc4>
  800420706a:	48 b9 b9 72 21 04 80 	movabs $0x80042172b9,%rcx
  8004207071:	00 00 00 
  8004207074:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420707b:	00 00 00 
  800420707e:	be 9f 05 00 00       	mov    $0x59f,%esi
  8004207083:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420708a:	00 00 00 
  800420708d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207092:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004207099:	00 00 00 
  800420709c:	41 ff d0             	callq  *%r8
	assert(pp5->pp_ref == 0);
  800420709f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042070a3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042070a7:	66 85 c0             	test   %ax,%ax
  80042070aa:	74 35                	je     80042070e1 <page_check+0x1d06>
  80042070ac:	48 b9 ca 72 21 04 80 	movabs $0x80042172ca,%rcx
  80042070b3:	00 00 00 
  80042070b6:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042070bd:	00 00 00 
  80042070c0:	be a0 05 00 00       	mov    $0x5a0,%esi
  80042070c5:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042070cc:	00 00 00 
  80042070cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070d4:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042070db:	00 00 00 
  80042070de:	41 ff d0             	callq  *%r8

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  80042070e1:	be 01 10 00 00       	mov    $0x1001,%esi
  80042070e6:	bf 00 00 00 00       	mov    $0x0,%edi
  80042070eb:	48 b8 c8 37 20 04 80 	movabs $0x80042037c8,%rax
  80042070f2:	00 00 00 
  80042070f5:	ff d0                	callq  *%rax
  80042070f7:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  80042070fe:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207103:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207108:	48 b8 c8 37 20 04 80 	movabs $0x80042037c8,%rax
  800420710f:	00 00 00 
  8004207112:	ff d0                	callq  *%rax
  8004207114:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  800420711b:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207122:	00 00 00 
  8004207125:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  800420712c:	76 1d                	jbe    800420714b <page_check+0x1d70>
  800420712e:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207135:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  800420713c:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207143:	00 00 00 
  8004207146:	48 39 c2             	cmp    %rax,%rdx
  8004207149:	76 35                	jbe    8004207180 <page_check+0x1da5>
  800420714b:	48 b9 e0 72 21 04 80 	movabs $0x80042172e0,%rcx
  8004207152:	00 00 00 
  8004207155:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420715c:	00 00 00 
  800420715f:	be a6 05 00 00       	mov    $0x5a6,%esi
  8004207164:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420716b:	00 00 00 
  800420716e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207173:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420717a:	00 00 00 
  800420717d:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  8004207180:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207187:	00 00 00 
  800420718a:	48 39 85 e8 fe ff ff 	cmp    %rax,-0x118(%rbp)
  8004207191:	76 1d                	jbe    80042071b0 <page_check+0x1dd5>
  8004207193:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  800420719a:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  80042071a1:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042071a8:	00 00 00 
  80042071ab:	48 39 c2             	cmp    %rax,%rdx
  80042071ae:	76 35                	jbe    80042071e5 <page_check+0x1e0a>
  80042071b0:	48 b9 08 73 21 04 80 	movabs $0x8004217308,%rcx
  80042071b7:	00 00 00 
  80042071ba:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042071c1:	00 00 00 
  80042071c4:	be a7 05 00 00       	mov    $0x5a7,%esi
  80042071c9:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042071d0:	00 00 00 
  80042071d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071d8:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042071df:	00 00 00 
  80042071e2:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	//cprintf("mm1: %d mm2: %d\n", mm1, mm2);
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  80042071e5:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042071ec:	25 ff 0f 00 00       	and    $0xfff,%eax
  80042071f1:	48 85 c0             	test   %rax,%rax
  80042071f4:	75 11                	jne    8004207207 <page_check+0x1e2c>
  80042071f6:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042071fd:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207202:	48 85 c0             	test   %rax,%rax
  8004207205:	74 35                	je     800420723c <page_check+0x1e61>
  8004207207:	48 b9 30 73 21 04 80 	movabs $0x8004217330,%rcx
  800420720e:	00 00 00 
  8004207211:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004207218:	00 00 00 
  800420721b:	be aa 05 00 00       	mov    $0x5aa,%esi
  8004207220:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004207227:	00 00 00 
  800420722a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420722f:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004207236:	00 00 00 
  8004207239:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	//cprintf("mm1: %d mm2: %d\n", mm1, mm2);
	assert(mm1 + 8096 <= mm2);
  800420723c:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207243:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  8004207249:	48 3b 85 e8 fe ff ff 	cmp    -0x118(%rbp),%rax
  8004207250:	76 35                	jbe    8004207287 <page_check+0x1eac>
  8004207252:	48 b9 57 73 21 04 80 	movabs $0x8004217357,%rcx
  8004207259:	00 00 00 
  800420725c:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004207263:	00 00 00 
  8004207266:	be ad 05 00 00       	mov    $0x5ad,%esi
  800420726b:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004207272:	00 00 00 
  8004207275:	b8 00 00 00 00       	mov    $0x0,%eax
  800420727a:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004207281:	00 00 00 
  8004207284:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  8004207287:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  800420728e:	00 00 00 
  8004207291:	48 8b 00             	mov    (%rax),%rax
  8004207294:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  800420729b:	48 89 d6             	mov    %rdx,%rsi
  800420729e:	48 89 c7             	mov    %rax,%rdi
  80042072a1:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  80042072a8:	00 00 00 
  80042072ab:	ff d0                	callq  *%rax
  80042072ad:	48 85 c0             	test   %rax,%rax
  80042072b0:	74 35                	je     80042072e7 <page_check+0x1f0c>
  80042072b2:	48 b9 70 73 21 04 80 	movabs $0x8004217370,%rcx
  80042072b9:	00 00 00 
  80042072bc:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042072c3:	00 00 00 
  80042072c6:	be b0 05 00 00       	mov    $0x5b0,%esi
  80042072cb:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042072d2:	00 00 00 
  80042072d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072da:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042072e1:	00 00 00 
  80042072e4:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  80042072e7:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042072ee:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  80042072f5:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042072fc:	00 00 00 
  80042072ff:	48 8b 00             	mov    (%rax),%rax
  8004207302:	48 89 d6             	mov    %rdx,%rsi
  8004207305:	48 89 c7             	mov    %rax,%rdi
  8004207308:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  800420730f:	00 00 00 
  8004207312:	ff d0                	callq  *%rax
  8004207314:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  800420731a:	74 35                	je     8004207351 <page_check+0x1f76>
  800420731c:	48 b9 98 73 21 04 80 	movabs $0x8004217398,%rcx
  8004207323:	00 00 00 
  8004207326:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420732d:	00 00 00 
  8004207330:	be b1 05 00 00       	mov    $0x5b1,%esi
  8004207335:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420733c:	00 00 00 
  800420733f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207344:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420734b:	00 00 00 
  800420734e:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004207351:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004207358:	00 00 00 
  800420735b:	48 8b 00             	mov    (%rax),%rax
  800420735e:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  8004207365:	48 89 d6             	mov    %rdx,%rsi
  8004207368:	48 89 c7             	mov    %rax,%rdi
  800420736b:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  8004207372:	00 00 00 
  8004207375:	ff d0                	callq  *%rax
  8004207377:	48 85 c0             	test   %rax,%rax
  800420737a:	74 35                	je     80042073b1 <page_check+0x1fd6>
  800420737c:	48 b9 c8 73 21 04 80 	movabs $0x80042173c8,%rcx
  8004207383:	00 00 00 
  8004207386:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  800420738d:	00 00 00 
  8004207390:	be b2 05 00 00       	mov    $0x5b2,%esi
  8004207395:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420739c:	00 00 00 
  800420739f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073a4:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042073ab:	00 00 00 
  80042073ae:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  80042073b1:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042073b8:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  80042073bf:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042073c6:	00 00 00 
  80042073c9:	48 8b 00             	mov    (%rax),%rax
  80042073cc:	48 89 d6             	mov    %rdx,%rsi
  80042073cf:	48 89 c7             	mov    %rax,%rdi
  80042073d2:	48 b8 61 51 20 04 80 	movabs $0x8004205161,%rax
  80042073d9:	00 00 00 
  80042073dc:	ff d0                	callq  *%rax
  80042073de:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042073e2:	74 35                	je     8004207419 <page_check+0x203e>
  80042073e4:	48 b9 f0 73 21 04 80 	movabs $0x80042173f0,%rcx
  80042073eb:	00 00 00 
  80042073ee:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042073f5:	00 00 00 
  80042073f8:	be b3 05 00 00       	mov    $0x5b3,%esi
  80042073fd:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  8004207404:	00 00 00 
  8004207407:	b8 00 00 00 00       	mov    $0x0,%eax
  800420740c:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004207413:	00 00 00 
  8004207416:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  8004207419:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207420:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004207427:	00 00 00 
  800420742a:	48 8b 00             	mov    (%rax),%rax
  800420742d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207432:	48 89 ce             	mov    %rcx,%rsi
  8004207435:	48 89 c7             	mov    %rax,%rdi
  8004207438:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  800420743f:	00 00 00 
  8004207442:	ff d0                	callq  *%rax
  8004207444:	48 8b 00             	mov    (%rax),%rax
  8004207447:	83 e0 1a             	and    $0x1a,%eax
  800420744a:	48 85 c0             	test   %rax,%rax
  800420744d:	75 35                	jne    8004207484 <page_check+0x20a9>
  800420744f:	48 b9 20 74 21 04 80 	movabs $0x8004217420,%rcx
  8004207456:	00 00 00 
  8004207459:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  8004207460:	00 00 00 
  8004207463:	be b5 05 00 00       	mov    $0x5b5,%esi
  8004207468:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  800420746f:	00 00 00 
  8004207472:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207477:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420747e:	00 00 00 
  8004207481:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004207484:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  800420748b:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004207492:	00 00 00 
  8004207495:	48 8b 00             	mov    (%rax),%rax
  8004207498:	ba 00 00 00 00       	mov    $0x0,%edx
  800420749d:	48 89 ce             	mov    %rcx,%rsi
  80042074a0:	48 89 c7             	mov    %rax,%rdi
  80042074a3:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  80042074aa:	00 00 00 
  80042074ad:	ff d0                	callq  *%rax
  80042074af:	48 8b 00             	mov    (%rax),%rax
  80042074b2:	83 e0 04             	and    $0x4,%eax
  80042074b5:	48 85 c0             	test   %rax,%rax
  80042074b8:	74 35                	je     80042074ef <page_check+0x2114>
  80042074ba:	48 b9 68 74 21 04 80 	movabs $0x8004217468,%rcx
  80042074c1:	00 00 00 
  80042074c4:	48 ba 61 66 21 04 80 	movabs $0x8004216661,%rdx
  80042074cb:	00 00 00 
  80042074ce:	be b6 05 00 00       	mov    $0x5b6,%esi
  80042074d3:	48 bf 76 66 21 04 80 	movabs $0x8004216676,%rdi
  80042074da:	00 00 00 
  80042074dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074e2:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042074e9:	00 00 00 
  80042074ec:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  80042074ef:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  80042074f6:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  80042074fd:	00 00 00 
  8004207500:	48 8b 00             	mov    (%rax),%rax
  8004207503:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207508:	48 89 ce             	mov    %rcx,%rsi
  800420750b:	48 89 c7             	mov    %rax,%rdi
  800420750e:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  8004207515:	00 00 00 
  8004207518:	ff d0                	callq  *%rax
  800420751a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004207521:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207528:	48 05 00 10 00 00    	add    $0x1000,%rax
  800420752e:	48 89 c1             	mov    %rax,%rcx
  8004207531:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004207538:	00 00 00 
  800420753b:	48 8b 00             	mov    (%rax),%rax
  800420753e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207543:	48 89 ce             	mov    %rcx,%rsi
  8004207546:	48 89 c7             	mov    %rax,%rdi
  8004207549:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  8004207550:	00 00 00 
  8004207553:	ff d0                	callq  *%rax
  8004207555:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  800420755c:	48 8b 8d e8 fe ff ff 	mov    -0x118(%rbp),%rcx
  8004207563:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  800420756a:	00 00 00 
  800420756d:	48 8b 00             	mov    (%rax),%rax
  8004207570:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207575:	48 89 ce             	mov    %rcx,%rsi
  8004207578:	48 89 c7             	mov    %rax,%rdi
  800420757b:	48 b8 ad 2c 20 04 80 	movabs $0x8004202cad,%rax
  8004207582:	00 00 00 
  8004207585:	ff d0                	callq  *%rax
  8004207587:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  800420758e:	48 bf 9b 74 21 04 80 	movabs $0x800421749b,%rdi
  8004207595:	00 00 00 
  8004207598:	b8 00 00 00 00       	mov    $0x0,%eax
  800420759d:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042075a4:	00 00 00 
  80042075a7:	ff d2                	callq  *%rdx
}
  80042075a9:	90                   	nop
  80042075aa:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  80042075b1:	5b                   	pop    %rbx
  80042075b2:	5d                   	pop    %rbp
  80042075b3:	c3                   	retq   

00000080042075b4 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  80042075b4:	55                   	push   %rbp
  80042075b5:	48 89 e5             	mov    %rsp,%rbp
  80042075b8:	48 83 ec 08          	sub    $0x8,%rsp
  80042075bc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  80042075c0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042075c4:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  80042075cb:	00 00 00 
  80042075ce:	48 8b 00             	mov    (%rax),%rax
  80042075d1:	48 29 c2             	sub    %rax,%rdx
  80042075d4:	48 89 d0             	mov    %rdx,%rax
  80042075d7:	48 c1 f8 04          	sar    $0x4,%rax
}
  80042075db:	c9                   	leaveq 
  80042075dc:	c3                   	retq   

00000080042075dd <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  80042075dd:	55                   	push   %rbp
  80042075de:	48 89 e5             	mov    %rsp,%rbp
  80042075e1:	48 83 ec 08          	sub    $0x8,%rsp
  80042075e5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042075e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042075ed:	48 89 c7             	mov    %rax,%rdi
  80042075f0:	48 b8 b4 75 20 04 80 	movabs $0x80042075b4,%rax
  80042075f7:	00 00 00 
  80042075fa:	ff d0                	callq  *%rax
  80042075fc:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207600:	c9                   	leaveq 
  8004207601:	c3                   	retq   

0000008004207602 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004207602:	55                   	push   %rbp
  8004207603:	48 89 e5             	mov    %rsp,%rbp
  8004207606:	48 83 ec 10          	sub    $0x10,%rsp
  800420760a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  800420760e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207612:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207616:	48 89 c2             	mov    %rax,%rdx
  8004207619:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004207620:	00 00 00 
  8004207623:	48 8b 00             	mov    (%rax),%rax
  8004207626:	48 39 c2             	cmp    %rax,%rdx
  8004207629:	72 2a                	jb     8004207655 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  800420762b:	48 ba b8 74 21 04 80 	movabs $0x80042174b8,%rdx
  8004207632:	00 00 00 
  8004207635:	be 54 00 00 00       	mov    $0x54,%esi
  800420763a:	48 bf d7 74 21 04 80 	movabs $0x80042174d7,%rdi
  8004207641:	00 00 00 
  8004207644:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207649:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  8004207650:	00 00 00 
  8004207653:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004207655:	48 b8 38 37 36 04 80 	movabs $0x8004363738,%rax
  800420765c:	00 00 00 
  800420765f:	48 8b 00             	mov    (%rax),%rax
  8004207662:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207666:	48 c1 ea 0c          	shr    $0xc,%rdx
  800420766a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420766e:	48 01 d0             	add    %rdx,%rax
}
  8004207671:	c9                   	leaveq 
  8004207672:	c3                   	retq   

0000008004207673 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004207673:	55                   	push   %rbp
  8004207674:	48 89 e5             	mov    %rsp,%rbp
  8004207677:	48 83 ec 20          	sub    $0x20,%rsp
  800420767b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800420767f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207683:	48 89 c7             	mov    %rax,%rdi
  8004207686:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  800420768d:	00 00 00 
  8004207690:	ff d0                	callq  *%rax
  8004207692:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207696:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420769a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420769e:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042076a1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042076a4:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042076ab:	00 00 00 
  80042076ae:	48 8b 00             	mov    (%rax),%rax
  80042076b1:	48 39 c2             	cmp    %rax,%rdx
  80042076b4:	72 32                	jb     80042076e8 <page2kva+0x75>
  80042076b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042076ba:	48 89 c1             	mov    %rax,%rcx
  80042076bd:	48 ba e8 74 21 04 80 	movabs $0x80042174e8,%rdx
  80042076c4:	00 00 00 
  80042076c7:	be 5b 00 00 00       	mov    $0x5b,%esi
  80042076cc:	48 bf d7 74 21 04 80 	movabs $0x80042174d7,%rdi
  80042076d3:	00 00 00 
  80042076d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076db:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042076e2:	00 00 00 
  80042076e5:	41 ff d0             	callq  *%r8
  80042076e8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042076ef:	00 00 00 
  80042076f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042076f6:	48 01 d0             	add    %rdx,%rax
}
  80042076f9:	c9                   	leaveq 
  80042076fa:	c3                   	retq   

00000080042076fb <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  80042076fb:	55                   	push   %rbp
  80042076fc:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  80042076ff:	48 bf 80 b7 22 04 80 	movabs $0x800422b780,%rdi
  8004207706:	00 00 00 
  8004207709:	48 b8 ee 5f 21 04 80 	movabs $0x8004215fee,%rax
  8004207710:	00 00 00 
  8004207713:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207715:	f3 90                	pause  
}
  8004207717:	90                   	nop
  8004207718:	5d                   	pop    %rbp
  8004207719:	c3                   	retq   

000000800420771a <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  800420771a:	55                   	push   %rbp
  800420771b:	48 89 e5             	mov    %rsp,%rbp
  800420771e:	53                   	push   %rbx
  800420771f:	48 83 ec 28          	sub    $0x28,%rsp
  8004207723:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004207726:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420772a:	89 d0                	mov    %edx,%eax
  800420772c:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  800420772f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207733:	75 4b                	jne    8004207780 <envid2env+0x66>
		*env_store = curenv;
  8004207735:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420773c:	00 00 00 
  800420773f:	ff d0                	callq  *%rax
  8004207741:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  8004207748:	00 00 00 
  800420774b:	48 98                	cltq   
  800420774d:	48 89 c2             	mov    %rax,%rdx
  8004207750:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004207757:	00 
  8004207758:	48 89 c2             	mov    %rax,%rdx
  800420775b:	48 89 d0             	mov    %rdx,%rax
  800420775e:	48 c1 e0 04          	shl    $0x4,%rax
  8004207762:	48 29 d0             	sub    %rdx,%rax
  8004207765:	48 01 c8             	add    %rcx,%rax
  8004207768:	48 83 c0 08          	add    $0x8,%rax
  800420776c:	48 8b 10             	mov    (%rax),%rdx
  800420776f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207773:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  8004207776:	b8 00 00 00 00       	mov    $0x0,%eax
  800420777b:	e9 1b 01 00 00       	jmpq   800420789b <envid2env+0x181>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004207780:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  8004207787:	00 00 00 
  800420778a:	48 8b 08             	mov    (%rax),%rcx
  800420778d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207790:	48 98                	cltq   
  8004207792:	25 ff 03 00 00       	and    $0x3ff,%eax
  8004207797:	48 89 c2             	mov    %rax,%rdx
  800420779a:	48 89 d0             	mov    %rdx,%rax
  800420779d:	48 c1 e0 03          	shl    $0x3,%rax
  80042077a1:	48 01 d0             	add    %rdx,%rax
  80042077a4:	48 c1 e0 05          	shl    $0x5,%rax
  80042077a8:	48 01 c8             	add    %rcx,%rax
  80042077ab:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  80042077af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042077b3:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042077b9:	85 c0                	test   %eax,%eax
  80042077bb:	74 0f                	je     80042077cc <envid2env+0xb2>
  80042077bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042077c1:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042077c7:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  80042077ca:	74 15                	je     80042077e1 <envid2env+0xc7>
		*env_store = 0;
  80042077cc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042077d0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  80042077d7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80042077dc:	e9 ba 00 00 00       	jmpq   800420789b <envid2env+0x181>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  80042077e1:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  80042077e5:	0f 84 a0 00 00 00    	je     800420788b <envid2env+0x171>
  80042077eb:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  80042077f2:	00 00 00 
  80042077f5:	ff d0                	callq  *%rax
  80042077f7:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  80042077fe:	00 00 00 
  8004207801:	48 98                	cltq   
  8004207803:	48 89 c2             	mov    %rax,%rdx
  8004207806:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420780d:	00 
  800420780e:	48 89 c2             	mov    %rax,%rdx
  8004207811:	48 89 d0             	mov    %rdx,%rax
  8004207814:	48 c1 e0 04          	shl    $0x4,%rax
  8004207818:	48 29 d0             	sub    %rdx,%rax
  800420781b:	48 01 c8             	add    %rcx,%rax
  800420781e:	48 83 c0 08          	add    $0x8,%rax
  8004207822:	48 8b 00             	mov    (%rax),%rax
  8004207825:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207829:	74 60                	je     800420788b <envid2env+0x171>
  800420782b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420782f:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  8004207835:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420783c:	00 00 00 
  800420783f:	ff d0                	callq  *%rax
  8004207841:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  8004207848:	00 00 00 
  800420784b:	48 98                	cltq   
  800420784d:	48 89 c2             	mov    %rax,%rdx
  8004207850:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004207857:	00 
  8004207858:	48 89 c2             	mov    %rax,%rdx
  800420785b:	48 89 d0             	mov    %rdx,%rax
  800420785e:	48 c1 e0 04          	shl    $0x4,%rax
  8004207862:	48 29 d0             	sub    %rdx,%rax
  8004207865:	48 01 c8             	add    %rcx,%rax
  8004207868:	48 83 c0 08          	add    $0x8,%rax
  800420786c:	48 8b 00             	mov    (%rax),%rax
  800420786f:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207875:	39 c3                	cmp    %eax,%ebx
  8004207877:	74 12                	je     800420788b <envid2env+0x171>
		*env_store = 0;
  8004207879:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420787d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207884:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207889:	eb 10                	jmp    800420789b <envid2env+0x181>
	}

	*env_store = e;
  800420788b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420788f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207893:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8004207896:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420789b:	48 83 c4 28          	add    $0x28,%rsp
  800420789f:	5b                   	pop    %rbx
  80042078a0:	5d                   	pop    %rbp
  80042078a1:	c3                   	retq   

00000080042078a2 <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  80042078a2:	55                   	push   %rbp
  80042078a3:	48 89 e5             	mov    %rsp,%rbp
  80042078a6:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	
	env_free_list = NULL;
  80042078aa:	48 b8 58 22 36 04 80 	movabs $0x8004362258,%rax
  80042078b1:	00 00 00 
  80042078b4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	for(int i = NENV-1; i >= 0; i--) {
  80042078bb:	c7 45 fc ff 03 00 00 	movl   $0x3ff,-0x4(%rbp)
  80042078c2:	e9 cb 00 00 00       	jmpq   8004207992 <env_init+0xf0>
	    	envs[i].env_link = env_free_list;
  80042078c7:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  80042078ce:	00 00 00 
  80042078d1:	48 8b 08             	mov    (%rax),%rcx
  80042078d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042078d7:	48 63 d0             	movslq %eax,%rdx
  80042078da:	48 89 d0             	mov    %rdx,%rax
  80042078dd:	48 c1 e0 03          	shl    $0x3,%rax
  80042078e1:	48 01 d0             	add    %rdx,%rax
  80042078e4:	48 c1 e0 05          	shl    $0x5,%rax
  80042078e8:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042078ec:	48 b8 58 22 36 04 80 	movabs $0x8004362258,%rax
  80042078f3:	00 00 00 
  80042078f6:	48 8b 00             	mov    (%rax),%rax
  80042078f9:	48 89 82 c0 00 00 00 	mov    %rax,0xc0(%rdx)
		envs[i].env_id = 0;
  8004207900:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  8004207907:	00 00 00 
  800420790a:	48 8b 08             	mov    (%rax),%rcx
  800420790d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004207910:	48 63 d0             	movslq %eax,%rdx
  8004207913:	48 89 d0             	mov    %rdx,%rax
  8004207916:	48 c1 e0 03          	shl    $0x3,%rax
  800420791a:	48 01 d0             	add    %rdx,%rax
  800420791d:	48 c1 e0 05          	shl    $0x5,%rax
  8004207921:	48 01 c8             	add    %rcx,%rax
  8004207924:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  800420792b:	00 00 00 
		envs[i].env_status = ENV_FREE;
  800420792e:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  8004207935:	00 00 00 
  8004207938:	48 8b 08             	mov    (%rax),%rcx
  800420793b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420793e:	48 63 d0             	movslq %eax,%rdx
  8004207941:	48 89 d0             	mov    %rdx,%rax
  8004207944:	48 c1 e0 03          	shl    $0x3,%rax
  8004207948:	48 01 d0             	add    %rdx,%rax
  800420794b:	48 c1 e0 05          	shl    $0x5,%rax
  800420794f:	48 01 c8             	add    %rcx,%rax
  8004207952:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004207959:	00 00 00 
		env_free_list = envs + i;
  800420795c:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  8004207963:	00 00 00 
  8004207966:	48 8b 08             	mov    (%rax),%rcx
  8004207969:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420796c:	48 63 d0             	movslq %eax,%rdx
  800420796f:	48 89 d0             	mov    %rdx,%rax
  8004207972:	48 c1 e0 03          	shl    $0x3,%rax
  8004207976:	48 01 d0             	add    %rdx,%rax
  8004207979:	48 c1 e0 05          	shl    $0x5,%rax
  800420797d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004207981:	48 b8 58 22 36 04 80 	movabs $0x8004362258,%rax
  8004207988:	00 00 00 
  800420798b:	48 89 10             	mov    %rdx,(%rax)
{
	// Set up envs array
	// LAB 3: Your code here.
	
	env_free_list = NULL;
	for(int i = NENV-1; i >= 0; i--) {
  800420798e:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  8004207992:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207996:	0f 89 2b ff ff ff    	jns    80042078c7 <env_init+0x25>
		envs[i].env_id = 0;
		envs[i].env_status = ENV_FREE;
		env_free_list = envs + i;
	}
	// Per-CPU part of the initialization
	env_init_percpu();
  800420799c:	48 b8 ab 79 20 04 80 	movabs $0x80042079ab,%rax
  80042079a3:	00 00 00 
  80042079a6:	ff d0                	callq  *%rax
}
  80042079a8:	90                   	nop
  80042079a9:	c9                   	leaveq 
  80042079aa:	c3                   	retq   

00000080042079ab <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  80042079ab:	55                   	push   %rbp
  80042079ac:	48 89 e5             	mov    %rsp,%rbp
  80042079af:	53                   	push   %rbx
  80042079b0:	48 83 ec 10          	sub    $0x10,%rsp
  80042079b4:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  80042079bb:	00 00 00 
  80042079be:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  80042079c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042079c6:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  80042079c9:	b8 23 00 00 00       	mov    $0x23,%eax
  80042079ce:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  80042079d0:	b8 23 00 00 00       	mov    $0x23,%eax
  80042079d5:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  80042079d7:	b8 10 00 00 00       	mov    $0x10,%eax
  80042079dc:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  80042079de:	b8 10 00 00 00       	mov    $0x10,%eax
  80042079e3:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  80042079e5:	b8 10 00 00 00       	mov    $0x10,%eax
  80042079ea:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  80042079ec:	b8 08 00 00 00       	mov    $0x8,%eax
  80042079f1:	89 c3                	mov    %eax,%ebx
  80042079f3:	53                   	push   %rbx
  80042079f4:	48 b8 01 7a 20 04 80 	movabs $0x8004207a01,%rax
  80042079fb:	00 00 00 
  80042079fe:	50                   	push   %rax
  80042079ff:	48 cb                	lretq  
  8004207a01:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  8004207a07:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8004207a0b:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  8004207a0e:	90                   	nop
  8004207a0f:	48 83 c4 10          	add    $0x10,%rsp
  8004207a13:	5b                   	pop    %rbx
  8004207a14:	5d                   	pop    %rbp
  8004207a15:	c3                   	retq   

0000008004207a16 <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004207a16:	55                   	push   %rbp
  8004207a17:	48 89 e5             	mov    %rsp,%rbp
  8004207a1a:	48 83 ec 20          	sub    $0x20,%rsp
  8004207a1e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  8004207a22:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207a29:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  8004207a2a:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207a2f:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004207a36:	00 00 00 
  8004207a39:	ff d0                	callq  *%rax
  8004207a3b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207a3f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004207a44:	75 0a                	jne    8004207a50 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004207a46:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207a4b:	e9 9e 00 00 00       	jmpq   8004207aee <env_setup_vm+0xd8>
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.
	
	p->pp_ref++;
  8004207a50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a54:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207a58:	8d 50 01             	lea    0x1(%rax),%edx
  8004207a5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a5f:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e = page2kva(p);
  8004207a63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a67:	48 89 c7             	mov    %rax,%rdi
  8004207a6a:	48 b8 73 76 20 04 80 	movabs $0x8004207673,%rax
  8004207a71:	00 00 00 
  8004207a74:	ff d0                	callq  *%rax
  8004207a76:	48 89 c2             	mov    %rax,%rdx
  8004207a79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207a7d:	48 89 90 e0 00 00 00 	mov    %rdx,0xe0(%rax)
	e->env_cr3 = page2pa(p);
  8004207a84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a88:	48 89 c7             	mov    %rax,%rdi
  8004207a8b:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  8004207a92:	00 00 00 
  8004207a95:	ff d0                	callq  *%rax
  8004207a97:	48 89 c2             	mov    %rax,%rdx
  8004207a9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207a9e:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)

	// Everything from 0 to UTOP mark as zero
	e->env_pml4e[1] = boot_pml4e[1];
  8004207aa5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207aa9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207ab0:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004207ab4:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  8004207abb:	00 00 00 
  8004207abe:	48 8b 00             	mov    (%rax),%rax
  8004207ac1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207ac5:	48 89 02             	mov    %rax,(%rdx)

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  8004207ac8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207acc:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207ad3:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8004207ad7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207adb:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207ae2:	48 83 c8 05          	or     $0x5,%rax
  8004207ae6:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  8004207ae9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207aee:	c9                   	leaveq 
  8004207aef:	c3                   	retq   

0000008004207af0 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004207af0:	55                   	push   %rbp
  8004207af1:	48 89 e5             	mov    %rsp,%rbp
  8004207af4:	53                   	push   %rbx
  8004207af5:	48 83 ec 38          	sub    $0x38,%rsp
  8004207af9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004207afd:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  8004207b00:	48 b8 58 22 36 04 80 	movabs $0x8004362258,%rax
  8004207b07:	00 00 00 
  8004207b0a:	48 8b 00             	mov    (%rax),%rax
  8004207b0d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004207b11:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004207b16:	75 0a                	jne    8004207b22 <env_alloc+0x32>
		return -E_NO_FREE_ENV;
  8004207b18:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004207b1d:	e9 25 02 00 00       	jmpq   8004207d47 <env_alloc+0x257>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  8004207b22:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207b26:	48 89 c7             	mov    %rax,%rdi
  8004207b29:	48 b8 16 7a 20 04 80 	movabs $0x8004207a16,%rax
  8004207b30:	00 00 00 
  8004207b33:	ff d0                	callq  *%rax
  8004207b35:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004207b38:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207b3c:	79 08                	jns    8004207b46 <env_alloc+0x56>
		return r;
  8004207b3e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207b41:	e9 01 02 00 00       	jmpq   8004207d47 <env_alloc+0x257>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004207b46:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207b4a:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207b50:	05 00 10 00 00       	add    $0x1000,%eax
  8004207b55:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004207b5a:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004207b5d:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004207b61:	7f 07                	jg     8004207b6a <env_alloc+0x7a>
		generation = 1 << ENVGENSHIFT;
  8004207b63:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%rbp)
	e->env_id = generation | (e - envs);
  8004207b6a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004207b6e:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  8004207b75:	00 00 00 
  8004207b78:	48 8b 00             	mov    (%rax),%rax
  8004207b7b:	48 29 c2             	sub    %rax,%rdx
  8004207b7e:	48 89 d0             	mov    %rdx,%rax
  8004207b81:	48 c1 f8 05          	sar    $0x5,%rax
  8004207b85:	48 89 c2             	mov    %rax,%rdx
  8004207b88:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  8004207b8f:	e3 38 8e 
  8004207b92:	48 0f af c2          	imul   %rdx,%rax
  8004207b96:	0b 45 ec             	or     -0x14(%rbp),%eax
  8004207b99:	89 c2                	mov    %eax,%edx
  8004207b9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207b9f:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004207ba5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207ba9:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004207bac:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004207bb2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207bb6:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004207bbd:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004207bc0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207bc4:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004207bcb:	00 00 00 
	e->env_runs = 0;
  8004207bce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207bd2:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004207bd9:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004207bdc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207be0:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004207be5:	be 00 00 00 00       	mov    $0x0,%esi
  8004207bea:	48 89 c7             	mov    %rax,%rdi
  8004207bed:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004207bf4:	00 00 00 
  8004207bf7:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004207bf9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207bfd:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004207c04:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004207c06:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c0a:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  8004207c10:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c14:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004207c1b:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004207c1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c21:	bb 00 e0 7f ef       	mov    $0xef7fe000,%ebx
  8004207c26:	48 89 98 b0 00 00 00 	mov    %rbx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004207c2d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c31:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004207c38:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.

	e->env_tf.tf_eflags = e->env_tf.tf_eflags | FL_IF;
  8004207c3a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c3e:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004207c45:	80 cc 02             	or     $0x2,%ah
  8004207c48:	48 89 c2             	mov    %rax,%rdx
  8004207c4b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c4f:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)

	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004207c56:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c5a:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004207c61:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004207c65:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c69:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004207c70:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c74:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004207c7b:	48 b8 58 22 36 04 80 	movabs $0x8004362258,%rax
  8004207c82:	00 00 00 
  8004207c85:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004207c88:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207c8c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004207c90:	48 89 10             	mov    %rdx,(%rax)

	cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004207c93:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207c97:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  8004207c9d:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004207ca4:	00 00 00 
  8004207ca7:	ff d0                	callq  *%rax
  8004207ca9:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  8004207cb0:	00 00 00 
  8004207cb3:	48 98                	cltq   
  8004207cb5:	48 89 c2             	mov    %rax,%rdx
  8004207cb8:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004207cbf:	00 
  8004207cc0:	48 89 c2             	mov    %rax,%rdx
  8004207cc3:	48 89 d0             	mov    %rdx,%rax
  8004207cc6:	48 c1 e0 04          	shl    $0x4,%rax
  8004207cca:	48 29 d0             	sub    %rdx,%rax
  8004207ccd:	48 01 c8             	add    %rcx,%rax
  8004207cd0:	48 83 c0 08          	add    $0x8,%rax
  8004207cd4:	48 8b 00             	mov    (%rax),%rax
  8004207cd7:	48 85 c0             	test   %rax,%rax
  8004207cda:	74 42                	je     8004207d1e <env_alloc+0x22e>
  8004207cdc:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004207ce3:	00 00 00 
  8004207ce6:	ff d0                	callq  *%rax
  8004207ce8:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  8004207cef:	00 00 00 
  8004207cf2:	48 98                	cltq   
  8004207cf4:	48 89 c2             	mov    %rax,%rdx
  8004207cf7:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004207cfe:	00 
  8004207cff:	48 89 c2             	mov    %rax,%rdx
  8004207d02:	48 89 d0             	mov    %rdx,%rax
  8004207d05:	48 c1 e0 04          	shl    $0x4,%rax
  8004207d09:	48 29 d0             	sub    %rdx,%rax
  8004207d0c:	48 01 c8             	add    %rcx,%rax
  8004207d0f:	48 83 c0 08          	add    $0x8,%rax
  8004207d13:	48 8b 00             	mov    (%rax),%rax
  8004207d16:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207d1c:	eb 05                	jmp    8004207d23 <env_alloc+0x233>
  8004207d1e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d23:	89 da                	mov    %ebx,%edx
  8004207d25:	89 c6                	mov    %eax,%esi
  8004207d27:	48 bf 0b 75 21 04 80 	movabs $0x800421750b,%rdi
  8004207d2e:	00 00 00 
  8004207d31:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207d36:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  8004207d3d:	00 00 00 
  8004207d40:	ff d1                	callq  *%rcx
	return 0;
  8004207d42:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207d47:	48 83 c4 38          	add    $0x38,%rsp
  8004207d4b:	5b                   	pop    %rbx
  8004207d4c:	5d                   	pop    %rbp
  8004207d4d:	c3                   	retq   

0000008004207d4e <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  8004207d4e:	55                   	push   %rbp
  8004207d4f:	48 89 e5             	mov    %rsp,%rbp
  8004207d52:	48 83 ec 60          	sub    $0x60,%rsp
  8004207d56:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004207d5a:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004207d5e:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)

	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	void *end = ROUNDUP(va + len, PGSIZE);
  8004207d62:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004207d69:	00 
  8004207d6a:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004207d6e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004207d72:	48 01 d0             	add    %rdx,%rax
  8004207d75:	48 89 c2             	mov    %rax,%rdx
  8004207d78:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d7c:	48 01 d0             	add    %rdx,%rax
  8004207d7f:	48 83 e8 01          	sub    $0x1,%rax
  8004207d83:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004207d87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207d8b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207d90:	48 f7 75 f0          	divq   -0x10(%rbp)
  8004207d94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207d98:	48 29 d0             	sub    %rdx,%rax
  8004207d9b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	void *start = ROUNDDOWN(va, PGSIZE);	
  8004207d9f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004207da3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004207da7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207dab:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207db1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for(; start < end; start += PGSIZE) {
  8004207db5:	e9 bb 00 00 00       	jmpq   8004207e75 <region_alloc+0x127>
		struct PageInfo *pp = page_alloc(ALLOC_ZERO);
  8004207dba:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207dbf:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  8004207dc6:	00 00 00 
  8004207dc9:	ff d0                	callq  *%rax
  8004207dcb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(pp) {
  8004207dcf:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004207dd4:	74 6d                	je     8004207e43 <region_alloc+0xf5>
			pp->pp_ref++;
  8004207dd6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207dda:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207dde:	8d 50 01             	lea    0x1(%rax),%edx
  8004207de1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207de5:	66 89 50 08          	mov    %dx,0x8(%rax)
			int flag = page_insert(e->env_pml4e, pp, start, PTE_U | PTE_W | PTE_P);
  8004207de9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207ded:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207df4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207df8:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004207dfc:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004207e01:	48 89 c7             	mov    %rax,%rdi
  8004207e04:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  8004207e0b:	00 00 00 
  8004207e0e:	ff d0                	callq  *%rax
  8004207e10:	89 45 cc             	mov    %eax,-0x34(%rbp)
			if(flag) panic("Page insertion failed! ");
  8004207e13:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004207e17:	74 54                	je     8004207e6d <region_alloc+0x11f>
  8004207e19:	48 ba 20 75 21 04 80 	movabs $0x8004217520,%rdx
  8004207e20:	00 00 00 
  8004207e23:	be 37 01 00 00       	mov    $0x137,%esi
  8004207e28:	48 bf 38 75 21 04 80 	movabs $0x8004217538,%rdi
  8004207e2f:	00 00 00 
  8004207e32:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e37:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  8004207e3e:	00 00 00 
  8004207e41:	ff d1                	callq  *%rcx
		} else panic("Page Allocation failed!");
  8004207e43:	48 ba 43 75 21 04 80 	movabs $0x8004217543,%rdx
  8004207e4a:	00 00 00 
  8004207e4d:	be 38 01 00 00       	mov    $0x138,%esi
  8004207e52:	48 bf 38 75 21 04 80 	movabs $0x8004217538,%rdi
  8004207e59:	00 00 00 
  8004207e5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e61:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  8004207e68:	00 00 00 
  8004207e6b:	ff d1                	callq  *%rcx
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	void *end = ROUNDUP(va + len, PGSIZE);
	void *start = ROUNDDOWN(va, PGSIZE);	
	for(; start < end; start += PGSIZE) {
  8004207e6d:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004207e74:	00 
  8004207e75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207e79:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004207e7d:	0f 82 37 ff ff ff    	jb     8004207dba <region_alloc+0x6c>
			pp->pp_ref++;
			int flag = page_insert(e->env_pml4e, pp, start, PTE_U | PTE_W | PTE_P);
			if(flag) panic("Page insertion failed! ");
		} else panic("Page Allocation failed!");
	}
}
  8004207e83:	90                   	nop
  8004207e84:	c9                   	leaveq 
  8004207e85:	c3                   	retq   

0000008004207e86 <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004207e86:	55                   	push   %rbp
  8004207e87:	48 89 e5             	mov    %rsp,%rbp
  8004207e8a:	48 83 ec 40          	sub    $0x40,%rsp
  8004207e8e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004207e92:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
	// Now map one page for the program's initial stack
	// at virtual address USTACKTOP - PGSIZE.
	//struct Elf *ELFHDR = (struct Elf *)binary;
	//struct Proghdr *ph, *eph;	
	
	struct Elf *temp = (struct Elf *)binary;
  8004207e96:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207e9a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	struct Proghdr *ph, *eph;
	if(temp->e_magic != ELF_MAGIC)
  8004207e9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ea2:	8b 00                	mov    (%rax),%eax
  8004207ea4:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004207ea9:	74 2a                	je     8004207ed5 <load_icode+0x4f>
		panic("Elf loading failed");
  8004207eab:	48 ba 5b 75 21 04 80 	movabs $0x800421755b,%rdx
  8004207eb2:	00 00 00 
  8004207eb5:	be 7b 01 00 00       	mov    $0x17b,%esi
  8004207eba:	48 bf 38 75 21 04 80 	movabs $0x8004217538,%rdi
  8004207ec1:	00 00 00 
  8004207ec4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ec9:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  8004207ed0:	00 00 00 
  8004207ed3:	ff d1                	callq  *%rcx

	ph = (struct Proghdr *) ((uint8_t*)temp + temp->e_phoff);
  8004207ed5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ed9:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207edd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ee1:	48 01 d0             	add    %rdx,%rax
  8004207ee4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	eph = ph + temp->e_phnum;
  8004207ee8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207eec:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004207ef0:	0f b7 c0             	movzwl %ax,%eax
  8004207ef3:	48 c1 e0 03          	shl    $0x3,%rax
  8004207ef7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207efe:	00 
  8004207eff:	48 29 c2             	sub    %rax,%rdx
  8004207f02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f06:	48 01 d0             	add    %rdx,%rax
  8004207f09:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	lcr3(e->env_cr3);
  8004207f0d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f11:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207f18:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004207f1c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207f20:	0f 22 d8             	mov    %rax,%cr3
	
	for(; ph < eph; ph++) if(ph->p_type == ELF_PROG_LOAD){
  8004207f23:	e9 ab 00 00 00       	jmpq   8004207fd3 <load_icode+0x14d>
  8004207f28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f2c:	8b 00                	mov    (%rax),%eax
  8004207f2e:	83 f8 01             	cmp    $0x1,%eax
  8004207f31:	0f 85 97 00 00 00    	jne    8004207fce <load_icode+0x148>
		region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  8004207f37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f3b:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207f3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f43:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207f47:	48 89 c1             	mov    %rax,%rcx
  8004207f4a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f4e:	48 89 ce             	mov    %rcx,%rsi
  8004207f51:	48 89 c7             	mov    %rax,%rdi
  8004207f54:	48 b8 4e 7d 20 04 80 	movabs $0x8004207d4e,%rax
  8004207f5b:	00 00 00 
  8004207f5e:	ff d0                	callq  *%rax
		memcpy((void*)ph->p_va,binary + ph->p_offset,ph->p_filesz);
  8004207f60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f64:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004207f68:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207f6c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004207f70:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004207f74:	48 01 d1             	add    %rdx,%rcx
  8004207f77:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207f7b:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004207f7f:	48 89 d7             	mov    %rdx,%rdi
  8004207f82:	48 89 c2             	mov    %rax,%rdx
  8004207f85:	48 89 ce             	mov    %rcx,%rsi
  8004207f88:	48 b8 19 ee 20 04 80 	movabs $0x800420ee19,%rax
  8004207f8f:	00 00 00 
  8004207f92:	ff d0                	callq  *%rax
		memset((void*)ph->p_va+ph->p_filesz, 0, ph->p_memsz - ph->p_filesz);
  8004207f94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f98:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207f9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fa0:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004207fa4:	48 29 c2             	sub    %rax,%rdx
  8004207fa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fab:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004207faf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fb3:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207fb7:	48 01 c8             	add    %rcx,%rax
  8004207fba:	be 00 00 00 00       	mov    $0x0,%esi
  8004207fbf:	48 89 c7             	mov    %rax,%rdi
  8004207fc2:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004207fc9:	00 00 00 
  8004207fcc:	ff d0                	callq  *%rax

	ph = (struct Proghdr *) ((uint8_t*)temp + temp->e_phoff);
	eph = ph + temp->e_phnum;
	lcr3(e->env_cr3);
	
	for(; ph < eph; ph++) if(ph->p_type == ELF_PROG_LOAD){
  8004207fce:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004207fd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207fd7:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207fdb:	0f 82 47 ff ff ff    	jb     8004207f28 <load_icode+0xa2>
		region_alloc(e, (void *)ph->p_va, ph->p_memsz);
		memcpy((void*)ph->p_va,binary + ph->p_offset,ph->p_filesz);
		memset((void*)ph->p_va+ph->p_filesz, 0, ph->p_memsz - ph->p_filesz);

	}
	lcr3(boot_cr3);
  8004207fe1:	48 b8 20 37 36 04 80 	movabs $0x8004363720,%rax
  8004207fe8:	00 00 00 
  8004207feb:	48 8b 00             	mov    (%rax),%rax
  8004207fee:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004207ff2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207ff6:	0f 22 d8             	mov    %rax,%cr3
	e->env_tf.tf_rip = temp->e_entry;
  8004207ff9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ffd:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004208001:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208005:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	
	region_alloc(e, (void *)USTACKTOP-PGSIZE, PGSIZE);
  800420800c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208010:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208015:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  800420801a:	48 89 c7             	mov    %rax,%rdi
  800420801d:	48 b8 4e 7d 20 04 80 	movabs $0x8004207d4e,%rax
  8004208024:	00 00 00 
  8004208027:	ff d0                	callq  *%rax

	e->elf = binary;
  8004208029:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420802d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004208031:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
	return;
  8004208038:	90                   	nop
}
  8004208039:	c9                   	leaveq 
  800420803a:	c3                   	retq   

000000800420803b <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  800420803b:	55                   	push   %rbp
  800420803c:	48 89 e5             	mov    %rsp,%rbp
  800420803f:	48 83 ec 20          	sub    $0x20,%rsp
  8004208043:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004208047:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 3: Your code here.
	struct Env *e = NULL;
  800420804a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004208051:	00 
	int result = env_alloc(&e, 0);
  8004208052:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004208056:	be 00 00 00 00       	mov    $0x0,%esi
  800420805b:	48 89 c7             	mov    %rax,%rdi
  800420805e:	48 b8 f0 7a 20 04 80 	movabs $0x8004207af0,%rax
  8004208065:	00 00 00 
  8004208068:	ff d0                	callq  *%rax
  800420806a:	89 45 fc             	mov    %eax,-0x4(%rbp)

    	if (result == -E_NO_FREE_ENV){
  800420806d:	83 7d fc fb          	cmpl   $0xfffffffb,-0x4(%rbp)
  8004208071:	75 2a                	jne    800420809d <env_create+0x62>
        	panic("no free environment");
  8004208073:	48 ba 6e 75 21 04 80 	movabs $0x800421756e,%rdx
  800420807a:	00 00 00 
  800420807d:	be 9f 01 00 00       	mov    $0x19f,%esi
  8004208082:	48 bf 38 75 21 04 80 	movabs $0x8004217538,%rdi
  8004208089:	00 00 00 
  800420808c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208091:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  8004208098:	00 00 00 
  800420809b:	ff d1                	callq  *%rcx
	}else if(result == -E_NO_MEM){
  800420809d:	83 7d fc fc          	cmpl   $0xfffffffc,-0x4(%rbp)
  80042080a1:	75 2a                	jne    80042080cd <env_create+0x92>
		panic("no free mem");
  80042080a3:	48 ba 82 75 21 04 80 	movabs $0x8004217582,%rdx
  80042080aa:	00 00 00 
  80042080ad:	be a1 01 00 00       	mov    $0x1a1,%esi
  80042080b2:	48 bf 38 75 21 04 80 	movabs $0x8004217538,%rdi
  80042080b9:	00 00 00 
  80042080bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042080c1:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  80042080c8:	00 00 00 
  80042080cb:	ff d1                	callq  *%rcx
	}

	load_icode(e, binary);
  80042080cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042080d1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042080d5:	48 89 d6             	mov    %rdx,%rsi
  80042080d8:	48 89 c7             	mov    %rax,%rdi
  80042080db:	48 b8 86 7e 20 04 80 	movabs $0x8004207e86,%rax
  80042080e2:	00 00 00 
  80042080e5:	ff d0                	callq  *%rax
	e->env_type = type;
  80042080e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042080eb:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042080ee:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	e->env_parent_id=0;
  80042080f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042080f8:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  80042080ff:	00 00 00 

}
  8004208102:	90                   	nop
  8004208103:	c9                   	leaveq 
  8004208104:	c3                   	retq   

0000008004208105 <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  8004208105:	55                   	push   %rbp
  8004208106:	48 89 e5             	mov    %rsp,%rbp
  8004208109:	53                   	push   %rbx
  800420810a:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8004208111:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)


	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004208118:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420811f:	00 00 00 
  8004208122:	ff d0                	callq  *%rax
  8004208124:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420812b:	00 00 00 
  800420812e:	48 98                	cltq   
  8004208130:	48 89 c2             	mov    %rax,%rdx
  8004208133:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420813a:	00 
  800420813b:	48 89 c2             	mov    %rax,%rdx
  800420813e:	48 89 d0             	mov    %rdx,%rax
  8004208141:	48 c1 e0 04          	shl    $0x4,%rax
  8004208145:	48 29 d0             	sub    %rdx,%rax
  8004208148:	48 01 c8             	add    %rcx,%rax
  800420814b:	48 83 c0 08          	add    $0x8,%rax
  800420814f:	48 8b 00             	mov    (%rax),%rax
  8004208152:	48 3b 85 68 ff ff ff 	cmp    -0x98(%rbp),%rax
  8004208159:	75 1e                	jne    8004208179 <env_free+0x74>
		lcr3(boot_cr3);
  800420815b:	48 b8 20 37 36 04 80 	movabs $0x8004363720,%rax
  8004208162:	00 00 00 
  8004208165:	48 8b 00             	mov    (%rax),%rax
  8004208168:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800420816f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208176:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  8004208179:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208180:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  8004208186:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420818d:	00 00 00 
  8004208190:	ff d0                	callq  *%rax
  8004208192:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  8004208199:	00 00 00 
  800420819c:	48 98                	cltq   
  800420819e:	48 89 c2             	mov    %rax,%rdx
  80042081a1:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  80042081a8:	00 
  80042081a9:	48 89 c2             	mov    %rax,%rdx
  80042081ac:	48 89 d0             	mov    %rdx,%rax
  80042081af:	48 c1 e0 04          	shl    $0x4,%rax
  80042081b3:	48 29 d0             	sub    %rdx,%rax
  80042081b6:	48 01 c8             	add    %rcx,%rax
  80042081b9:	48 83 c0 08          	add    $0x8,%rax
  80042081bd:	48 8b 00             	mov    (%rax),%rax
  80042081c0:	48 85 c0             	test   %rax,%rax
  80042081c3:	74 42                	je     8004208207 <env_free+0x102>
  80042081c5:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  80042081cc:	00 00 00 
  80042081cf:	ff d0                	callq  *%rax
  80042081d1:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  80042081d8:	00 00 00 
  80042081db:	48 98                	cltq   
  80042081dd:	48 89 c2             	mov    %rax,%rdx
  80042081e0:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  80042081e7:	00 
  80042081e8:	48 89 c2             	mov    %rax,%rdx
  80042081eb:	48 89 d0             	mov    %rdx,%rax
  80042081ee:	48 c1 e0 04          	shl    $0x4,%rax
  80042081f2:	48 29 d0             	sub    %rdx,%rax
  80042081f5:	48 01 c8             	add    %rcx,%rax
  80042081f8:	48 83 c0 08          	add    $0x8,%rax
  80042081fc:	48 8b 00             	mov    (%rax),%rax
  80042081ff:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208205:	eb 05                	jmp    800420820c <env_free+0x107>
  8004208207:	b8 00 00 00 00       	mov    $0x0,%eax
  800420820c:	89 da                	mov    %ebx,%edx
  800420820e:	89 c6                	mov    %eax,%esi
  8004208210:	48 bf 8e 75 21 04 80 	movabs $0x800421758e,%rdi
  8004208217:	00 00 00 
  800420821a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420821f:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  8004208226:	00 00 00 
  8004208229:	ff d1                	callq  *%rcx

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  800420822b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004208232:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208239:	48 8b 00             	mov    (%rax),%rax
  800420823c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208242:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004208246:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420824a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420824e:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004208251:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208254:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  800420825b:	00 00 00 
  800420825e:	48 8b 00             	mov    (%rax),%rax
  8004208261:	48 39 c2             	cmp    %rax,%rdx
  8004208264:	72 32                	jb     8004208298 <env_free+0x193>
  8004208266:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420826a:	48 89 c1             	mov    %rax,%rcx
  800420826d:	48 ba e8 74 21 04 80 	movabs $0x80042174e8,%rdx
  8004208274:	00 00 00 
  8004208277:	be bf 01 00 00       	mov    $0x1bf,%esi
  800420827c:	48 bf 38 75 21 04 80 	movabs $0x8004217538,%rdi
  8004208283:	00 00 00 
  8004208286:	b8 00 00 00 00       	mov    $0x0,%eax
  800420828b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004208292:	00 00 00 
  8004208295:	41 ff d0             	callq  *%r8
  8004208298:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420829f:	00 00 00 
  80042082a2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042082a6:	48 01 d0             	add    %rdx,%rax
  80042082a9:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  80042082ad:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80042082b4:	00 
  80042082b5:	e9 af 02 00 00       	jmpq   8004208569 <env_free+0x464>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  80042082ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042082be:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042082c5:	00 
  80042082c6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042082ca:	48 01 d0             	add    %rdx,%rax
  80042082cd:	48 8b 00             	mov    (%rax),%rax
  80042082d0:	83 e0 01             	and    $0x1,%eax
  80042082d3:	48 85 c0             	test   %rax,%rax
  80042082d6:	0f 84 87 02 00 00    	je     8004208563 <env_free+0x45e>
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  80042082dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042082e0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042082e7:	00 
  80042082e8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042082ec:	48 01 d0             	add    %rdx,%rax
  80042082ef:	48 8b 00             	mov    (%rax),%rax
  80042082f2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042082f8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  80042082fc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208300:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208304:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004208307:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  800420830a:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004208311:	00 00 00 
  8004208314:	48 8b 00             	mov    (%rax),%rax
  8004208317:	48 39 c2             	cmp    %rax,%rdx
  800420831a:	72 32                	jb     800420834e <env_free+0x249>
  800420831c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208320:	48 89 c1             	mov    %rax,%rcx
  8004208323:	48 ba e8 74 21 04 80 	movabs $0x80042174e8,%rdx
  800420832a:	00 00 00 
  800420832d:	be c7 01 00 00       	mov    $0x1c7,%esi
  8004208332:	48 bf 38 75 21 04 80 	movabs $0x8004217538,%rdi
  8004208339:	00 00 00 
  800420833c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208341:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004208348:	00 00 00 
  800420834b:	41 ff d0             	callq  *%r8
  800420834e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208355:	00 00 00 
  8004208358:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420835c:	48 01 d0             	add    %rdx,%rax
  800420835f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  8004208363:	48 83 7d d8 03       	cmpq   $0x3,-0x28(%rbp)
  8004208368:	75 07                	jne    8004208371 <env_free+0x26c>
  800420836a:	b8 04 00 00 00       	mov    $0x4,%eax
  800420836f:	eb 05                	jmp    8004208376 <env_free+0x271>
  8004208371:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004208376:	89 45 a4             	mov    %eax,-0x5c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208379:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208380:	00 
  8004208381:	e9 70 01 00 00       	jmpq   80042084f6 <env_free+0x3f1>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  8004208386:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420838a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208391:	00 
  8004208392:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208396:	48 01 d0             	add    %rdx,%rax
  8004208399:	48 8b 00             	mov    (%rax),%rax
  800420839c:	83 e0 01             	and    $0x1,%eax
  800420839f:	48 85 c0             	test   %rax,%rax
  80042083a2:	0f 84 48 01 00 00    	je     80042084f0 <env_free+0x3eb>
				continue;
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  80042083a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042083ac:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042083b3:	00 
  80042083b4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042083b8:	48 01 d0             	add    %rdx,%rax
  80042083bb:	48 8b 00             	mov    (%rax),%rax
  80042083be:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042083c4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
			pt = (pte_t*) KADDR(pa);
  80042083c8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042083cc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042083d0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042083d4:	48 c1 e8 0c          	shr    $0xc,%rax
  80042083d8:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042083db:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042083de:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042083e5:	00 00 00 
  80042083e8:	48 8b 00             	mov    (%rax),%rax
  80042083eb:	48 39 c2             	cmp    %rax,%rdx
  80042083ee:	72 32                	jb     8004208422 <env_free+0x31d>
  80042083f0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042083f4:	48 89 c1             	mov    %rax,%rcx
  80042083f7:	48 ba e8 74 21 04 80 	movabs $0x80042174e8,%rdx
  80042083fe:	00 00 00 
  8004208401:	be d1 01 00 00       	mov    $0x1d1,%esi
  8004208406:	48 bf 38 75 21 04 80 	movabs $0x8004217538,%rdi
  800420840d:	00 00 00 
  8004208410:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208415:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420841c:	00 00 00 
  800420841f:	41 ff d0             	callq  *%r8
  8004208422:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208429:	00 00 00 
  800420842c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208430:	48 01 d0             	add    %rdx,%rax
  8004208433:	48 89 45 80          	mov    %rax,-0x80(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208437:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420843e:	00 
  800420843f:	eb 67                	jmp    80042084a8 <env_free+0x3a3>
				if (pt[pteno] & PTE_P){
  8004208441:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208445:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420844c:	00 
  800420844d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004208451:	48 01 d0             	add    %rdx,%rax
  8004208454:	48 8b 00             	mov    (%rax),%rax
  8004208457:	83 e0 01             	and    $0x1,%eax
  800420845a:	48 85 c0             	test   %rax,%rax
  800420845d:	74 44                	je     80042084a3 <env_free+0x39e>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  800420845f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208463:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004208467:	48 89 c2             	mov    %rax,%rdx
  800420846a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420846e:	48 c1 e0 15          	shl    $0x15,%rax
  8004208472:	48 09 c2             	or     %rax,%rdx
  8004208475:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208479:	48 c1 e0 0c          	shl    $0xc,%rax
  800420847d:	48 09 d0             	or     %rdx,%rax
  8004208480:	48 89 c2             	mov    %rax,%rdx
  8004208483:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420848a:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208491:	48 89 d6             	mov    %rdx,%rsi
  8004208494:	48 89 c7             	mov    %rax,%rdi
  8004208497:	48 b8 49 36 20 04 80 	movabs $0x8004203649,%rax
  800420849e:	00 00 00 
  80042084a1:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042084a3:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  80042084a8:	48 81 7d e0 fe 01 00 	cmpq   $0x1fe,-0x20(%rbp)
  80042084af:	00 
  80042084b0:	76 8f                	jbe    8004208441 <env_free+0x33c>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  80042084b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042084b6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042084bd:	00 
  80042084be:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042084c2:	48 01 d0             	add    %rdx,%rax
  80042084c5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  80042084cc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042084d0:	48 89 c7             	mov    %rax,%rdi
  80042084d3:	48 b8 02 76 20 04 80 	movabs $0x8004207602,%rax
  80042084da:	00 00 00 
  80042084dd:	ff d0                	callq  *%rax
  80042084df:	48 89 c7             	mov    %rax,%rdi
  80042084e2:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  80042084e9:	00 00 00 
  80042084ec:	ff d0                	callq  *%rax
  80042084ee:	eb 01                	jmp    80042084f1 <env_free+0x3ec>
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
				continue;
  80042084f0:	90                   	nop
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  80042084f1:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042084f6:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  80042084f9:	48 98                	cltq   
  80042084fb:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042084ff:	0f 87 81 fe ff ff    	ja     8004208386 <env_free+0x281>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004208505:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208509:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208510:	00 
  8004208511:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004208515:	48 01 d0             	add    %rdx,%rax
  8004208518:	48 8b 00             	mov    (%rax),%rax
  800420851b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208521:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		env_pdpe[pdpe_index] = 0;
  8004208525:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208529:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208530:	00 
  8004208531:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004208535:	48 01 d0             	add    %rdx,%rax
  8004208538:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  800420853f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004208543:	48 89 c7             	mov    %rax,%rdi
  8004208546:	48 b8 02 76 20 04 80 	movabs $0x8004207602,%rax
  800420854d:	00 00 00 
  8004208550:	ff d0                	callq  *%rax
  8004208552:	48 89 c7             	mov    %rax,%rdi
  8004208555:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  800420855c:	00 00 00 
  800420855f:	ff d0                	callq  *%rax
  8004208561:	eb 01                	jmp    8004208564 <env_free+0x45f>
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
  8004208563:	90                   	nop
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208564:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004208569:	48 83 7d d8 03       	cmpq   $0x3,-0x28(%rbp)
  800420856e:	0f 86 46 fd ff ff    	jbe    80042082ba <env_free+0x1b5>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004208574:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420857b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208582:	48 8b 00             	mov    (%rax),%rax
  8004208585:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420858b:	48 89 c7             	mov    %rax,%rdi
  800420858e:	48 b8 02 76 20 04 80 	movabs $0x8004207602,%rax
  8004208595:	00 00 00 
  8004208598:	ff d0                	callq  *%rax
  800420859a:	48 89 c7             	mov    %rax,%rdi
  800420859d:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  80042085a4:	00 00 00 
  80042085a7:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  80042085a9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042085b0:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042085b7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  80042085be:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042085c5:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042085cc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	e->env_pml4e = 0;
  80042085d0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042085d7:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  80042085de:	00 00 00 00 
	e->env_cr3 = 0;
  80042085e2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042085e9:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  80042085f0:	00 00 00 00 
	page_decref(pa2page(pa));
  80042085f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042085f8:	48 89 c7             	mov    %rax,%rdi
  80042085fb:	48 b8 02 76 20 04 80 	movabs $0x8004207602,%rax
  8004208602:	00 00 00 
  8004208605:	ff d0                	callq  *%rax
  8004208607:	48 89 c7             	mov    %rax,%rdi
  800420860a:	48 b8 6b 2c 20 04 80 	movabs $0x8004202c6b,%rax
  8004208611:	00 00 00 
  8004208614:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004208616:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420861d:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208624:	00 00 00 
	e->env_link = env_free_list;
  8004208627:	48 b8 58 22 36 04 80 	movabs $0x8004362258,%rax
  800420862e:	00 00 00 
  8004208631:	48 8b 10             	mov    (%rax),%rdx
  8004208634:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420863b:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004208642:	48 b8 58 22 36 04 80 	movabs $0x8004362258,%rax
  8004208649:	00 00 00 
  800420864c:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004208653:	48 89 10             	mov    %rdx,(%rax)
}
  8004208656:	90                   	nop
  8004208657:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  800420865e:	5b                   	pop    %rbx
  800420865f:	5d                   	pop    %rbp
  8004208660:	c3                   	retq   

0000008004208661 <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  8004208661:	55                   	push   %rbp
  8004208662:	48 89 e5             	mov    %rsp,%rbp
  8004208665:	48 83 ec 10          	sub    $0x10,%rsp
  8004208669:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  800420866d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208671:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208677:	83 f8 03             	cmp    $0x3,%eax
  800420867a:	75 53                	jne    80042086cf <env_destroy+0x6e>
  800420867c:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004208683:	00 00 00 
  8004208686:	ff d0                	callq  *%rax
  8004208688:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420868f:	00 00 00 
  8004208692:	48 98                	cltq   
  8004208694:	48 89 c2             	mov    %rax,%rdx
  8004208697:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420869e:	00 
  800420869f:	48 89 c2             	mov    %rax,%rdx
  80042086a2:	48 89 d0             	mov    %rdx,%rax
  80042086a5:	48 c1 e0 04          	shl    $0x4,%rax
  80042086a9:	48 29 d0             	sub    %rdx,%rax
  80042086ac:	48 01 c8             	add    %rcx,%rax
  80042086af:	48 83 c0 08          	add    $0x8,%rax
  80042086b3:	48 8b 00             	mov    (%rax),%rax
  80042086b6:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042086ba:	74 13                	je     80042086cf <env_destroy+0x6e>
		e->env_status = ENV_DYING;
  80042086bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042086c0:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  80042086c7:	00 00 00 
		return;
  80042086ca:	e9 9d 00 00 00       	jmpq   800420876c <env_destroy+0x10b>
	}

	env_free(e);
  80042086cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042086d3:	48 89 c7             	mov    %rax,%rdi
  80042086d6:	48 b8 05 81 20 04 80 	movabs $0x8004208105,%rax
  80042086dd:	00 00 00 
  80042086e0:	ff d0                	callq  *%rax
	if (curenv == e) {
  80042086e2:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  80042086e9:	00 00 00 
  80042086ec:	ff d0                	callq  *%rax
  80042086ee:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  80042086f5:	00 00 00 
  80042086f8:	48 98                	cltq   
  80042086fa:	48 89 c2             	mov    %rax,%rdx
  80042086fd:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004208704:	00 
  8004208705:	48 89 c2             	mov    %rax,%rdx
  8004208708:	48 89 d0             	mov    %rdx,%rax
  800420870b:	48 c1 e0 04          	shl    $0x4,%rax
  800420870f:	48 29 d0             	sub    %rdx,%rax
  8004208712:	48 01 c8             	add    %rcx,%rax
  8004208715:	48 83 c0 08          	add    $0x8,%rax
  8004208719:	48 8b 00             	mov    (%rax),%rax
  800420871c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208720:	75 4a                	jne    800420876c <env_destroy+0x10b>
		curenv = NULL;
  8004208722:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004208729:	00 00 00 
  800420872c:	ff d0                	callq  *%rax
  800420872e:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  8004208735:	00 00 00 
  8004208738:	48 98                	cltq   
  800420873a:	48 89 c2             	mov    %rax,%rdx
  800420873d:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004208744:	00 
  8004208745:	48 89 c2             	mov    %rax,%rdx
  8004208748:	48 89 d0             	mov    %rdx,%rax
  800420874b:	48 c1 e0 04          	shl    $0x4,%rax
  800420874f:	48 29 d0             	sub    %rdx,%rax
  8004208752:	48 01 c8             	add    %rcx,%rax
  8004208755:	48 83 c0 08          	add    $0x8,%rax
  8004208759:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  8004208760:	48 b8 2e c1 20 04 80 	movabs $0x800420c12e,%rax
  8004208767:	00 00 00 
  800420876a:	ff d0                	callq  *%rax
	}
}
  800420876c:	c9                   	leaveq 
  800420876d:	c3                   	retq   

000000800420876e <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  800420876e:	55                   	push   %rbp
  800420876f:	48 89 e5             	mov    %rsp,%rbp
  8004208772:	53                   	push   %rbx
  8004208773:	48 83 ec 18          	sub    $0x18,%rsp
  8004208777:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  800420877b:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004208782:	00 00 00 
  8004208785:	ff d0                	callq  *%rax
  8004208787:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420878e:	00 00 00 
  8004208791:	48 98                	cltq   
  8004208793:	48 89 c2             	mov    %rax,%rdx
  8004208796:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420879d:	00 
  800420879e:	48 89 c2             	mov    %rax,%rdx
  80042087a1:	48 89 d0             	mov    %rdx,%rax
  80042087a4:	48 c1 e0 04          	shl    $0x4,%rax
  80042087a8:	48 29 d0             	sub    %rdx,%rax
  80042087ab:	48 01 c8             	add    %rcx,%rax
  80042087ae:	48 83 c0 08          	add    $0x8,%rax
  80042087b2:	48 8b 18             	mov    (%rax),%rbx
  80042087b5:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  80042087bc:	00 00 00 
  80042087bf:	ff d0                	callq  *%rax
  80042087c1:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)
	__asm __volatile("movq %0,%%rsp\n"
  80042087c7:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  80042087cb:	4c 8b 3c 24          	mov    (%rsp),%r15
  80042087cf:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  80042087d4:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  80042087d9:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  80042087de:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  80042087e3:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  80042087e8:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  80042087ed:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  80042087f2:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  80042087f7:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  80042087fc:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208801:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208806:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420880b:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004208810:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  8004208815:	48 83 c4 78          	add    $0x78,%rsp
  8004208819:	8e 04 24             	mov    (%rsp),%es
  800420881c:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004208820:	48 83 c4 10          	add    $0x10,%rsp
  8004208824:	48 83 c4 10          	add    $0x10,%rsp
  8004208828:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  800420882a:	48 ba a4 75 21 04 80 	movabs $0x80042175a4,%rdx
  8004208831:	00 00 00 
  8004208834:	be 1d 02 00 00       	mov    $0x21d,%esi
  8004208839:	48 bf 38 75 21 04 80 	movabs $0x8004217538,%rdi
  8004208840:	00 00 00 
  8004208843:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208848:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  800420884f:	00 00 00 
  8004208852:	ff d1                	callq  *%rcx

0000008004208854 <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  8004208854:	55                   	push   %rbp
  8004208855:	48 89 e5             	mov    %rsp,%rbp
  8004208858:	48 83 ec 20          	sub    $0x20,%rsp
  800420885c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	// LAB 3: Your code here.
	
	//if context switch

	if(curenv && curenv->env_status == ENV_RUNNING){
  8004208860:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004208867:	00 00 00 
  800420886a:	ff d0                	callq  *%rax
  800420886c:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  8004208873:	00 00 00 
  8004208876:	48 98                	cltq   
  8004208878:	48 89 c2             	mov    %rax,%rdx
  800420887b:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004208882:	00 
  8004208883:	48 89 c2             	mov    %rax,%rdx
  8004208886:	48 89 d0             	mov    %rdx,%rax
  8004208889:	48 c1 e0 04          	shl    $0x4,%rax
  800420888d:	48 29 d0             	sub    %rdx,%rax
  8004208890:	48 01 c8             	add    %rcx,%rax
  8004208893:	48 83 c0 08          	add    $0x8,%rax
  8004208897:	48 8b 00             	mov    (%rax),%rax
  800420889a:	48 85 c0             	test   %rax,%rax
  800420889d:	0f 84 89 00 00 00    	je     800420892c <env_run+0xd8>
  80042088a3:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  80042088aa:	00 00 00 
  80042088ad:	ff d0                	callq  *%rax
  80042088af:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  80042088b6:	00 00 00 
  80042088b9:	48 98                	cltq   
  80042088bb:	48 89 c2             	mov    %rax,%rdx
  80042088be:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  80042088c5:	00 
  80042088c6:	48 89 c2             	mov    %rax,%rdx
  80042088c9:	48 89 d0             	mov    %rdx,%rax
  80042088cc:	48 c1 e0 04          	shl    $0x4,%rax
  80042088d0:	48 29 d0             	sub    %rdx,%rax
  80042088d3:	48 01 c8             	add    %rcx,%rax
  80042088d6:	48 83 c0 08          	add    $0x8,%rax
  80042088da:	48 8b 00             	mov    (%rax),%rax
  80042088dd:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042088e3:	83 f8 03             	cmp    $0x3,%eax
  80042088e6:	75 44                	jne    800420892c <env_run+0xd8>
		//set current status back to runnable instead of running
		curenv->env_status = ENV_RUNNABLE;
  80042088e8:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  80042088ef:	00 00 00 
  80042088f2:	ff d0                	callq  *%rax
  80042088f4:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  80042088fb:	00 00 00 
  80042088fe:	48 98                	cltq   
  8004208900:	48 89 c2             	mov    %rax,%rdx
  8004208903:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420890a:	00 
  800420890b:	48 89 c2             	mov    %rax,%rdx
  800420890e:	48 89 d0             	mov    %rdx,%rax
  8004208911:	48 c1 e0 04          	shl    $0x4,%rax
  8004208915:	48 29 d0             	sub    %rdx,%rax
  8004208918:	48 01 c8             	add    %rcx,%rax
  800420891b:	48 83 c0 08          	add    $0x8,%rax
  800420891f:	48 8b 00             	mov    (%rax),%rax
  8004208922:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208929:	00 00 00 
	}

	//actual switch current environment to new one
	curenv=e;
  800420892c:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004208933:	00 00 00 
  8004208936:	ff d0                	callq  *%rax
  8004208938:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420893f:	00 00 00 
  8004208942:	48 98                	cltq   
  8004208944:	48 89 c2             	mov    %rax,%rdx
  8004208947:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420894e:	00 
  800420894f:	48 89 c2             	mov    %rax,%rdx
  8004208952:	48 89 d0             	mov    %rdx,%rax
  8004208955:	48 c1 e0 04          	shl    $0x4,%rax
  8004208959:	48 29 d0             	sub    %rdx,%rax
  800420895c:	48 01 c8             	add    %rcx,%rax
  800420895f:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004208963:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208967:	48 89 02             	mov    %rax,(%rdx)
	curenv->env_status=ENV_RUNNING;
  800420896a:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004208971:	00 00 00 
  8004208974:	ff d0                	callq  *%rax
  8004208976:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420897d:	00 00 00 
  8004208980:	48 98                	cltq   
  8004208982:	48 89 c2             	mov    %rax,%rdx
  8004208985:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420898c:	00 
  800420898d:	48 89 c2             	mov    %rax,%rdx
  8004208990:	48 89 d0             	mov    %rdx,%rax
  8004208993:	48 c1 e0 04          	shl    $0x4,%rax
  8004208997:	48 29 d0             	sub    %rdx,%rax
  800420899a:	48 01 c8             	add    %rcx,%rax
  800420899d:	48 83 c0 08          	add    $0x8,%rax
  80042089a1:	48 8b 00             	mov    (%rax),%rax
  80042089a4:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  80042089ab:	00 00 00 
	curenv->env_runs++;
  80042089ae:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  80042089b5:	00 00 00 
  80042089b8:	ff d0                	callq  *%rax
  80042089ba:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  80042089c1:	00 00 00 
  80042089c4:	48 98                	cltq   
  80042089c6:	48 89 c2             	mov    %rax,%rdx
  80042089c9:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  80042089d0:	00 
  80042089d1:	48 89 c2             	mov    %rax,%rdx
  80042089d4:	48 89 d0             	mov    %rdx,%rax
  80042089d7:	48 c1 e0 04          	shl    $0x4,%rax
  80042089db:	48 29 d0             	sub    %rdx,%rax
  80042089de:	48 01 c8             	add    %rcx,%rax
  80042089e1:	48 83 c0 08          	add    $0x8,%rax
  80042089e5:	48 8b 00             	mov    (%rax),%rax
  80042089e8:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  80042089ee:	83 c2 01             	add    $0x1,%edx
  80042089f1:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	lcr3(PADDR(curenv->env_pml4e));
  80042089f7:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  80042089fe:	00 00 00 
  8004208a01:	ff d0                	callq  *%rax
  8004208a03:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  8004208a0a:	00 00 00 
  8004208a0d:	48 98                	cltq   
  8004208a0f:	48 89 c2             	mov    %rax,%rdx
  8004208a12:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004208a19:	00 
  8004208a1a:	48 89 c2             	mov    %rax,%rdx
  8004208a1d:	48 89 d0             	mov    %rdx,%rax
  8004208a20:	48 c1 e0 04          	shl    $0x4,%rax
  8004208a24:	48 29 d0             	sub    %rdx,%rax
  8004208a27:	48 01 c8             	add    %rcx,%rax
  8004208a2a:	48 83 c0 08          	add    $0x8,%rax
  8004208a2e:	48 8b 00             	mov    (%rax),%rax
  8004208a31:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208a38:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208a3c:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004208a43:	00 00 00 
  8004208a46:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004208a4a:	77 32                	ja     8004208a7e <env_run+0x22a>
  8004208a4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208a50:	48 89 c1             	mov    %rax,%rcx
  8004208a53:	48 ba b0 75 21 04 80 	movabs $0x80042175b0,%rdx
  8004208a5a:	00 00 00 
  8004208a5d:	be 47 02 00 00       	mov    $0x247,%esi
  8004208a62:	48 bf 38 75 21 04 80 	movabs $0x8004217538,%rdi
  8004208a69:	00 00 00 
  8004208a6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208a71:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004208a78:	00 00 00 
  8004208a7b:	41 ff d0             	callq  *%r8
  8004208a7e:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004208a85:	ff ff ff 
  8004208a88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208a8c:	48 01 d0             	add    %rdx,%rax
  8004208a8f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004208a93:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208a97:	0f 22 d8             	mov    %rax,%cr3

	unlock_kernel();
  8004208a9a:	48 b8 fb 76 20 04 80 	movabs $0x80042076fb,%rax
  8004208aa1:	00 00 00 
  8004208aa4:	ff d0                	callq  *%rax

	env_pop_tf(&e->env_tf);
  8004208aa6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208aaa:	48 89 c7             	mov    %rax,%rdi
  8004208aad:	48 b8 6e 87 20 04 80 	movabs $0x800420876e,%rax
  8004208ab4:	00 00 00 
  8004208ab7:	ff d0                	callq  *%rax

0000008004208ab9 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004208ab9:	55                   	push   %rbp
  8004208aba:	48 89 e5             	mov    %rsp,%rbp
  8004208abd:	48 83 ec 18          	sub    $0x18,%rsp
  8004208ac1:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004208ac4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208ac7:	0f b6 c0             	movzbl %al,%eax
  8004208aca:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208ad1:	88 45 f6             	mov    %al,-0xa(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208ad4:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
  8004208ad8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208adb:	ee                   	out    %al,(%dx)
  8004208adc:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004208ae3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004208ae6:	89 c2                	mov    %eax,%edx
  8004208ae8:	ec                   	in     (%dx),%al
  8004208ae9:	88 45 f7             	mov    %al,-0x9(%rbp)
	return data;
  8004208aec:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
	return inb(IO_RTC+1);
  8004208af0:	0f b6 c0             	movzbl %al,%eax
}
  8004208af3:	c9                   	leaveq 
  8004208af4:	c3                   	retq   

0000008004208af5 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  8004208af5:	55                   	push   %rbp
  8004208af6:	48 89 e5             	mov    %rsp,%rbp
  8004208af9:	48 83 ec 18          	sub    $0x18,%rsp
  8004208afd:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004208b00:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  8004208b03:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208b06:	0f b6 c0             	movzbl %al,%eax
  8004208b09:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208b10:	88 45 f6             	mov    %al,-0xa(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208b13:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
  8004208b17:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208b1a:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004208b1b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004208b1e:	0f b6 c0             	movzbl %al,%eax
  8004208b21:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%rbp)
  8004208b28:	88 45 f7             	mov    %al,-0x9(%rbp)
  8004208b2b:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004208b2f:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004208b32:	ee                   	out    %al,(%dx)
}
  8004208b33:	90                   	nop
  8004208b34:	c9                   	leaveq 
  8004208b35:	c3                   	retq   

0000008004208b36 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  8004208b36:	55                   	push   %rbp
  8004208b37:	48 89 e5             	mov    %rsp,%rbp
  8004208b3a:	48 83 ec 50          	sub    $0x50,%rsp
	didinit = 1;
  8004208b3e:	48 b8 60 22 36 04 80 	movabs $0x8004362260,%rax
  8004208b45:	00 00 00 
  8004208b48:	c6 00 01             	movb   $0x1,(%rax)
  8004208b4b:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004208b52:	c6 45 ba ff          	movb   $0xff,-0x46(%rbp)
  8004208b56:	0f b6 45 ba          	movzbl -0x46(%rbp),%eax
  8004208b5a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208b5d:	ee                   	out    %al,(%dx)
  8004208b5e:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%rbp)
  8004208b65:	c6 45 bb ff          	movb   $0xff,-0x45(%rbp)
  8004208b69:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004208b6d:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004208b70:	ee                   	out    %al,(%dx)
  8004208b71:	c7 45 f4 20 00 00 00 	movl   $0x20,-0xc(%rbp)
  8004208b78:	c6 45 bc 11          	movb   $0x11,-0x44(%rbp)
  8004208b7c:	0f b6 45 bc          	movzbl -0x44(%rbp),%eax
  8004208b80:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208b83:	ee                   	out    %al,(%dx)
  8004208b84:	c7 45 f0 21 00 00 00 	movl   $0x21,-0x10(%rbp)
  8004208b8b:	c6 45 bd 20          	movb   $0x20,-0x43(%rbp)
  8004208b8f:	0f b6 45 bd          	movzbl -0x43(%rbp),%eax
  8004208b93:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004208b96:	ee                   	out    %al,(%dx)
  8004208b97:	c7 45 ec 21 00 00 00 	movl   $0x21,-0x14(%rbp)
  8004208b9e:	c6 45 be 04          	movb   $0x4,-0x42(%rbp)
  8004208ba2:	0f b6 45 be          	movzbl -0x42(%rbp),%eax
  8004208ba6:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208ba9:	ee                   	out    %al,(%dx)
  8004208baa:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%rbp)
  8004208bb1:	c6 45 bf 03          	movb   $0x3,-0x41(%rbp)
  8004208bb5:	0f b6 45 bf          	movzbl -0x41(%rbp),%eax
  8004208bb9:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004208bbc:	ee                   	out    %al,(%dx)
  8004208bbd:	c7 45 e4 a0 00 00 00 	movl   $0xa0,-0x1c(%rbp)
  8004208bc4:	c6 45 c0 11          	movb   $0x11,-0x40(%rbp)
  8004208bc8:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  8004208bcc:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208bcf:	ee                   	out    %al,(%dx)
  8004208bd0:	c7 45 e0 a1 00 00 00 	movl   $0xa1,-0x20(%rbp)
  8004208bd7:	c6 45 c1 28          	movb   $0x28,-0x3f(%rbp)
  8004208bdb:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
  8004208bdf:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004208be2:	ee                   	out    %al,(%dx)
  8004208be3:	c7 45 dc a1 00 00 00 	movl   $0xa1,-0x24(%rbp)
  8004208bea:	c6 45 c2 02          	movb   $0x2,-0x3e(%rbp)
  8004208bee:	0f b6 45 c2          	movzbl -0x3e(%rbp),%eax
  8004208bf2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208bf5:	ee                   	out    %al,(%dx)
  8004208bf6:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%rbp)
  8004208bfd:	c6 45 c3 01          	movb   $0x1,-0x3d(%rbp)
  8004208c01:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004208c05:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004208c08:	ee                   	out    %al,(%dx)
  8004208c09:	c7 45 d4 20 00 00 00 	movl   $0x20,-0x2c(%rbp)
  8004208c10:	c6 45 c4 68          	movb   $0x68,-0x3c(%rbp)
  8004208c14:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  8004208c18:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208c1b:	ee                   	out    %al,(%dx)
  8004208c1c:	c7 45 d0 20 00 00 00 	movl   $0x20,-0x30(%rbp)
  8004208c23:	c6 45 c5 0a          	movb   $0xa,-0x3b(%rbp)
  8004208c27:	0f b6 45 c5          	movzbl -0x3b(%rbp),%eax
  8004208c2b:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8004208c2e:	ee                   	out    %al,(%dx)
  8004208c2f:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004208c36:	c6 45 c6 68          	movb   $0x68,-0x3a(%rbp)
  8004208c3a:	0f b6 45 c6          	movzbl -0x3a(%rbp),%eax
  8004208c3e:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208c41:	ee                   	out    %al,(%dx)
  8004208c42:	c7 45 c8 a0 00 00 00 	movl   $0xa0,-0x38(%rbp)
  8004208c49:	c6 45 c7 0a          	movb   $0xa,-0x39(%rbp)
  8004208c4d:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  8004208c51:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004208c54:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004208c55:	48 b8 92 b6 22 04 80 	movabs $0x800422b692,%rax
  8004208c5c:	00 00 00 
  8004208c5f:	0f b7 00             	movzwl (%rax),%eax
  8004208c62:	66 83 f8 ff          	cmp    $0xffff,%ax
  8004208c66:	74 1e                	je     8004208c86 <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004208c68:	48 b8 92 b6 22 04 80 	movabs $0x800422b692,%rax
  8004208c6f:	00 00 00 
  8004208c72:	0f b7 00             	movzwl (%rax),%eax
  8004208c75:	0f b7 c0             	movzwl %ax,%eax
  8004208c78:	89 c7                	mov    %eax,%edi
  8004208c7a:	48 b8 89 8c 20 04 80 	movabs $0x8004208c89,%rax
  8004208c81:	00 00 00 
  8004208c84:	ff d0                	callq  *%rax
}
  8004208c86:	90                   	nop
  8004208c87:	c9                   	leaveq 
  8004208c88:	c3                   	retq   

0000008004208c89 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004208c89:	55                   	push   %rbp
  8004208c8a:	48 89 e5             	mov    %rsp,%rbp
  8004208c8d:	48 83 ec 20          	sub    $0x20,%rsp
  8004208c91:	89 f8                	mov    %edi,%eax
  8004208c93:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
	int i;
	irq_mask_8259A = mask;
  8004208c97:	48 b8 92 b6 22 04 80 	movabs $0x800422b692,%rax
  8004208c9e:	00 00 00 
  8004208ca1:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  8004208ca5:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  8004208ca8:	48 b8 60 22 36 04 80 	movabs $0x8004362260,%rax
  8004208caf:	00 00 00 
  8004208cb2:	0f b6 00             	movzbl (%rax),%eax
  8004208cb5:	83 f0 01             	xor    $0x1,%eax
  8004208cb8:	84 c0                	test   %al,%al
  8004208cba:	0f 85 b9 00 00 00    	jne    8004208d79 <irq_setmask_8259A+0xf0>
		return;
	outb(IO_PIC1+1, (char)mask);
  8004208cc0:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8004208cc4:	0f b6 c0             	movzbl %al,%eax
  8004208cc7:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  8004208cce:	88 45 f2             	mov    %al,-0xe(%rbp)
  8004208cd1:	0f b6 45 f2          	movzbl -0xe(%rbp),%eax
  8004208cd5:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004208cd8:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004208cd9:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8004208cdd:	66 c1 e8 08          	shr    $0x8,%ax
  8004208ce1:	0f b6 c0             	movzbl %al,%eax
  8004208ce4:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004208ceb:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004208cee:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208cf2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208cf5:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  8004208cf6:	48 bf d4 75 21 04 80 	movabs $0x80042175d4,%rdi
  8004208cfd:	00 00 00 
  8004208d00:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208d05:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004208d0c:	00 00 00 
  8004208d0f:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004208d11:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004208d18:	eb 3c                	jmp    8004208d56 <irq_setmask_8259A+0xcd>
		if (~mask & (1<<i))
  8004208d1a:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8004208d1e:	f7 d0                	not    %eax
  8004208d20:	89 c2                	mov    %eax,%edx
  8004208d22:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208d25:	89 c1                	mov    %eax,%ecx
  8004208d27:	d3 fa                	sar    %cl,%edx
  8004208d29:	89 d0                	mov    %edx,%eax
  8004208d2b:	83 e0 01             	and    $0x1,%eax
  8004208d2e:	85 c0                	test   %eax,%eax
  8004208d30:	74 20                	je     8004208d52 <irq_setmask_8259A+0xc9>
			cprintf(" %d", i);
  8004208d32:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208d35:	89 c6                	mov    %eax,%esi
  8004208d37:	48 bf e8 75 21 04 80 	movabs $0x80042175e8,%rdi
  8004208d3e:	00 00 00 
  8004208d41:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208d46:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004208d4d:	00 00 00 
  8004208d50:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  8004208d52:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004208d56:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004208d5a:	7e be                	jle    8004208d1a <irq_setmask_8259A+0x91>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004208d5c:	48 bf ec 75 21 04 80 	movabs $0x80042175ec,%rdi
  8004208d63:	00 00 00 
  8004208d66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208d6b:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004208d72:	00 00 00 
  8004208d75:	ff d2                	callq  *%rdx
  8004208d77:	eb 01                	jmp    8004208d7a <irq_setmask_8259A+0xf1>
irq_setmask_8259A(uint16_t mask)
{
	int i;
	irq_mask_8259A = mask;
	if (!didinit)
		return;
  8004208d79:	90                   	nop
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
}
  8004208d7a:	c9                   	leaveq 
  8004208d7b:	c3                   	retq   

0000008004208d7c <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004208d7c:	55                   	push   %rbp
  8004208d7d:	48 89 e5             	mov    %rsp,%rbp
  8004208d80:	48 83 ec 10          	sub    $0x10,%rsp
  8004208d84:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004208d87:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004208d8b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208d8e:	89 c7                	mov    %eax,%edi
  8004208d90:	48 b8 a3 11 20 04 80 	movabs $0x80042011a3,%rax
  8004208d97:	00 00 00 
  8004208d9a:	ff d0                	callq  *%rax
	*cnt++;
  8004208d9c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208da0:	48 83 c0 04          	add    $0x4,%rax
  8004208da4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004208da8:	90                   	nop
  8004208da9:	c9                   	leaveq 
  8004208daa:	c3                   	retq   

0000008004208dab <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004208dab:	55                   	push   %rbp
  8004208dac:	48 89 e5             	mov    %rsp,%rbp
  8004208daf:	48 83 ec 30          	sub    $0x30,%rsp
  8004208db3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208db7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004208dbb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004208dc2:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004208dc6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208dca:	48 8b 0a             	mov    (%rdx),%rcx
  8004208dcd:	48 89 08             	mov    %rcx,(%rax)
  8004208dd0:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208dd4:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208dd8:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208ddc:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004208de0:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004208de4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004208de8:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004208dec:	48 89 c6             	mov    %rax,%rsi
  8004208def:	48 bf 7c 8d 20 04 80 	movabs $0x8004208d7c,%rdi
  8004208df6:	00 00 00 
  8004208df9:	48 b8 98 e0 20 04 80 	movabs $0x800420e098,%rax
  8004208e00:	00 00 00 
  8004208e03:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004208e05:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004208e08:	c9                   	leaveq 
  8004208e09:	c3                   	retq   

0000008004208e0a <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004208e0a:	55                   	push   %rbp
  8004208e0b:	48 89 e5             	mov    %rsp,%rbp
  8004208e0e:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004208e15:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  8004208e1c:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004208e23:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004208e2a:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004208e31:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004208e38:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004208e3f:	84 c0                	test   %al,%al
  8004208e41:	74 20                	je     8004208e63 <cprintf+0x59>
  8004208e43:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004208e47:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004208e4b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004208e4f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004208e53:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004208e57:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004208e5b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004208e5f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004208e63:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004208e6a:	00 00 00 
  8004208e6d:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004208e74:	00 00 00 
  8004208e77:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004208e7b:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004208e82:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004208e89:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004208e90:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004208e97:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004208e9e:	48 8b 0a             	mov    (%rdx),%rcx
  8004208ea1:	48 89 08             	mov    %rcx,(%rax)
  8004208ea4:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208ea8:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208eac:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208eb0:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004208eb4:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004208ebb:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004208ec2:	48 89 d6             	mov    %rdx,%rsi
  8004208ec5:	48 89 c7             	mov    %rax,%rdi
  8004208ec8:	48 b8 ab 8d 20 04 80 	movabs $0x8004208dab,%rax
  8004208ecf:	00 00 00 
  8004208ed2:	ff d0                	callq  *%rax
  8004208ed4:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004208eda:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004208ee0:	c9                   	leaveq 
  8004208ee1:	c3                   	retq   

0000008004208ee2 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004208ee2:	55                   	push   %rbp
  8004208ee3:	48 89 e5             	mov    %rsp,%rbp
  8004208ee6:	48 83 ec 20          	sub    $0x20,%rsp
  8004208eea:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004208eee:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004208ef1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208ef5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004208ef8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004208efc:	f0 87 02             	lock xchg %eax,(%rdx)
  8004208eff:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004208f02:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004208f05:	c9                   	leaveq 
  8004208f06:	c3                   	retq   

0000008004208f07 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004208f07:	55                   	push   %rbp
  8004208f08:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004208f0b:	48 bf 80 b7 22 04 80 	movabs $0x800422b780,%rdi
  8004208f12:	00 00 00 
  8004208f15:	48 b8 0e 5f 21 04 80 	movabs $0x8004215f0e,%rax
  8004208f1c:	00 00 00 
  8004208f1f:	ff d0                	callq  *%rax
}
  8004208f21:	90                   	nop
  8004208f22:	5d                   	pop    %rbp
  8004208f23:	c3                   	retq   

0000008004208f24 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004208f24:	55                   	push   %rbp
  8004208f25:	48 89 e5             	mov    %rsp,%rbp
  8004208f28:	48 83 ec 08          	sub    $0x8,%rsp
  8004208f2c:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004208f2f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208f32:	83 f8 13             	cmp    $0x13,%eax
  8004208f35:	77 16                	ja     8004208f4d <trapname+0x29>
		return excnames[trapno];
  8004208f37:	48 b8 20 7a 21 04 80 	movabs $0x8004217a20,%rax
  8004208f3e:	00 00 00 
  8004208f41:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208f44:	48 63 d2             	movslq %edx,%rdx
  8004208f47:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004208f4b:	eb 34                	jmp    8004208f81 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004208f4d:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004208f51:	75 0c                	jne    8004208f5f <trapname+0x3b>
		return "System call";
  8004208f53:	48 b8 00 76 21 04 80 	movabs $0x8004217600,%rax
  8004208f5a:	00 00 00 
  8004208f5d:	eb 22                	jmp    8004208f81 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004208f5f:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004208f63:	7e 12                	jle    8004208f77 <trapname+0x53>
  8004208f65:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004208f69:	7f 0c                	jg     8004208f77 <trapname+0x53>
		return "Hardware Interrupt";
  8004208f6b:	48 b8 0c 76 21 04 80 	movabs $0x800421760c,%rax
  8004208f72:	00 00 00 
  8004208f75:	eb 0a                	jmp    8004208f81 <trapname+0x5d>
	return "(unknown trap)";
  8004208f77:	48 b8 1f 76 21 04 80 	movabs $0x800421761f,%rax
  8004208f7e:	00 00 00 
}
  8004208f81:	c9                   	leaveq 
  8004208f82:	c3                   	retq   

0000008004208f83 <trap_init>:


void
trap_init(void)
{
  8004208f83:	55                   	push   %rbp
  8004208f84:	48 89 e5             	mov    %rsp,%rbp
	extern void XTRAPX_irq_spurious();
	extern void XTRAPX_irq_ide();
	extern void XTRAPX_irq_error();


	SETGATE(idt[T_DIVIDE], 0, GD_KT, XTRAPX_divzero, 0);  
  8004208f87:	48 b8 84 bf 20 04 80 	movabs $0x800420bf84,%rax
  8004208f8e:	00 00 00 
  8004208f91:	89 c2                	mov    %eax,%edx
  8004208f93:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004208f9a:	00 00 00 
  8004208f9d:	66 89 10             	mov    %dx,(%rax)
  8004208fa0:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004208fa7:	00 00 00 
  8004208faa:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004208fb0:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004208fb7:	00 00 00 
  8004208fba:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208fbe:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208fc1:	88 50 04             	mov    %dl,0x4(%rax)
  8004208fc4:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004208fcb:	00 00 00 
  8004208fce:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208fd2:	83 e2 07             	and    $0x7,%edx
  8004208fd5:	88 50 04             	mov    %dl,0x4(%rax)
  8004208fd8:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004208fdf:	00 00 00 
  8004208fe2:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208fe6:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208fe9:	83 ca 0e             	or     $0xe,%edx
  8004208fec:	88 50 05             	mov    %dl,0x5(%rax)
  8004208fef:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004208ff6:	00 00 00 
  8004208ff9:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208ffd:	83 e2 ef             	and    $0xffffffef,%edx
  8004209000:	88 50 05             	mov    %dl,0x5(%rax)
  8004209003:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420900a:	00 00 00 
  800420900d:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209011:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209014:	88 50 05             	mov    %dl,0x5(%rax)
  8004209017:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420901e:	00 00 00 
  8004209021:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209025:	83 ca 80             	or     $0xffffff80,%edx
  8004209028:	88 50 05             	mov    %dl,0x5(%rax)
  800420902b:	48 b8 84 bf 20 04 80 	movabs $0x800420bf84,%rax
  8004209032:	00 00 00 
  8004209035:	48 c1 e8 10          	shr    $0x10,%rax
  8004209039:	89 c2                	mov    %eax,%edx
  800420903b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209042:	00 00 00 
  8004209045:	66 89 50 06          	mov    %dx,0x6(%rax)
  8004209049:	48 b8 84 bf 20 04 80 	movabs $0x800420bf84,%rax
  8004209050:	00 00 00 
  8004209053:	48 c1 e8 20          	shr    $0x20,%rax
  8004209057:	89 c2                	mov    %eax,%edx
  8004209059:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209060:	00 00 00 
  8004209063:	89 50 08             	mov    %edx,0x8(%rax)
  8004209066:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420906d:	00 00 00 
  8004209070:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
    	SETGATE(idt[T_DEBUG], 0, GD_KT, XTRAPX_debug, 0);  
  8004209077:	48 b8 8e bf 20 04 80 	movabs $0x800420bf8e,%rax
  800420907e:	00 00 00 
  8004209081:	89 c2                	mov    %eax,%edx
  8004209083:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420908a:	00 00 00 
  800420908d:	66 89 50 10          	mov    %dx,0x10(%rax)
  8004209091:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209098:	00 00 00 
  800420909b:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  80042090a1:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042090a8:	00 00 00 
  80042090ab:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  80042090af:	83 e2 f8             	and    $0xfffffff8,%edx
  80042090b2:	88 50 14             	mov    %dl,0x14(%rax)
  80042090b5:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042090bc:	00 00 00 
  80042090bf:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  80042090c3:	83 e2 07             	and    $0x7,%edx
  80042090c6:	88 50 14             	mov    %dl,0x14(%rax)
  80042090c9:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042090d0:	00 00 00 
  80042090d3:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042090d7:	83 e2 f0             	and    $0xfffffff0,%edx
  80042090da:	83 ca 0e             	or     $0xe,%edx
  80042090dd:	88 50 15             	mov    %dl,0x15(%rax)
  80042090e0:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042090e7:	00 00 00 
  80042090ea:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042090ee:	83 e2 ef             	and    $0xffffffef,%edx
  80042090f1:	88 50 15             	mov    %dl,0x15(%rax)
  80042090f4:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042090fb:	00 00 00 
  80042090fe:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209102:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209105:	88 50 15             	mov    %dl,0x15(%rax)
  8004209108:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420910f:	00 00 00 
  8004209112:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209116:	83 ca 80             	or     $0xffffff80,%edx
  8004209119:	88 50 15             	mov    %dl,0x15(%rax)
  800420911c:	48 b8 8e bf 20 04 80 	movabs $0x800420bf8e,%rax
  8004209123:	00 00 00 
  8004209126:	48 c1 e8 10          	shr    $0x10,%rax
  800420912a:	89 c2                	mov    %eax,%edx
  800420912c:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209133:	00 00 00 
  8004209136:	66 89 50 16          	mov    %dx,0x16(%rax)
  800420913a:	48 b8 8e bf 20 04 80 	movabs $0x800420bf8e,%rax
  8004209141:	00 00 00 
  8004209144:	48 c1 e8 20          	shr    $0x20,%rax
  8004209148:	89 c2                	mov    %eax,%edx
  800420914a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209151:	00 00 00 
  8004209154:	89 50 18             	mov    %edx,0x18(%rax)
  8004209157:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420915e:	00 00 00 
  8004209161:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
    	SETGATE(idt[T_NMI], 0, GD_KT, XTRAPX_nonmask, 0);  
  8004209168:	48 b8 98 bf 20 04 80 	movabs $0x800420bf98,%rax
  800420916f:	00 00 00 
  8004209172:	89 c2                	mov    %eax,%edx
  8004209174:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420917b:	00 00 00 
  800420917e:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004209182:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209189:	00 00 00 
  800420918c:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004209192:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209199:	00 00 00 
  800420919c:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  80042091a0:	83 e2 f8             	and    $0xfffffff8,%edx
  80042091a3:	88 50 24             	mov    %dl,0x24(%rax)
  80042091a6:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042091ad:	00 00 00 
  80042091b0:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  80042091b4:	83 e2 07             	and    $0x7,%edx
  80042091b7:	88 50 24             	mov    %dl,0x24(%rax)
  80042091ba:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042091c1:	00 00 00 
  80042091c4:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042091c8:	83 e2 f0             	and    $0xfffffff0,%edx
  80042091cb:	83 ca 0e             	or     $0xe,%edx
  80042091ce:	88 50 25             	mov    %dl,0x25(%rax)
  80042091d1:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042091d8:	00 00 00 
  80042091db:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042091df:	83 e2 ef             	and    $0xffffffef,%edx
  80042091e2:	88 50 25             	mov    %dl,0x25(%rax)
  80042091e5:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042091ec:	00 00 00 
  80042091ef:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042091f3:	83 e2 9f             	and    $0xffffff9f,%edx
  80042091f6:	88 50 25             	mov    %dl,0x25(%rax)
  80042091f9:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209200:	00 00 00 
  8004209203:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209207:	83 ca 80             	or     $0xffffff80,%edx
  800420920a:	88 50 25             	mov    %dl,0x25(%rax)
  800420920d:	48 b8 98 bf 20 04 80 	movabs $0x800420bf98,%rax
  8004209214:	00 00 00 
  8004209217:	48 c1 e8 10          	shr    $0x10,%rax
  800420921b:	89 c2                	mov    %eax,%edx
  800420921d:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209224:	00 00 00 
  8004209227:	66 89 50 26          	mov    %dx,0x26(%rax)
  800420922b:	48 b8 98 bf 20 04 80 	movabs $0x800420bf98,%rax
  8004209232:	00 00 00 
  8004209235:	48 c1 e8 20          	shr    $0x20,%rax
  8004209239:	89 c2                	mov    %eax,%edx
  800420923b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209242:	00 00 00 
  8004209245:	89 50 28             	mov    %edx,0x28(%rax)
  8004209248:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420924f:	00 00 00 
  8004209252:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
    	SETGATE(idt[T_BRKPT], 0, GD_KT, XTRAPX_breakpoint, 3);  
  8004209259:	48 b8 a2 bf 20 04 80 	movabs $0x800420bfa2,%rax
  8004209260:	00 00 00 
  8004209263:	89 c2                	mov    %eax,%edx
  8004209265:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420926c:	00 00 00 
  800420926f:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004209273:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420927a:	00 00 00 
  800420927d:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004209283:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420928a:	00 00 00 
  800420928d:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209291:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209294:	88 50 34             	mov    %dl,0x34(%rax)
  8004209297:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420929e:	00 00 00 
  80042092a1:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  80042092a5:	83 e2 07             	and    $0x7,%edx
  80042092a8:	88 50 34             	mov    %dl,0x34(%rax)
  80042092ab:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042092b2:	00 00 00 
  80042092b5:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  80042092b9:	83 e2 f0             	and    $0xfffffff0,%edx
  80042092bc:	83 ca 0e             	or     $0xe,%edx
  80042092bf:	88 50 35             	mov    %dl,0x35(%rax)
  80042092c2:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042092c9:	00 00 00 
  80042092cc:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  80042092d0:	83 e2 ef             	and    $0xffffffef,%edx
  80042092d3:	88 50 35             	mov    %dl,0x35(%rax)
  80042092d6:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042092dd:	00 00 00 
  80042092e0:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  80042092e4:	83 ca 60             	or     $0x60,%edx
  80042092e7:	88 50 35             	mov    %dl,0x35(%rax)
  80042092ea:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042092f1:	00 00 00 
  80042092f4:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  80042092f8:	83 ca 80             	or     $0xffffff80,%edx
  80042092fb:	88 50 35             	mov    %dl,0x35(%rax)
  80042092fe:	48 b8 a2 bf 20 04 80 	movabs $0x800420bfa2,%rax
  8004209305:	00 00 00 
  8004209308:	48 c1 e8 10          	shr    $0x10,%rax
  800420930c:	89 c2                	mov    %eax,%edx
  800420930e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209315:	00 00 00 
  8004209318:	66 89 50 36          	mov    %dx,0x36(%rax)
  800420931c:	48 b8 a2 bf 20 04 80 	movabs $0x800420bfa2,%rax
  8004209323:	00 00 00 
  8004209326:	48 c1 e8 20          	shr    $0x20,%rax
  800420932a:	89 c2                	mov    %eax,%edx
  800420932c:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209333:	00 00 00 
  8004209336:	89 50 38             	mov    %edx,0x38(%rax)
  8004209339:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209340:	00 00 00 
  8004209343:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
    	SETGATE(idt[T_OFLOW], 0, GD_KT, XTRAPX_overflow, 0);  
  800420934a:	48 b8 a8 bf 20 04 80 	movabs $0x800420bfa8,%rax
  8004209351:	00 00 00 
  8004209354:	89 c2                	mov    %eax,%edx
  8004209356:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420935d:	00 00 00 
  8004209360:	66 89 50 40          	mov    %dx,0x40(%rax)
  8004209364:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420936b:	00 00 00 
  800420936e:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004209374:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420937b:	00 00 00 
  800420937e:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209382:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209385:	88 50 44             	mov    %dl,0x44(%rax)
  8004209388:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420938f:	00 00 00 
  8004209392:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209396:	83 e2 07             	and    $0x7,%edx
  8004209399:	88 50 44             	mov    %dl,0x44(%rax)
  800420939c:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042093a3:	00 00 00 
  80042093a6:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042093aa:	83 e2 f0             	and    $0xfffffff0,%edx
  80042093ad:	83 ca 0e             	or     $0xe,%edx
  80042093b0:	88 50 45             	mov    %dl,0x45(%rax)
  80042093b3:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042093ba:	00 00 00 
  80042093bd:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042093c1:	83 e2 ef             	and    $0xffffffef,%edx
  80042093c4:	88 50 45             	mov    %dl,0x45(%rax)
  80042093c7:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042093ce:	00 00 00 
  80042093d1:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042093d5:	83 e2 9f             	and    $0xffffff9f,%edx
  80042093d8:	88 50 45             	mov    %dl,0x45(%rax)
  80042093db:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042093e2:	00 00 00 
  80042093e5:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042093e9:	83 ca 80             	or     $0xffffff80,%edx
  80042093ec:	88 50 45             	mov    %dl,0x45(%rax)
  80042093ef:	48 b8 a8 bf 20 04 80 	movabs $0x800420bfa8,%rax
  80042093f6:	00 00 00 
  80042093f9:	48 c1 e8 10          	shr    $0x10,%rax
  80042093fd:	89 c2                	mov    %eax,%edx
  80042093ff:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209406:	00 00 00 
  8004209409:	66 89 50 46          	mov    %dx,0x46(%rax)
  800420940d:	48 b8 a8 bf 20 04 80 	movabs $0x800420bfa8,%rax
  8004209414:	00 00 00 
  8004209417:	48 c1 e8 20          	shr    $0x20,%rax
  800420941b:	89 c2                	mov    %eax,%edx
  800420941d:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209424:	00 00 00 
  8004209427:	89 50 48             	mov    %edx,0x48(%rax)
  800420942a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209431:	00 00 00 
  8004209434:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
    	SETGATE(idt[T_BOUND], 0, GD_KT, XTRAPX_bound, 0);  
  800420943b:	48 b8 ae bf 20 04 80 	movabs $0x800420bfae,%rax
  8004209442:	00 00 00 
  8004209445:	89 c2                	mov    %eax,%edx
  8004209447:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420944e:	00 00 00 
  8004209451:	66 89 50 50          	mov    %dx,0x50(%rax)
  8004209455:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420945c:	00 00 00 
  800420945f:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  8004209465:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420946c:	00 00 00 
  800420946f:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209473:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209476:	88 50 54             	mov    %dl,0x54(%rax)
  8004209479:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209480:	00 00 00 
  8004209483:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209487:	83 e2 07             	and    $0x7,%edx
  800420948a:	88 50 54             	mov    %dl,0x54(%rax)
  800420948d:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209494:	00 00 00 
  8004209497:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420949b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420949e:	83 ca 0e             	or     $0xe,%edx
  80042094a1:	88 50 55             	mov    %dl,0x55(%rax)
  80042094a4:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042094ab:	00 00 00 
  80042094ae:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  80042094b2:	83 e2 ef             	and    $0xffffffef,%edx
  80042094b5:	88 50 55             	mov    %dl,0x55(%rax)
  80042094b8:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042094bf:	00 00 00 
  80042094c2:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  80042094c6:	83 e2 9f             	and    $0xffffff9f,%edx
  80042094c9:	88 50 55             	mov    %dl,0x55(%rax)
  80042094cc:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042094d3:	00 00 00 
  80042094d6:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  80042094da:	83 ca 80             	or     $0xffffff80,%edx
  80042094dd:	88 50 55             	mov    %dl,0x55(%rax)
  80042094e0:	48 b8 ae bf 20 04 80 	movabs $0x800420bfae,%rax
  80042094e7:	00 00 00 
  80042094ea:	48 c1 e8 10          	shr    $0x10,%rax
  80042094ee:	89 c2                	mov    %eax,%edx
  80042094f0:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042094f7:	00 00 00 
  80042094fa:	66 89 50 56          	mov    %dx,0x56(%rax)
  80042094fe:	48 b8 ae bf 20 04 80 	movabs $0x800420bfae,%rax
  8004209505:	00 00 00 
  8004209508:	48 c1 e8 20          	shr    $0x20,%rax
  800420950c:	89 c2                	mov    %eax,%edx
  800420950e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209515:	00 00 00 
  8004209518:	89 50 58             	mov    %edx,0x58(%rax)
  800420951b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209522:	00 00 00 
  8004209525:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
    	SETGATE(idt[T_ILLOP], 0, GD_KT, XTRAPX_illop, 0);  
  800420952c:	48 b8 b4 bf 20 04 80 	movabs $0x800420bfb4,%rax
  8004209533:	00 00 00 
  8004209536:	89 c2                	mov    %eax,%edx
  8004209538:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420953f:	00 00 00 
  8004209542:	66 89 50 60          	mov    %dx,0x60(%rax)
  8004209546:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420954d:	00 00 00 
  8004209550:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  8004209556:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420955d:	00 00 00 
  8004209560:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209564:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209567:	88 50 64             	mov    %dl,0x64(%rax)
  800420956a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209571:	00 00 00 
  8004209574:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209578:	83 e2 07             	and    $0x7,%edx
  800420957b:	88 50 64             	mov    %dl,0x64(%rax)
  800420957e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209585:	00 00 00 
  8004209588:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420958c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420958f:	83 ca 0e             	or     $0xe,%edx
  8004209592:	88 50 65             	mov    %dl,0x65(%rax)
  8004209595:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420959c:	00 00 00 
  800420959f:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  80042095a3:	83 e2 ef             	and    $0xffffffef,%edx
  80042095a6:	88 50 65             	mov    %dl,0x65(%rax)
  80042095a9:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042095b0:	00 00 00 
  80042095b3:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  80042095b7:	83 e2 9f             	and    $0xffffff9f,%edx
  80042095ba:	88 50 65             	mov    %dl,0x65(%rax)
  80042095bd:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042095c4:	00 00 00 
  80042095c7:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  80042095cb:	83 ca 80             	or     $0xffffff80,%edx
  80042095ce:	88 50 65             	mov    %dl,0x65(%rax)
  80042095d1:	48 b8 b4 bf 20 04 80 	movabs $0x800420bfb4,%rax
  80042095d8:	00 00 00 
  80042095db:	48 c1 e8 10          	shr    $0x10,%rax
  80042095df:	89 c2                	mov    %eax,%edx
  80042095e1:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042095e8:	00 00 00 
  80042095eb:	66 89 50 66          	mov    %dx,0x66(%rax)
  80042095ef:	48 b8 b4 bf 20 04 80 	movabs $0x800420bfb4,%rax
  80042095f6:	00 00 00 
  80042095f9:	48 c1 e8 20          	shr    $0x20,%rax
  80042095fd:	89 c2                	mov    %eax,%edx
  80042095ff:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209606:	00 00 00 
  8004209609:	89 50 68             	mov    %edx,0x68(%rax)
  800420960c:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209613:	00 00 00 
  8004209616:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
    	SETGATE(idt[T_DEVICE], 0, GD_KT, XTRAPX_device, 0);  
  800420961d:	48 b8 ba bf 20 04 80 	movabs $0x800420bfba,%rax
  8004209624:	00 00 00 
  8004209627:	89 c2                	mov    %eax,%edx
  8004209629:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209630:	00 00 00 
  8004209633:	66 89 50 70          	mov    %dx,0x70(%rax)
  8004209637:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420963e:	00 00 00 
  8004209641:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  8004209647:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420964e:	00 00 00 
  8004209651:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209655:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209658:	88 50 74             	mov    %dl,0x74(%rax)
  800420965b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209662:	00 00 00 
  8004209665:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209669:	83 e2 07             	and    $0x7,%edx
  800420966c:	88 50 74             	mov    %dl,0x74(%rax)
  800420966f:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209676:	00 00 00 
  8004209679:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420967d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209680:	83 ca 0e             	or     $0xe,%edx
  8004209683:	88 50 75             	mov    %dl,0x75(%rax)
  8004209686:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420968d:	00 00 00 
  8004209690:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209694:	83 e2 ef             	and    $0xffffffef,%edx
  8004209697:	88 50 75             	mov    %dl,0x75(%rax)
  800420969a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042096a1:	00 00 00 
  80042096a4:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  80042096a8:	83 e2 9f             	and    $0xffffff9f,%edx
  80042096ab:	88 50 75             	mov    %dl,0x75(%rax)
  80042096ae:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042096b5:	00 00 00 
  80042096b8:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  80042096bc:	83 ca 80             	or     $0xffffff80,%edx
  80042096bf:	88 50 75             	mov    %dl,0x75(%rax)
  80042096c2:	48 b8 ba bf 20 04 80 	movabs $0x800420bfba,%rax
  80042096c9:	00 00 00 
  80042096cc:	48 c1 e8 10          	shr    $0x10,%rax
  80042096d0:	89 c2                	mov    %eax,%edx
  80042096d2:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042096d9:	00 00 00 
  80042096dc:	66 89 50 76          	mov    %dx,0x76(%rax)
  80042096e0:	48 b8 ba bf 20 04 80 	movabs $0x800420bfba,%rax
  80042096e7:	00 00 00 
  80042096ea:	48 c1 e8 20          	shr    $0x20,%rax
  80042096ee:	89 c2                	mov    %eax,%edx
  80042096f0:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042096f7:	00 00 00 
  80042096fa:	89 50 78             	mov    %edx,0x78(%rax)
  80042096fd:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209704:	00 00 00 
  8004209707:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
   	SETGATE(idt[T_DBLFLT], 0, GD_KT, XTRAPX_dblflt, 0);  
  800420970e:	48 b8 c0 bf 20 04 80 	movabs $0x800420bfc0,%rax
  8004209715:	00 00 00 
  8004209718:	89 c2                	mov    %eax,%edx
  800420971a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209721:	00 00 00 
  8004209724:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  800420972b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209732:	00 00 00 
  8004209735:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  800420973c:	08 00 
  800420973e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209745:	00 00 00 
  8004209748:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420974f:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209752:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209758:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420975f:	00 00 00 
  8004209762:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209769:	83 e2 07             	and    $0x7,%edx
  800420976c:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209772:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209779:	00 00 00 
  800420977c:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209783:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209786:	83 ca 0e             	or     $0xe,%edx
  8004209789:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420978f:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209796:	00 00 00 
  8004209799:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042097a0:	83 e2 ef             	and    $0xffffffef,%edx
  80042097a3:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042097a9:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042097b0:	00 00 00 
  80042097b3:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042097ba:	83 e2 9f             	and    $0xffffff9f,%edx
  80042097bd:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042097c3:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042097ca:	00 00 00 
  80042097cd:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042097d4:	83 ca 80             	or     $0xffffff80,%edx
  80042097d7:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042097dd:	48 b8 c0 bf 20 04 80 	movabs $0x800420bfc0,%rax
  80042097e4:	00 00 00 
  80042097e7:	48 c1 e8 10          	shr    $0x10,%rax
  80042097eb:	89 c2                	mov    %eax,%edx
  80042097ed:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042097f4:	00 00 00 
  80042097f7:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  80042097fe:	48 b8 c0 bf 20 04 80 	movabs $0x800420bfc0,%rax
  8004209805:	00 00 00 
  8004209808:	48 c1 e8 20          	shr    $0x20,%rax
  800420980c:	89 c2                	mov    %eax,%edx
  800420980e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209815:	00 00 00 
  8004209818:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  800420981e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209825:	00 00 00 
  8004209828:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  800420982f:	00 00 00 
    	
	SETGATE(idt[T_TSS], 0, GD_KT, XTRAPX_tss, 0);  
  8004209832:	48 b8 c4 bf 20 04 80 	movabs $0x800420bfc4,%rax
  8004209839:	00 00 00 
  800420983c:	89 c2                	mov    %eax,%edx
  800420983e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209845:	00 00 00 
  8004209848:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  800420984f:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209856:	00 00 00 
  8004209859:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  8004209860:	08 00 
  8004209862:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209869:	00 00 00 
  800420986c:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209873:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209876:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420987c:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209883:	00 00 00 
  8004209886:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420988d:	83 e2 07             	and    $0x7,%edx
  8004209890:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004209896:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420989d:	00 00 00 
  80042098a0:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042098a7:	83 e2 f0             	and    $0xfffffff0,%edx
  80042098aa:	83 ca 0e             	or     $0xe,%edx
  80042098ad:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042098b3:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042098ba:	00 00 00 
  80042098bd:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042098c4:	83 e2 ef             	and    $0xffffffef,%edx
  80042098c7:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042098cd:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042098d4:	00 00 00 
  80042098d7:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042098de:	83 e2 9f             	and    $0xffffff9f,%edx
  80042098e1:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042098e7:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042098ee:	00 00 00 
  80042098f1:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042098f8:	83 ca 80             	or     $0xffffff80,%edx
  80042098fb:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209901:	48 b8 c4 bf 20 04 80 	movabs $0x800420bfc4,%rax
  8004209908:	00 00 00 
  800420990b:	48 c1 e8 10          	shr    $0x10,%rax
  800420990f:	89 c2                	mov    %eax,%edx
  8004209911:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209918:	00 00 00 
  800420991b:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  8004209922:	48 b8 c4 bf 20 04 80 	movabs $0x800420bfc4,%rax
  8004209929:	00 00 00 
  800420992c:	48 c1 e8 20          	shr    $0x20,%rax
  8004209930:	89 c2                	mov    %eax,%edx
  8004209932:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209939:	00 00 00 
  800420993c:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  8004209942:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209949:	00 00 00 
  800420994c:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  8004209953:	00 00 00 
    	SETGATE(idt[T_SEGNP], 0, GD_KT, XTRAPX_segnp, 0);  
  8004209956:	48 b8 c8 bf 20 04 80 	movabs $0x800420bfc8,%rax
  800420995d:	00 00 00 
  8004209960:	89 c2                	mov    %eax,%edx
  8004209962:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209969:	00 00 00 
  800420996c:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  8004209973:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420997a:	00 00 00 
  800420997d:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  8004209984:	08 00 
  8004209986:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420998d:	00 00 00 
  8004209990:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209997:	83 e2 f8             	and    $0xfffffff8,%edx
  800420999a:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  80042099a0:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042099a7:	00 00 00 
  80042099aa:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  80042099b1:	83 e2 07             	and    $0x7,%edx
  80042099b4:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  80042099ba:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042099c1:	00 00 00 
  80042099c4:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042099cb:	83 e2 f0             	and    $0xfffffff0,%edx
  80042099ce:	83 ca 0e             	or     $0xe,%edx
  80042099d1:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042099d7:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042099de:	00 00 00 
  80042099e1:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042099e8:	83 e2 ef             	and    $0xffffffef,%edx
  80042099eb:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042099f1:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  80042099f8:	00 00 00 
  80042099fb:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209a02:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209a05:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209a0b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209a12:	00 00 00 
  8004209a15:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209a1c:	83 ca 80             	or     $0xffffff80,%edx
  8004209a1f:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209a25:	48 b8 c8 bf 20 04 80 	movabs $0x800420bfc8,%rax
  8004209a2c:	00 00 00 
  8004209a2f:	48 c1 e8 10          	shr    $0x10,%rax
  8004209a33:	89 c2                	mov    %eax,%edx
  8004209a35:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209a3c:	00 00 00 
  8004209a3f:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  8004209a46:	48 b8 c8 bf 20 04 80 	movabs $0x800420bfc8,%rax
  8004209a4d:	00 00 00 
  8004209a50:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a54:	89 c2                	mov    %eax,%edx
  8004209a56:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209a5d:	00 00 00 
  8004209a60:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  8004209a66:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209a6d:	00 00 00 
  8004209a70:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  8004209a77:	00 00 00 
    	SETGATE(idt[T_STACK], 0, GD_KT, XTRAPX_stack, 0);  
  8004209a7a:	48 b8 cc bf 20 04 80 	movabs $0x800420bfcc,%rax
  8004209a81:	00 00 00 
  8004209a84:	89 c2                	mov    %eax,%edx
  8004209a86:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209a8d:	00 00 00 
  8004209a90:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  8004209a97:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209a9e:	00 00 00 
  8004209aa1:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  8004209aa8:	08 00 
  8004209aaa:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209ab1:	00 00 00 
  8004209ab4:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209abb:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209abe:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209ac4:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209acb:	00 00 00 
  8004209ace:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209ad5:	83 e2 07             	and    $0x7,%edx
  8004209ad8:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209ade:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209ae5:	00 00 00 
  8004209ae8:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209aef:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209af2:	83 ca 0e             	or     $0xe,%edx
  8004209af5:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209afb:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209b02:	00 00 00 
  8004209b05:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209b0c:	83 e2 ef             	and    $0xffffffef,%edx
  8004209b0f:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209b15:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209b1c:	00 00 00 
  8004209b1f:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209b26:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209b29:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209b2f:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209b36:	00 00 00 
  8004209b39:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209b40:	83 ca 80             	or     $0xffffff80,%edx
  8004209b43:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209b49:	48 b8 cc bf 20 04 80 	movabs $0x800420bfcc,%rax
  8004209b50:	00 00 00 
  8004209b53:	48 c1 e8 10          	shr    $0x10,%rax
  8004209b57:	89 c2                	mov    %eax,%edx
  8004209b59:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209b60:	00 00 00 
  8004209b63:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  8004209b6a:	48 b8 cc bf 20 04 80 	movabs $0x800420bfcc,%rax
  8004209b71:	00 00 00 
  8004209b74:	48 c1 e8 20          	shr    $0x20,%rax
  8004209b78:	89 c2                	mov    %eax,%edx
  8004209b7a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209b81:	00 00 00 
  8004209b84:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  8004209b8a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209b91:	00 00 00 
  8004209b94:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  8004209b9b:	00 00 00 
    	SETGATE(idt[T_GPFLT], 0, GD_KT, XTRAPX_gpflt, 0);  
  8004209b9e:	48 b8 d0 bf 20 04 80 	movabs $0x800420bfd0,%rax
  8004209ba5:	00 00 00 
  8004209ba8:	89 c2                	mov    %eax,%edx
  8004209baa:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209bb1:	00 00 00 
  8004209bb4:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  8004209bbb:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209bc2:	00 00 00 
  8004209bc5:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  8004209bcc:	08 00 
  8004209bce:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209bd5:	00 00 00 
  8004209bd8:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209bdf:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209be2:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209be8:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209bef:	00 00 00 
  8004209bf2:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209bf9:	83 e2 07             	and    $0x7,%edx
  8004209bfc:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209c02:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209c09:	00 00 00 
  8004209c0c:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209c13:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209c16:	83 ca 0e             	or     $0xe,%edx
  8004209c19:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209c1f:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209c26:	00 00 00 
  8004209c29:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209c30:	83 e2 ef             	and    $0xffffffef,%edx
  8004209c33:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209c39:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209c40:	00 00 00 
  8004209c43:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209c4a:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209c4d:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209c53:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209c5a:	00 00 00 
  8004209c5d:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209c64:	83 ca 80             	or     $0xffffff80,%edx
  8004209c67:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209c6d:	48 b8 d0 bf 20 04 80 	movabs $0x800420bfd0,%rax
  8004209c74:	00 00 00 
  8004209c77:	48 c1 e8 10          	shr    $0x10,%rax
  8004209c7b:	89 c2                	mov    %eax,%edx
  8004209c7d:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209c84:	00 00 00 
  8004209c87:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  8004209c8e:	48 b8 d0 bf 20 04 80 	movabs $0x800420bfd0,%rax
  8004209c95:	00 00 00 
  8004209c98:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c9c:	89 c2                	mov    %eax,%edx
  8004209c9e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209ca5:	00 00 00 
  8004209ca8:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  8004209cae:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209cb5:	00 00 00 
  8004209cb8:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  8004209cbf:	00 00 00 
    	SETGATE(idt[T_PGFLT], 0, GD_KT, XTRAPX_pgflt, 0);  
  8004209cc2:	48 b8 d4 bf 20 04 80 	movabs $0x800420bfd4,%rax
  8004209cc9:	00 00 00 
  8004209ccc:	89 c2                	mov    %eax,%edx
  8004209cce:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209cd5:	00 00 00 
  8004209cd8:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  8004209cdf:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209ce6:	00 00 00 
  8004209ce9:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  8004209cf0:	08 00 
  8004209cf2:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209cf9:	00 00 00 
  8004209cfc:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209d03:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209d06:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209d0c:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209d13:	00 00 00 
  8004209d16:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209d1d:	83 e2 07             	and    $0x7,%edx
  8004209d20:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209d26:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209d2d:	00 00 00 
  8004209d30:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d37:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209d3a:	83 ca 0e             	or     $0xe,%edx
  8004209d3d:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d43:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209d4a:	00 00 00 
  8004209d4d:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d54:	83 e2 ef             	and    $0xffffffef,%edx
  8004209d57:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d5d:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209d64:	00 00 00 
  8004209d67:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d6e:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209d71:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d77:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209d7e:	00 00 00 
  8004209d81:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209d88:	83 ca 80             	or     $0xffffff80,%edx
  8004209d8b:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209d91:	48 b8 d4 bf 20 04 80 	movabs $0x800420bfd4,%rax
  8004209d98:	00 00 00 
  8004209d9b:	48 c1 e8 10          	shr    $0x10,%rax
  8004209d9f:	89 c2                	mov    %eax,%edx
  8004209da1:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209da8:	00 00 00 
  8004209dab:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  8004209db2:	48 b8 d4 bf 20 04 80 	movabs $0x800420bfd4,%rax
  8004209db9:	00 00 00 
  8004209dbc:	48 c1 e8 20          	shr    $0x20,%rax
  8004209dc0:	89 c2                	mov    %eax,%edx
  8004209dc2:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209dc9:	00 00 00 
  8004209dcc:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  8004209dd2:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209dd9:	00 00 00 
  8004209ddc:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  8004209de3:	00 00 00 
    	
	SETGATE(idt[T_FPERR], 0, GD_KT, XTRAPX_fperr, 0);  
  8004209de6:	48 b8 d8 bf 20 04 80 	movabs $0x800420bfd8,%rax
  8004209ded:	00 00 00 
  8004209df0:	89 c2                	mov    %eax,%edx
  8004209df2:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209df9:	00 00 00 
  8004209dfc:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  8004209e03:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209e0a:	00 00 00 
  8004209e0d:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  8004209e14:	08 00 
  8004209e16:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209e1d:	00 00 00 
  8004209e20:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209e27:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209e2a:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209e30:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209e37:	00 00 00 
  8004209e3a:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209e41:	83 e2 07             	and    $0x7,%edx
  8004209e44:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209e4a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209e51:	00 00 00 
  8004209e54:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e5b:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209e5e:	83 ca 0e             	or     $0xe,%edx
  8004209e61:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e67:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209e6e:	00 00 00 
  8004209e71:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e78:	83 e2 ef             	and    $0xffffffef,%edx
  8004209e7b:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e81:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209e88:	00 00 00 
  8004209e8b:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209e92:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209e95:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209e9b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209ea2:	00 00 00 
  8004209ea5:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209eac:	83 ca 80             	or     $0xffffff80,%edx
  8004209eaf:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209eb5:	48 b8 d8 bf 20 04 80 	movabs $0x800420bfd8,%rax
  8004209ebc:	00 00 00 
  8004209ebf:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ec3:	89 c2                	mov    %eax,%edx
  8004209ec5:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209ecc:	00 00 00 
  8004209ecf:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  8004209ed6:	48 b8 d8 bf 20 04 80 	movabs $0x800420bfd8,%rax
  8004209edd:	00 00 00 
  8004209ee0:	48 c1 e8 20          	shr    $0x20,%rax
  8004209ee4:	89 c2                	mov    %eax,%edx
  8004209ee6:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209eed:	00 00 00 
  8004209ef0:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  8004209ef6:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209efd:	00 00 00 
  8004209f00:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  8004209f07:	00 00 00 
    	SETGATE(idt[T_ALIGN], 0, GD_KT, XTRAPX_align, 0);  
  8004209f0a:	48 b8 de bf 20 04 80 	movabs $0x800420bfde,%rax
  8004209f11:	00 00 00 
  8004209f14:	89 c2                	mov    %eax,%edx
  8004209f16:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209f1d:	00 00 00 
  8004209f20:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  8004209f27:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209f2e:	00 00 00 
  8004209f31:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  8004209f38:	08 00 
  8004209f3a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209f41:	00 00 00 
  8004209f44:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209f4b:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209f4e:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209f54:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209f5b:	00 00 00 
  8004209f5e:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209f65:	83 e2 07             	and    $0x7,%edx
  8004209f68:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209f6e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209f75:	00 00 00 
  8004209f78:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f7f:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f82:	83 ca 0e             	or     $0xe,%edx
  8004209f85:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209f8b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209f92:	00 00 00 
  8004209f95:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209f9c:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f9f:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209fa5:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209fac:	00 00 00 
  8004209faf:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209fb6:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209fb9:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209fbf:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209fc6:	00 00 00 
  8004209fc9:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209fd0:	83 ca 80             	or     $0xffffff80,%edx
  8004209fd3:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209fd9:	48 b8 de bf 20 04 80 	movabs $0x800420bfde,%rax
  8004209fe0:	00 00 00 
  8004209fe3:	48 c1 e8 10          	shr    $0x10,%rax
  8004209fe7:	89 c2                	mov    %eax,%edx
  8004209fe9:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  8004209ff0:	00 00 00 
  8004209ff3:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  8004209ffa:	48 b8 de bf 20 04 80 	movabs $0x800420bfde,%rax
  800420a001:	00 00 00 
  800420a004:	48 c1 e8 20          	shr    $0x20,%rax
  800420a008:	89 c2                	mov    %eax,%edx
  800420a00a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a011:	00 00 00 
  800420a014:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  800420a01a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a021:	00 00 00 
  800420a024:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  800420a02b:	00 00 00 
    	SETGATE(idt[T_MCHK], 0, GD_KT, XTRAPX_mchk, 0);  
  800420a02e:	48 b8 e2 bf 20 04 80 	movabs $0x800420bfe2,%rax
  800420a035:	00 00 00 
  800420a038:	89 c2                	mov    %eax,%edx
  800420a03a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a041:	00 00 00 
  800420a044:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  800420a04b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a052:	00 00 00 
  800420a055:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  800420a05c:	08 00 
  800420a05e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a065:	00 00 00 
  800420a068:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a06f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a072:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a078:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a07f:	00 00 00 
  800420a082:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a089:	83 e2 07             	and    $0x7,%edx
  800420a08c:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a092:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a099:	00 00 00 
  800420a09c:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a0a3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a0a6:	83 ca 0e             	or     $0xe,%edx
  800420a0a9:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a0af:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a0b6:	00 00 00 
  800420a0b9:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a0c0:	83 e2 ef             	and    $0xffffffef,%edx
  800420a0c3:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a0c9:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a0d0:	00 00 00 
  800420a0d3:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a0da:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a0dd:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a0e3:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a0ea:	00 00 00 
  800420a0ed:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a0f4:	83 ca 80             	or     $0xffffff80,%edx
  800420a0f7:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a0fd:	48 b8 e2 bf 20 04 80 	movabs $0x800420bfe2,%rax
  800420a104:	00 00 00 
  800420a107:	48 c1 e8 10          	shr    $0x10,%rax
  800420a10b:	89 c2                	mov    %eax,%edx
  800420a10d:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a114:	00 00 00 
  800420a117:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420a11e:	48 b8 e2 bf 20 04 80 	movabs $0x800420bfe2,%rax
  800420a125:	00 00 00 
  800420a128:	48 c1 e8 20          	shr    $0x20,%rax
  800420a12c:	89 c2                	mov    %eax,%edx
  800420a12e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a135:	00 00 00 
  800420a138:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420a13e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a145:	00 00 00 
  800420a148:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420a14f:	00 00 00 
    	SETGATE(idt[T_SIMDERR], 0, GD_KT, XTRAPX_simderr, 0);  
  800420a152:	48 b8 e8 bf 20 04 80 	movabs $0x800420bfe8,%rax
  800420a159:	00 00 00 
  800420a15c:	89 c2                	mov    %eax,%edx
  800420a15e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a165:	00 00 00 
  800420a168:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  800420a16f:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a176:	00 00 00 
  800420a179:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  800420a180:	08 00 
  800420a182:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a189:	00 00 00 
  800420a18c:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a193:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a196:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a19c:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a1a3:	00 00 00 
  800420a1a6:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a1ad:	83 e2 07             	and    $0x7,%edx
  800420a1b0:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a1b6:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a1bd:	00 00 00 
  800420a1c0:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a1c7:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a1ca:	83 ca 0e             	or     $0xe,%edx
  800420a1cd:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a1d3:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a1da:	00 00 00 
  800420a1dd:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a1e4:	83 e2 ef             	and    $0xffffffef,%edx
  800420a1e7:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a1ed:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a1f4:	00 00 00 
  800420a1f7:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a1fe:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a201:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a207:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a20e:	00 00 00 
  800420a211:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a218:	83 ca 80             	or     $0xffffff80,%edx
  800420a21b:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a221:	48 b8 e8 bf 20 04 80 	movabs $0x800420bfe8,%rax
  800420a228:	00 00 00 
  800420a22b:	48 c1 e8 10          	shr    $0x10,%rax
  800420a22f:	89 c2                	mov    %eax,%edx
  800420a231:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a238:	00 00 00 
  800420a23b:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  800420a242:	48 b8 e8 bf 20 04 80 	movabs $0x800420bfe8,%rax
  800420a249:	00 00 00 
  800420a24c:	48 c1 e8 20          	shr    $0x20,%rax
  800420a250:	89 c2                	mov    %eax,%edx
  800420a252:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a259:	00 00 00 
  800420a25c:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  800420a262:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a269:	00 00 00 
  800420a26c:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  800420a273:	00 00 00 
    	
	SETGATE(idt[T_SYSCALL], 0, GD_KT, XTRAPX_syscall, 3);
  800420a276:	48 b8 ee bf 20 04 80 	movabs $0x800420bfee,%rax
  800420a27d:	00 00 00 
  800420a280:	89 c2                	mov    %eax,%edx
  800420a282:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a289:	00 00 00 
  800420a28c:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420a293:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a29a:	00 00 00 
  800420a29d:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420a2a4:	08 00 
  800420a2a6:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a2ad:	00 00 00 
  800420a2b0:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a2b7:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a2ba:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a2c0:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a2c7:	00 00 00 
  800420a2ca:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a2d1:	83 e2 07             	and    $0x7,%edx
  800420a2d4:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a2da:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a2e1:	00 00 00 
  800420a2e4:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a2eb:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a2ee:	83 ca 0e             	or     $0xe,%edx
  800420a2f1:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a2f7:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a2fe:	00 00 00 
  800420a301:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a308:	83 e2 ef             	and    $0xffffffef,%edx
  800420a30b:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a311:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a318:	00 00 00 
  800420a31b:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a322:	83 ca 60             	or     $0x60,%edx
  800420a325:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a32b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a332:	00 00 00 
  800420a335:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a33c:	83 ca 80             	or     $0xffffff80,%edx
  800420a33f:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a345:	48 b8 ee bf 20 04 80 	movabs $0x800420bfee,%rax
  800420a34c:	00 00 00 
  800420a34f:	48 c1 e8 10          	shr    $0x10,%rax
  800420a353:	89 c2                	mov    %eax,%edx
  800420a355:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a35c:	00 00 00 
  800420a35f:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420a366:	48 b8 ee bf 20 04 80 	movabs $0x800420bfee,%rax
  800420a36d:	00 00 00 
  800420a370:	48 c1 e8 20          	shr    $0x20,%rax
  800420a374:	89 c2                	mov    %eax,%edx
  800420a376:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a37d:	00 00 00 
  800420a380:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420a386:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a38d:	00 00 00 
  800420a390:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420a397:	00 00 00 
    	SETGATE(idt[T_DEFAULT], 0, GD_KT, XTRAPX_default, 0);
  800420a39a:	48 b8 f4 bf 20 04 80 	movabs $0x800420bff4,%rax
  800420a3a1:	00 00 00 
  800420a3a4:	89 c2                	mov    %eax,%edx
  800420a3a6:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a3ad:	00 00 00 
  800420a3b0:	66 89 90 40 1f 00 00 	mov    %dx,0x1f40(%rax)
  800420a3b7:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a3be:	00 00 00 
  800420a3c1:	66 c7 80 42 1f 00 00 	movw   $0x8,0x1f42(%rax)
  800420a3c8:	08 00 
  800420a3ca:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a3d1:	00 00 00 
  800420a3d4:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420a3db:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a3de:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420a3e4:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a3eb:	00 00 00 
  800420a3ee:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420a3f5:	83 e2 07             	and    $0x7,%edx
  800420a3f8:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420a3fe:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a405:	00 00 00 
  800420a408:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a40f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a412:	83 ca 0e             	or     $0xe,%edx
  800420a415:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a41b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a422:	00 00 00 
  800420a425:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a42c:	83 e2 ef             	and    $0xffffffef,%edx
  800420a42f:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a435:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a43c:	00 00 00 
  800420a43f:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a446:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a449:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a44f:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a456:	00 00 00 
  800420a459:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a460:	83 ca 80             	or     $0xffffff80,%edx
  800420a463:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a469:	48 b8 f4 bf 20 04 80 	movabs $0x800420bff4,%rax
  800420a470:	00 00 00 
  800420a473:	48 c1 e8 10          	shr    $0x10,%rax
  800420a477:	89 c2                	mov    %eax,%edx
  800420a479:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a480:	00 00 00 
  800420a483:	66 89 90 46 1f 00 00 	mov    %dx,0x1f46(%rax)
  800420a48a:	48 b8 f4 bf 20 04 80 	movabs $0x800420bff4,%rax
  800420a491:	00 00 00 
  800420a494:	48 c1 e8 20          	shr    $0x20,%rax
  800420a498:	89 c2                	mov    %eax,%edx
  800420a49a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a4a1:	00 00 00 
  800420a4a4:	89 90 48 1f 00 00    	mov    %edx,0x1f48(%rax)
  800420a4aa:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a4b1:	00 00 00 
  800420a4b4:	c7 80 4c 1f 00 00 00 	movl   $0x0,0x1f4c(%rax)
  800420a4bb:	00 00 00 
	
    	SETGATE(idt[IRQ_OFFSET+IRQ_TIMER], 0, GD_KT, XTRAPX_irq_timer, 0);
  800420a4be:	48 b8 fe bf 20 04 80 	movabs $0x800420bffe,%rax
  800420a4c5:	00 00 00 
  800420a4c8:	89 c2                	mov    %eax,%edx
  800420a4ca:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a4d1:	00 00 00 
  800420a4d4:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420a4db:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a4e2:	00 00 00 
  800420a4e5:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420a4ec:	08 00 
  800420a4ee:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a4f5:	00 00 00 
  800420a4f8:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a4ff:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a502:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a508:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a50f:	00 00 00 
  800420a512:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a519:	83 e2 07             	and    $0x7,%edx
  800420a51c:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a522:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a529:	00 00 00 
  800420a52c:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a533:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a536:	83 ca 0e             	or     $0xe,%edx
  800420a539:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a53f:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a546:	00 00 00 
  800420a549:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a550:	83 e2 ef             	and    $0xffffffef,%edx
  800420a553:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a559:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a560:	00 00 00 
  800420a563:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a56a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a56d:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a573:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a57a:	00 00 00 
  800420a57d:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a584:	83 ca 80             	or     $0xffffff80,%edx
  800420a587:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a58d:	48 b8 fe bf 20 04 80 	movabs $0x800420bffe,%rax
  800420a594:	00 00 00 
  800420a597:	48 c1 e8 10          	shr    $0x10,%rax
  800420a59b:	89 c2                	mov    %eax,%edx
  800420a59d:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a5a4:	00 00 00 
  800420a5a7:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420a5ae:	48 b8 fe bf 20 04 80 	movabs $0x800420bffe,%rax
  800420a5b5:	00 00 00 
  800420a5b8:	48 c1 e8 20          	shr    $0x20,%rax
  800420a5bc:	89 c2                	mov    %eax,%edx
  800420a5be:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a5c5:	00 00 00 
  800420a5c8:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420a5ce:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a5d5:	00 00 00 
  800420a5d8:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420a5df:	00 00 00 
    	SETGATE(idt[IRQ_OFFSET+IRQ_KBD], 0, GD_KT, XTRAPX_irq_kbd, 0);
  800420a5e2:	48 b8 04 c0 20 04 80 	movabs $0x800420c004,%rax
  800420a5e9:	00 00 00 
  800420a5ec:	89 c2                	mov    %eax,%edx
  800420a5ee:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a5f5:	00 00 00 
  800420a5f8:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420a5ff:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a606:	00 00 00 
  800420a609:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420a610:	08 00 
  800420a612:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a619:	00 00 00 
  800420a61c:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a623:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a626:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a62c:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a633:	00 00 00 
  800420a636:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a63d:	83 e2 07             	and    $0x7,%edx
  800420a640:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a646:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a64d:	00 00 00 
  800420a650:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a657:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a65a:	83 ca 0e             	or     $0xe,%edx
  800420a65d:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a663:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a66a:	00 00 00 
  800420a66d:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a674:	83 e2 ef             	and    $0xffffffef,%edx
  800420a677:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a67d:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a684:	00 00 00 
  800420a687:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a68e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a691:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a697:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a69e:	00 00 00 
  800420a6a1:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a6a8:	83 ca 80             	or     $0xffffff80,%edx
  800420a6ab:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a6b1:	48 b8 04 c0 20 04 80 	movabs $0x800420c004,%rax
  800420a6b8:	00 00 00 
  800420a6bb:	48 c1 e8 10          	shr    $0x10,%rax
  800420a6bf:	89 c2                	mov    %eax,%edx
  800420a6c1:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a6c8:	00 00 00 
  800420a6cb:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420a6d2:	48 b8 04 c0 20 04 80 	movabs $0x800420c004,%rax
  800420a6d9:	00 00 00 
  800420a6dc:	48 c1 e8 20          	shr    $0x20,%rax
  800420a6e0:	89 c2                	mov    %eax,%edx
  800420a6e2:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a6e9:	00 00 00 
  800420a6ec:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420a6f2:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a6f9:	00 00 00 
  800420a6fc:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420a703:	00 00 00 
    	SETGATE(idt[IRQ_OFFSET+IRQ_SERIAL], 0, GD_KT, XTRAPX_irq_serial, 0);
  800420a706:	48 b8 0a c0 20 04 80 	movabs $0x800420c00a,%rax
  800420a70d:	00 00 00 
  800420a710:	89 c2                	mov    %eax,%edx
  800420a712:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a719:	00 00 00 
  800420a71c:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420a723:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a72a:	00 00 00 
  800420a72d:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420a734:	08 00 
  800420a736:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a73d:	00 00 00 
  800420a740:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a747:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a74a:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a750:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a757:	00 00 00 
  800420a75a:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a761:	83 e2 07             	and    $0x7,%edx
  800420a764:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a76a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a771:	00 00 00 
  800420a774:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a77b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a77e:	83 ca 0e             	or     $0xe,%edx
  800420a781:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a787:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a78e:	00 00 00 
  800420a791:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a798:	83 e2 ef             	and    $0xffffffef,%edx
  800420a79b:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a7a1:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a7a8:	00 00 00 
  800420a7ab:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a7b2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a7b5:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a7bb:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a7c2:	00 00 00 
  800420a7c5:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a7cc:	83 ca 80             	or     $0xffffff80,%edx
  800420a7cf:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a7d5:	48 b8 0a c0 20 04 80 	movabs $0x800420c00a,%rax
  800420a7dc:	00 00 00 
  800420a7df:	48 c1 e8 10          	shr    $0x10,%rax
  800420a7e3:	89 c2                	mov    %eax,%edx
  800420a7e5:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a7ec:	00 00 00 
  800420a7ef:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420a7f6:	48 b8 0a c0 20 04 80 	movabs $0x800420c00a,%rax
  800420a7fd:	00 00 00 
  800420a800:	48 c1 e8 20          	shr    $0x20,%rax
  800420a804:	89 c2                	mov    %eax,%edx
  800420a806:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a80d:	00 00 00 
  800420a810:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420a816:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a81d:	00 00 00 
  800420a820:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420a827:	00 00 00 
    	SETGATE(idt[IRQ_OFFSET+IRQ_SPURIOUS], 0, GD_KT, XTRAPX_irq_spurious, 0);
  800420a82a:	48 b8 10 c0 20 04 80 	movabs $0x800420c010,%rax
  800420a831:	00 00 00 
  800420a834:	89 c2                	mov    %eax,%edx
  800420a836:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a83d:	00 00 00 
  800420a840:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420a847:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a84e:	00 00 00 
  800420a851:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420a858:	08 00 
  800420a85a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a861:	00 00 00 
  800420a864:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a86b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a86e:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a874:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a87b:	00 00 00 
  800420a87e:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a885:	83 e2 07             	and    $0x7,%edx
  800420a888:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a88e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a895:	00 00 00 
  800420a898:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a89f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a8a2:	83 ca 0e             	or     $0xe,%edx
  800420a8a5:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a8ab:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a8b2:	00 00 00 
  800420a8b5:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a8bc:	83 e2 ef             	and    $0xffffffef,%edx
  800420a8bf:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a8c5:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a8cc:	00 00 00 
  800420a8cf:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a8d6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a8d9:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a8df:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a8e6:	00 00 00 
  800420a8e9:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a8f0:	83 ca 80             	or     $0xffffff80,%edx
  800420a8f3:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a8f9:	48 b8 10 c0 20 04 80 	movabs $0x800420c010,%rax
  800420a900:	00 00 00 
  800420a903:	48 c1 e8 10          	shr    $0x10,%rax
  800420a907:	89 c2                	mov    %eax,%edx
  800420a909:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a910:	00 00 00 
  800420a913:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420a91a:	48 b8 10 c0 20 04 80 	movabs $0x800420c010,%rax
  800420a921:	00 00 00 
  800420a924:	48 c1 e8 20          	shr    $0x20,%rax
  800420a928:	89 c2                	mov    %eax,%edx
  800420a92a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a931:	00 00 00 
  800420a934:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420a93a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a941:	00 00 00 
  800420a944:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420a94b:	00 00 00 
    	SETGATE(idt[IRQ_OFFSET+IRQ_IDE], 0, GD_KT, XTRAPX_irq_ide, 0);
  800420a94e:	48 b8 16 c0 20 04 80 	movabs $0x800420c016,%rax
  800420a955:	00 00 00 
  800420a958:	89 c2                	mov    %eax,%edx
  800420a95a:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a961:	00 00 00 
  800420a964:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420a96b:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a972:	00 00 00 
  800420a975:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420a97c:	08 00 
  800420a97e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a985:	00 00 00 
  800420a988:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420a98f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a992:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420a998:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a99f:	00 00 00 
  800420a9a2:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420a9a9:	83 e2 07             	and    $0x7,%edx
  800420a9ac:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420a9b2:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a9b9:	00 00 00 
  800420a9bc:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a9c3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a9c6:	83 ca 0e             	or     $0xe,%edx
  800420a9c9:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420a9cf:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a9d6:	00 00 00 
  800420a9d9:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a9e0:	83 e2 ef             	and    $0xffffffef,%edx
  800420a9e3:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420a9e9:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420a9f0:	00 00 00 
  800420a9f3:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a9fa:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a9fd:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420aa03:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420aa0a:	00 00 00 
  800420aa0d:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420aa14:	83 ca 80             	or     $0xffffff80,%edx
  800420aa17:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420aa1d:	48 b8 16 c0 20 04 80 	movabs $0x800420c016,%rax
  800420aa24:	00 00 00 
  800420aa27:	48 c1 e8 10          	shr    $0x10,%rax
  800420aa2b:	89 c2                	mov    %eax,%edx
  800420aa2d:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420aa34:	00 00 00 
  800420aa37:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420aa3e:	48 b8 16 c0 20 04 80 	movabs $0x800420c016,%rax
  800420aa45:	00 00 00 
  800420aa48:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa4c:	89 c2                	mov    %eax,%edx
  800420aa4e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420aa55:	00 00 00 
  800420aa58:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420aa5e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420aa65:	00 00 00 
  800420aa68:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420aa6f:	00 00 00 
    	SETGATE(idt[IRQ_OFFSET+IRQ_ERROR], 0, GD_KT, XTRAPX_irq_error, 0);
  800420aa72:	48 b8 1c c0 20 04 80 	movabs $0x800420c01c,%rax
  800420aa79:	00 00 00 
  800420aa7c:	89 c2                	mov    %eax,%edx
  800420aa7e:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420aa85:	00 00 00 
  800420aa88:	66 89 90 30 03 00 00 	mov    %dx,0x330(%rax)
  800420aa8f:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420aa96:	00 00 00 
  800420aa99:	66 c7 80 32 03 00 00 	movw   $0x8,0x332(%rax)
  800420aaa0:	08 00 
  800420aaa2:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420aaa9:	00 00 00 
  800420aaac:	0f b6 90 34 03 00 00 	movzbl 0x334(%rax),%edx
  800420aab3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aab6:	88 90 34 03 00 00    	mov    %dl,0x334(%rax)
  800420aabc:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420aac3:	00 00 00 
  800420aac6:	0f b6 90 34 03 00 00 	movzbl 0x334(%rax),%edx
  800420aacd:	83 e2 07             	and    $0x7,%edx
  800420aad0:	88 90 34 03 00 00    	mov    %dl,0x334(%rax)
  800420aad6:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420aadd:	00 00 00 
  800420aae0:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420aae7:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aaea:	83 ca 0e             	or     $0xe,%edx
  800420aaed:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420aaf3:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420aafa:	00 00 00 
  800420aafd:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420ab04:	83 e2 ef             	and    $0xffffffef,%edx
  800420ab07:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420ab0d:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420ab14:	00 00 00 
  800420ab17:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420ab1e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ab21:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420ab27:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420ab2e:	00 00 00 
  800420ab31:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420ab38:	83 ca 80             	or     $0xffffff80,%edx
  800420ab3b:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420ab41:	48 b8 1c c0 20 04 80 	movabs $0x800420c01c,%rax
  800420ab48:	00 00 00 
  800420ab4b:	48 c1 e8 10          	shr    $0x10,%rax
  800420ab4f:	89 c2                	mov    %eax,%edx
  800420ab51:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420ab58:	00 00 00 
  800420ab5b:	66 89 90 36 03 00 00 	mov    %dx,0x336(%rax)
  800420ab62:	48 b8 1c c0 20 04 80 	movabs $0x800420c01c,%rax
  800420ab69:	00 00 00 
  800420ab6c:	48 c1 e8 20          	shr    $0x20,%rax
  800420ab70:	89 c2                	mov    %eax,%edx
  800420ab72:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420ab79:	00 00 00 
  800420ab7c:	89 90 38 03 00 00    	mov    %edx,0x338(%rax)
  800420ab82:	48 b8 80 22 36 04 80 	movabs $0x8004362280,%rax
  800420ab89:	00 00 00 
  800420ab8c:	c7 80 3c 03 00 00 00 	movl   $0x0,0x33c(%rax)
  800420ab93:	00 00 00 

	idt_pd.pd_lim = sizeof(idt)-1;
  800420ab96:	48 b8 80 32 36 04 80 	movabs $0x8004363280,%rax
  800420ab9d:	00 00 00 
  800420aba0:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  800420aba5:	48 ba 80 22 36 04 80 	movabs $0x8004362280,%rdx
  800420abac:	00 00 00 
  800420abaf:	48 b8 80 32 36 04 80 	movabs $0x8004363280,%rax
  800420abb6:	00 00 00 
  800420abb9:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420abbd:	48 b8 cc ab 20 04 80 	movabs $0x800420abcc,%rax
  800420abc4:	00 00 00 
  800420abc7:	ff d0                	callq  *%rax
}
  800420abc9:	90                   	nop
  800420abca:	5d                   	pop    %rbp
  800420abcb:	c3                   	retq   

000000800420abcc <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420abcc:	55                   	push   %rbp
  800420abcd:	48 89 e5             	mov    %rsp,%rbp
  800420abd0:	53                   	push   %rbx
  800420abd1:	48 83 ec 18          	sub    $0x18,%rsp

	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.


	int cpu_id = thiscpu->cpu_id;
  800420abd5:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420abdc:	00 00 00 
  800420abdf:	ff d0                	callq  *%rax
  800420abe1:	48 ba 20 50 36 04 80 	movabs $0x8004365020,%rdx
  800420abe8:	00 00 00 
  800420abeb:	48 98                	cltq   
  800420abed:	48 c1 e0 03          	shl    $0x3,%rax
  800420abf1:	48 89 c1             	mov    %rax,%rcx
  800420abf4:	48 c1 e1 04          	shl    $0x4,%rcx
  800420abf8:	48 29 c1             	sub    %rax,%rcx
  800420abfb:	48 89 c8             	mov    %rcx,%rax
  800420abfe:	48 01 d0             	add    %rdx,%rax
  800420ac01:	0f b6 00             	movzbl (%rax),%eax
  800420ac04:	0f b6 c0             	movzbl %al,%eax
  800420ac07:	89 45 ec             	mov    %eax,-0x14(%rbp)
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - cpu_id * (KSTKSIZE+KSTKGAP);
  800420ac0a:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420ac11:	00 00 00 
  800420ac14:	ff d0                	callq  *%rax
  800420ac16:	89 c7                	mov    %eax,%edi
  800420ac18:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420ac1b:	89 d0                	mov    %edx,%eax
  800420ac1d:	01 c0                	add    %eax,%eax
  800420ac1f:	01 d0                	add    %edx,%eax
  800420ac21:	c1 e0 0f             	shl    $0xf,%eax
  800420ac24:	48 98                	cltq   
  800420ac26:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420ac2d:	00 00 00 
  800420ac30:	48 29 c2             	sub    %rax,%rdx
  800420ac33:	48 89 d0             	mov    %rdx,%rax
  800420ac36:	48 89 c6             	mov    %rax,%rsi
  800420ac39:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420ac40:	00 00 00 
  800420ac43:	48 63 c7             	movslq %edi,%rax
  800420ac46:	48 89 c2             	mov    %rax,%rdx
  800420ac49:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420ac50:	00 
  800420ac51:	48 89 c2             	mov    %rax,%rdx
  800420ac54:	48 89 d0             	mov    %rdx,%rax
  800420ac57:	48 c1 e0 04          	shl    $0x4,%rax
  800420ac5b:	48 29 d0             	sub    %rdx,%rax
  800420ac5e:	48 01 c8             	add    %rcx,%rax
  800420ac61:	48 83 c0 10          	add    $0x10,%rax
  800420ac65:	48 89 70 04          	mov    %rsi,0x4(%rax)
	//gdt[(GD_TSS0>>3)+(2*cpu_id)]=SEG64(STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
	
	//NOT HAVING THIS GAVE INFINITE LOOOP, SYSTEM, not application (difference between SETTSS and straight up assignment
	//gdt[(GD_TSS0>>3)+(2*cpu_id)].sd_s = 0;

	SETTSS((struct SystemSegdesc64 *)((gdt_pd>>16)+40+16*cpu_id),STS_T64A, (uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420ac69:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420ac70:	00 00 00 
  800420ac73:	48 8b 00             	mov    (%rax),%rax
  800420ac76:	48 c1 f8 10          	sar    $0x10,%rax
  800420ac7a:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ac7e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ac81:	c1 e0 04             	shl    $0x4,%eax
  800420ac84:	48 98                	cltq   
  800420ac86:	48 01 d0             	add    %rdx,%rax
  800420ac89:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420ac8e:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420ac95:	00 00 00 
  800420ac98:	48 8b 00             	mov    (%rax),%rax
  800420ac9b:	48 c1 f8 10          	sar    $0x10,%rax
  800420ac9f:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420aca3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420aca6:	c1 e0 04             	shl    $0x4,%eax
  800420aca9:	48 98                	cltq   
  800420acab:	48 01 d0             	add    %rdx,%rax
  800420acae:	48 89 c3             	mov    %rax,%rbx
  800420acb1:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420acb8:	00 00 00 
  800420acbb:	ff d0                	callq  *%rax
  800420acbd:	48 98                	cltq   
  800420acbf:	48 89 c2             	mov    %rax,%rdx
  800420acc2:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420acc9:	00 
  800420acca:	48 89 c2             	mov    %rax,%rdx
  800420accd:	48 89 d0             	mov    %rdx,%rax
  800420acd0:	48 c1 e0 04          	shl    $0x4,%rax
  800420acd4:	48 29 d0             	sub    %rdx,%rax
  800420acd7:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420acdb:	48 b8 20 50 36 04 80 	movabs $0x8004365020,%rax
  800420ace2:	00 00 00 
  800420ace5:	48 01 d0             	add    %rdx,%rax
  800420ace8:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420acec:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420acf3:	00 00 00 
  800420acf6:	48 8b 00             	mov    (%rax),%rax
  800420acf9:	48 c1 f8 10          	sar    $0x10,%rax
  800420acfd:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ad01:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ad04:	c1 e0 04             	shl    $0x4,%eax
  800420ad07:	48 98                	cltq   
  800420ad09:	48 01 d0             	add    %rdx,%rax
  800420ad0c:	48 89 c3             	mov    %rax,%rbx
  800420ad0f:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420ad16:	00 00 00 
  800420ad19:	ff d0                	callq  *%rax
  800420ad1b:	48 98                	cltq   
  800420ad1d:	48 89 c2             	mov    %rax,%rdx
  800420ad20:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420ad27:	00 
  800420ad28:	48 89 c2             	mov    %rax,%rdx
  800420ad2b:	48 89 d0             	mov    %rdx,%rax
  800420ad2e:	48 c1 e0 04          	shl    $0x4,%rax
  800420ad32:	48 29 d0             	sub    %rdx,%rax
  800420ad35:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420ad39:	48 b8 20 50 36 04 80 	movabs $0x8004365020,%rax
  800420ad40:	00 00 00 
  800420ad43:	48 01 d0             	add    %rdx,%rax
  800420ad46:	48 c1 e8 10          	shr    $0x10,%rax
  800420ad4a:	88 43 04             	mov    %al,0x4(%rbx)
  800420ad4d:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420ad54:	00 00 00 
  800420ad57:	48 8b 00             	mov    (%rax),%rax
  800420ad5a:	48 c1 f8 10          	sar    $0x10,%rax
  800420ad5e:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ad62:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ad65:	c1 e0 04             	shl    $0x4,%eax
  800420ad68:	48 98                	cltq   
  800420ad6a:	48 01 d0             	add    %rdx,%rax
  800420ad6d:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420ad71:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ad74:	83 ca 09             	or     $0x9,%edx
  800420ad77:	88 50 05             	mov    %dl,0x5(%rax)
  800420ad7a:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420ad81:	00 00 00 
  800420ad84:	48 8b 00             	mov    (%rax),%rax
  800420ad87:	48 c1 f8 10          	sar    $0x10,%rax
  800420ad8b:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ad8f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ad92:	c1 e0 04             	shl    $0x4,%eax
  800420ad95:	48 98                	cltq   
  800420ad97:	48 01 d0             	add    %rdx,%rax
  800420ad9a:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420ad9e:	83 e2 ef             	and    $0xffffffef,%edx
  800420ada1:	88 50 05             	mov    %dl,0x5(%rax)
  800420ada4:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420adab:	00 00 00 
  800420adae:	48 8b 00             	mov    (%rax),%rax
  800420adb1:	48 c1 f8 10          	sar    $0x10,%rax
  800420adb5:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420adb9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420adbc:	c1 e0 04             	shl    $0x4,%eax
  800420adbf:	48 98                	cltq   
  800420adc1:	48 01 d0             	add    %rdx,%rax
  800420adc4:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420adc8:	83 e2 9f             	and    $0xffffff9f,%edx
  800420adcb:	88 50 05             	mov    %dl,0x5(%rax)
  800420adce:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420add5:	00 00 00 
  800420add8:	48 8b 00             	mov    (%rax),%rax
  800420addb:	48 c1 f8 10          	sar    $0x10,%rax
  800420addf:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ade3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ade6:	c1 e0 04             	shl    $0x4,%eax
  800420ade9:	48 98                	cltq   
  800420adeb:	48 01 d0             	add    %rdx,%rax
  800420adee:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420adf2:	83 ca 80             	or     $0xffffff80,%edx
  800420adf5:	88 50 05             	mov    %dl,0x5(%rax)
  800420adf8:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420adff:	00 00 00 
  800420ae02:	48 8b 00             	mov    (%rax),%rax
  800420ae05:	48 c1 f8 10          	sar    $0x10,%rax
  800420ae09:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ae0d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ae10:	c1 e0 04             	shl    $0x4,%eax
  800420ae13:	48 98                	cltq   
  800420ae15:	48 01 d0             	add    %rdx,%rax
  800420ae18:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420ae1c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ae1f:	88 50 06             	mov    %dl,0x6(%rax)
  800420ae22:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420ae29:	00 00 00 
  800420ae2c:	48 8b 00             	mov    (%rax),%rax
  800420ae2f:	48 c1 f8 10          	sar    $0x10,%rax
  800420ae33:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ae37:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ae3a:	c1 e0 04             	shl    $0x4,%eax
  800420ae3d:	48 98                	cltq   
  800420ae3f:	48 01 d0             	add    %rdx,%rax
  800420ae42:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420ae46:	83 e2 ef             	and    $0xffffffef,%edx
  800420ae49:	88 50 06             	mov    %dl,0x6(%rax)
  800420ae4c:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420ae53:	00 00 00 
  800420ae56:	48 8b 00             	mov    (%rax),%rax
  800420ae59:	48 c1 f8 10          	sar    $0x10,%rax
  800420ae5d:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ae61:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ae64:	c1 e0 04             	shl    $0x4,%eax
  800420ae67:	48 98                	cltq   
  800420ae69:	48 01 d0             	add    %rdx,%rax
  800420ae6c:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420ae70:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ae73:	88 50 06             	mov    %dl,0x6(%rax)
  800420ae76:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420ae7d:	00 00 00 
  800420ae80:	48 8b 00             	mov    (%rax),%rax
  800420ae83:	48 c1 f8 10          	sar    $0x10,%rax
  800420ae87:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ae8b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ae8e:	c1 e0 04             	shl    $0x4,%eax
  800420ae91:	48 98                	cltq   
  800420ae93:	48 01 d0             	add    %rdx,%rax
  800420ae96:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420ae9a:	83 e2 7f             	and    $0x7f,%edx
  800420ae9d:	88 50 06             	mov    %dl,0x6(%rax)
  800420aea0:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420aea7:	00 00 00 
  800420aeaa:	48 8b 00             	mov    (%rax),%rax
  800420aead:	48 c1 f8 10          	sar    $0x10,%rax
  800420aeb1:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420aeb5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420aeb8:	c1 e0 04             	shl    $0x4,%eax
  800420aebb:	48 98                	cltq   
  800420aebd:	48 01 d0             	add    %rdx,%rax
  800420aec0:	48 89 c3             	mov    %rax,%rbx
  800420aec3:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420aeca:	00 00 00 
  800420aecd:	ff d0                	callq  *%rax
  800420aecf:	48 98                	cltq   
  800420aed1:	48 89 c2             	mov    %rax,%rdx
  800420aed4:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420aedb:	00 
  800420aedc:	48 89 c2             	mov    %rax,%rdx
  800420aedf:	48 89 d0             	mov    %rdx,%rax
  800420aee2:	48 c1 e0 04          	shl    $0x4,%rax
  800420aee6:	48 29 d0             	sub    %rdx,%rax
  800420aee9:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420aeed:	48 b8 20 50 36 04 80 	movabs $0x8004365020,%rax
  800420aef4:	00 00 00 
  800420aef7:	48 01 d0             	add    %rdx,%rax
  800420aefa:	48 c1 e8 18          	shr    $0x18,%rax
  800420aefe:	88 43 07             	mov    %al,0x7(%rbx)
  800420af01:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420af08:	00 00 00 
  800420af0b:	48 8b 00             	mov    (%rax),%rax
  800420af0e:	48 c1 f8 10          	sar    $0x10,%rax
  800420af12:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420af16:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420af19:	c1 e0 04             	shl    $0x4,%eax
  800420af1c:	48 98                	cltq   
  800420af1e:	48 01 d0             	add    %rdx,%rax
  800420af21:	48 89 c3             	mov    %rax,%rbx
  800420af24:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420af2b:	00 00 00 
  800420af2e:	ff d0                	callq  *%rax
  800420af30:	48 98                	cltq   
  800420af32:	48 89 c2             	mov    %rax,%rdx
  800420af35:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420af3c:	00 
  800420af3d:	48 89 c2             	mov    %rax,%rdx
  800420af40:	48 89 d0             	mov    %rdx,%rax
  800420af43:	48 c1 e0 04          	shl    $0x4,%rax
  800420af47:	48 29 d0             	sub    %rdx,%rax
  800420af4a:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420af4e:	48 b8 20 50 36 04 80 	movabs $0x8004365020,%rax
  800420af55:	00 00 00 
  800420af58:	48 01 d0             	add    %rdx,%rax
  800420af5b:	48 c1 e8 20          	shr    $0x20,%rax
  800420af5f:	89 43 08             	mov    %eax,0x8(%rbx)
  800420af62:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420af69:	00 00 00 
  800420af6c:	48 8b 00             	mov    (%rax),%rax
  800420af6f:	48 c1 f8 10          	sar    $0x10,%rax
  800420af73:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420af77:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420af7a:	c1 e0 04             	shl    $0x4,%eax
  800420af7d:	48 98                	cltq   
  800420af7f:	48 01 d0             	add    %rdx,%rax
  800420af82:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420af86:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420af8d:	00 00 00 
  800420af90:	48 8b 00             	mov    (%rax),%rax
  800420af93:	48 c1 f8 10          	sar    $0x10,%rax
  800420af97:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420af9b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420af9e:	c1 e0 04             	shl    $0x4,%eax
  800420afa1:	48 98                	cltq   
  800420afa3:	48 01 d0             	add    %rdx,%rax
  800420afa6:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420afaa:	48 b8 88 b6 22 04 80 	movabs $0x800422b688,%rax
  800420afb1:	00 00 00 
  800420afb4:	48 8b 00             	mov    (%rax),%rax
  800420afb7:	48 c1 f8 10          	sar    $0x10,%rax
  800420afbb:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420afbf:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420afc2:	c1 e0 04             	shl    $0x4,%eax
  800420afc5:	48 98                	cltq   
  800420afc7:	48 01 d0             	add    %rdx,%rax
  800420afca:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)

	gdt[(GD_TSS0>>3)+(2*cpu_id)].sd_s = 0;
  800420afd0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420afd3:	01 c0                	add    %eax,%eax
  800420afd5:	8d 50 05             	lea    0x5(%rax),%edx
  800420afd8:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420afdf:	00 00 00 
  800420afe2:	48 63 d2             	movslq %edx,%rdx
  800420afe5:	0f b6 4c d0 05       	movzbl 0x5(%rax,%rdx,8),%ecx
  800420afea:	83 e1 ef             	and    $0xffffffef,%ecx
  800420afed:	88 4c d0 05          	mov    %cl,0x5(%rax,%rdx,8)

	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(GD_TSS0+(cpu_id*16));
  800420aff1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420aff4:	c1 e0 04             	shl    $0x4,%eax
  800420aff7:	83 c0 28             	add    $0x28,%eax
  800420affa:	0f b7 c0             	movzwl %ax,%eax
  800420affd:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420b001:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  800420b005:	0f 00 d8             	ltr    %ax
  800420b008:	48 b8 80 32 36 04 80 	movabs $0x8004363280,%rax
  800420b00f:	00 00 00 
  800420b012:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420b016:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420b01a:	0f 01 18             	lidt   (%rax)

	// Load the IDT
	lidt(&idt_pd);
}
  800420b01d:	90                   	nop
  800420b01e:	48 83 c4 18          	add    $0x18,%rsp
  800420b022:	5b                   	pop    %rbx
  800420b023:	5d                   	pop    %rbp
  800420b024:	c3                   	retq   

000000800420b025 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420b025:	55                   	push   %rbp
  800420b026:	48 89 e5             	mov    %rsp,%rbp
  800420b029:	48 83 ec 20          	sub    $0x20,%rsp
  800420b02d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420b031:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420b038:	00 00 00 
  800420b03b:	ff d0                	callq  *%rax
  800420b03d:	89 c2                	mov    %eax,%edx
  800420b03f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b043:	48 89 c6             	mov    %rax,%rsi
  800420b046:	48 bf 2e 76 21 04 80 	movabs $0x800421762e,%rdi
  800420b04d:	00 00 00 
  800420b050:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b055:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  800420b05c:	00 00 00 
  800420b05f:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420b061:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b065:	48 89 c7             	mov    %rax,%rdi
  800420b068:	48 b8 37 b3 20 04 80 	movabs $0x800420b337,%rax
  800420b06f:	00 00 00 
  800420b072:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420b074:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b078:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420b07c:	0f b7 c0             	movzwl %ax,%eax
  800420b07f:	89 c6                	mov    %eax,%esi
  800420b081:	48 bf 4c 76 21 04 80 	movabs $0x800421764c,%rdi
  800420b088:	00 00 00 
  800420b08b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b090:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b097:	00 00 00 
  800420b09a:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420b09c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b0a0:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420b0a7:	0f b7 c0             	movzwl %ax,%eax
  800420b0aa:	89 c6                	mov    %eax,%esi
  800420b0ac:	48 bf 5f 76 21 04 80 	movabs $0x800421765f,%rdi
  800420b0b3:	00 00 00 
  800420b0b6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b0bb:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b0c2:	00 00 00 
  800420b0c5:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420b0c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b0cb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b0d2:	89 c7                	mov    %eax,%edi
  800420b0d4:	48 b8 24 8f 20 04 80 	movabs $0x8004208f24,%rax
  800420b0db:	00 00 00 
  800420b0de:	ff d0                	callq  *%rax
  800420b0e0:	48 89 c2             	mov    %rax,%rdx
  800420b0e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b0e7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b0ee:	48 89 c6             	mov    %rax,%rsi
  800420b0f1:	48 bf 72 76 21 04 80 	movabs $0x8004217672,%rdi
  800420b0f8:	00 00 00 
  800420b0fb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b100:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  800420b107:	00 00 00 
  800420b10a:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420b10c:	48 b8 90 32 36 04 80 	movabs $0x8004363290,%rax
  800420b113:	00 00 00 
  800420b116:	48 8b 00             	mov    (%rax),%rax
  800420b119:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420b11d:	75 3a                	jne    800420b159 <print_trapframe+0x134>
  800420b11f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b123:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b12a:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b12e:	75 29                	jne    800420b159 <print_trapframe+0x134>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420b130:	0f 20 d0             	mov    %cr2,%rax
  800420b133:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return val;
  800420b137:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420b13b:	48 89 c6             	mov    %rax,%rsi
  800420b13e:	48 bf 84 76 21 04 80 	movabs $0x8004217684,%rdi
  800420b145:	00 00 00 
  800420b148:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b14d:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b154:	00 00 00 
  800420b157:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420b159:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b15d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b164:	48 89 c6             	mov    %rax,%rsi
  800420b167:	48 bf 93 76 21 04 80 	movabs $0x8004217693,%rdi
  800420b16e:	00 00 00 
  800420b171:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b176:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b17d:	00 00 00 
  800420b180:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420b182:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b186:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b18d:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b191:	0f 85 9c 00 00 00    	jne    800420b233 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420b197:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b19b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b1a2:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b1a5:	48 85 c0             	test   %rax,%rax
  800420b1a8:	74 0c                	je     800420b1b6 <print_trapframe+0x191>
  800420b1aa:	48 b9 a1 76 21 04 80 	movabs $0x80042176a1,%rcx
  800420b1b1:	00 00 00 
  800420b1b4:	eb 0a                	jmp    800420b1c0 <print_trapframe+0x19b>
  800420b1b6:	48 b9 ac 76 21 04 80 	movabs $0x80042176ac,%rcx
  800420b1bd:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420b1c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b1c4:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b1cb:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b1ce:	48 85 c0             	test   %rax,%rax
  800420b1d1:	74 0c                	je     800420b1df <print_trapframe+0x1ba>
  800420b1d3:	48 ba b8 76 21 04 80 	movabs $0x80042176b8,%rdx
  800420b1da:	00 00 00 
  800420b1dd:	eb 0a                	jmp    800420b1e9 <print_trapframe+0x1c4>
  800420b1df:	48 ba be 76 21 04 80 	movabs $0x80042176be,%rdx
  800420b1e6:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420b1e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b1ed:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420b1f4:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420b1f7:	48 85 c0             	test   %rax,%rax
  800420b1fa:	74 0c                	je     800420b208 <print_trapframe+0x1e3>
  800420b1fc:	48 b8 c3 76 21 04 80 	movabs $0x80042176c3,%rax
  800420b203:	00 00 00 
  800420b206:	eb 0a                	jmp    800420b212 <print_trapframe+0x1ed>
  800420b208:	48 b8 c8 76 21 04 80 	movabs $0x80042176c8,%rax
  800420b20f:	00 00 00 
  800420b212:	48 89 c6             	mov    %rax,%rsi
  800420b215:	48 bf cf 76 21 04 80 	movabs $0x80042176cf,%rdi
  800420b21c:	00 00 00 
  800420b21f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b224:	49 b8 0a 8e 20 04 80 	movabs $0x8004208e0a,%r8
  800420b22b:	00 00 00 
  800420b22e:	41 ff d0             	callq  *%r8
  800420b231:	eb 1b                	jmp    800420b24e <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420b233:	48 bf de 76 21 04 80 	movabs $0x80042176de,%rdi
  800420b23a:	00 00 00 
  800420b23d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b242:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b249:	00 00 00 
  800420b24c:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420b24e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b252:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420b259:	48 89 c6             	mov    %rax,%rsi
  800420b25c:	48 bf e0 76 21 04 80 	movabs $0x80042176e0,%rdi
  800420b263:	00 00 00 
  800420b266:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b26b:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b272:	00 00 00 
  800420b275:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420b277:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b27b:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b282:	0f b7 c0             	movzwl %ax,%eax
  800420b285:	89 c6                	mov    %eax,%esi
  800420b287:	48 bf ef 76 21 04 80 	movabs $0x80042176ef,%rdi
  800420b28e:	00 00 00 
  800420b291:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b296:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b29d:	00 00 00 
  800420b2a0:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420b2a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b2a6:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420b2ad:	48 89 c6             	mov    %rax,%rsi
  800420b2b0:	48 bf 02 77 21 04 80 	movabs $0x8004217702,%rdi
  800420b2b7:	00 00 00 
  800420b2ba:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b2bf:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b2c6:	00 00 00 
  800420b2c9:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420b2cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b2cf:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b2d6:	0f b7 c0             	movzwl %ax,%eax
  800420b2d9:	83 e0 03             	and    $0x3,%eax
  800420b2dc:	85 c0                	test   %eax,%eax
  800420b2de:	74 54                	je     800420b334 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420b2e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b2e4:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420b2eb:	48 89 c6             	mov    %rax,%rsi
  800420b2ee:	48 bf 11 77 21 04 80 	movabs $0x8004217711,%rdi
  800420b2f5:	00 00 00 
  800420b2f8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b2fd:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b304:	00 00 00 
  800420b307:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420b309:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b30d:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420b314:	0f b7 c0             	movzwl %ax,%eax
  800420b317:	89 c6                	mov    %eax,%esi
  800420b319:	48 bf 20 77 21 04 80 	movabs $0x8004217720,%rdi
  800420b320:	00 00 00 
  800420b323:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b328:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b32f:	00 00 00 
  800420b332:	ff d2                	callq  *%rdx
	}
}
  800420b334:	90                   	nop
  800420b335:	c9                   	leaveq 
  800420b336:	c3                   	retq   

000000800420b337 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420b337:	55                   	push   %rbp
  800420b338:	48 89 e5             	mov    %rsp,%rbp
  800420b33b:	48 83 ec 10          	sub    $0x10,%rsp
  800420b33f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420b343:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b347:	48 8b 00             	mov    (%rax),%rax
  800420b34a:	48 89 c6             	mov    %rax,%rsi
  800420b34d:	48 bf 33 77 21 04 80 	movabs $0x8004217733,%rdi
  800420b354:	00 00 00 
  800420b357:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b35c:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b363:	00 00 00 
  800420b366:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420b368:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b36c:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b370:	48 89 c6             	mov    %rax,%rsi
  800420b373:	48 bf 42 77 21 04 80 	movabs $0x8004217742,%rdi
  800420b37a:	00 00 00 
  800420b37d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b382:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b389:	00 00 00 
  800420b38c:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420b38e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b392:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420b396:	48 89 c6             	mov    %rax,%rsi
  800420b399:	48 bf 51 77 21 04 80 	movabs $0x8004217751,%rdi
  800420b3a0:	00 00 00 
  800420b3a3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b3a8:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b3af:	00 00 00 
  800420b3b2:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420b3b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b3b8:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420b3bc:	48 89 c6             	mov    %rax,%rsi
  800420b3bf:	48 bf 60 77 21 04 80 	movabs $0x8004217760,%rdi
  800420b3c6:	00 00 00 
  800420b3c9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b3ce:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b3d5:	00 00 00 
  800420b3d8:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420b3da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b3de:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420b3e2:	48 89 c6             	mov    %rax,%rsi
  800420b3e5:	48 bf 6f 77 21 04 80 	movabs $0x800421776f,%rdi
  800420b3ec:	00 00 00 
  800420b3ef:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b3f4:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b3fb:	00 00 00 
  800420b3fe:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420b400:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b404:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420b408:	48 89 c6             	mov    %rax,%rsi
  800420b40b:	48 bf 7e 77 21 04 80 	movabs $0x800421777e,%rdi
  800420b412:	00 00 00 
  800420b415:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b41a:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b421:	00 00 00 
  800420b424:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420b426:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b42a:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420b42e:	48 89 c6             	mov    %rax,%rsi
  800420b431:	48 bf 8d 77 21 04 80 	movabs $0x800421778d,%rdi
  800420b438:	00 00 00 
  800420b43b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b440:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b447:	00 00 00 
  800420b44a:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420b44c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b450:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420b454:	48 89 c6             	mov    %rax,%rsi
  800420b457:	48 bf 9b 77 21 04 80 	movabs $0x800421779b,%rdi
  800420b45e:	00 00 00 
  800420b461:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b466:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b46d:	00 00 00 
  800420b470:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420b472:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b476:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420b47a:	48 89 c6             	mov    %rax,%rsi
  800420b47d:	48 bf a9 77 21 04 80 	movabs $0x80042177a9,%rdi
  800420b484:	00 00 00 
  800420b487:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b48c:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b493:	00 00 00 
  800420b496:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420b498:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b49c:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420b4a0:	48 89 c6             	mov    %rax,%rsi
  800420b4a3:	48 bf b8 77 21 04 80 	movabs $0x80042177b8,%rdi
  800420b4aa:	00 00 00 
  800420b4ad:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b4b2:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b4b9:	00 00 00 
  800420b4bc:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420b4be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b4c2:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420b4c6:	48 89 c6             	mov    %rax,%rsi
  800420b4c9:	48 bf c7 77 21 04 80 	movabs $0x80042177c7,%rdi
  800420b4d0:	00 00 00 
  800420b4d3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b4d8:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b4df:	00 00 00 
  800420b4e2:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420b4e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b4e8:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420b4ec:	48 89 c6             	mov    %rax,%rsi
  800420b4ef:	48 bf d6 77 21 04 80 	movabs $0x80042177d6,%rdi
  800420b4f6:	00 00 00 
  800420b4f9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b4fe:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b505:	00 00 00 
  800420b508:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420b50a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b50e:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420b512:	48 89 c6             	mov    %rax,%rsi
  800420b515:	48 bf e5 77 21 04 80 	movabs $0x80042177e5,%rdi
  800420b51c:	00 00 00 
  800420b51f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b524:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b52b:	00 00 00 
  800420b52e:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420b530:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b534:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420b538:	48 89 c6             	mov    %rax,%rsi
  800420b53b:	48 bf f4 77 21 04 80 	movabs $0x80042177f4,%rdi
  800420b542:	00 00 00 
  800420b545:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b54a:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b551:	00 00 00 
  800420b554:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420b556:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b55a:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b55e:	48 89 c6             	mov    %rax,%rsi
  800420b561:	48 bf 03 78 21 04 80 	movabs $0x8004217803,%rdi
  800420b568:	00 00 00 
  800420b56b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b570:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b577:	00 00 00 
  800420b57a:	ff d2                	callq  *%rdx
}
  800420b57c:	90                   	nop
  800420b57d:	c9                   	leaveq 
  800420b57e:	c3                   	retq   

000000800420b57f <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420b57f:	55                   	push   %rbp
  800420b580:	48 89 e5             	mov    %rsp,%rbp
  800420b583:	48 83 ec 40          	sub    $0x40,%rsp
  800420b587:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	// Handle processor exceptions.
	// LAB 3: Your code here.
	
	if (tf->tf_trapno == T_PGFLT) {
  800420b58b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b58f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b596:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b59a:	75 18                	jne    800420b5b4 <trap_dispatch+0x35>
		page_fault_handler(tf);
  800420b59c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b5a0:	48 89 c7             	mov    %rax,%rdi
  800420b5a3:	48 b8 42 bb 20 04 80 	movabs $0x800420bb42,%rax
  800420b5aa:	00 00 00 
  800420b5ad:	ff d0                	callq  *%rax
		return;
  800420b5af:	e9 c3 01 00 00       	jmpq   800420b777 <trap_dispatch+0x1f8>
	}
	if (tf->tf_trapno ==T_BRKPT){
  800420b5b4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b5b8:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b5bf:	48 83 f8 03          	cmp    $0x3,%rax
  800420b5c3:	75 13                	jne    800420b5d8 <trap_dispatch+0x59>
		monitor(tf);
  800420b5c5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b5c9:	48 89 c7             	mov    %rax,%rdi
  800420b5cc:	48 b8 4e 18 20 04 80 	movabs $0x800420184e,%rax
  800420b5d3:	00 00 00 
  800420b5d6:	ff d0                	callq  *%rax
	}
	if (tf->tf_trapno==T_SYSCALL){
  800420b5d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b5dc:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b5e3:	48 83 f8 30          	cmp    $0x30,%rax
  800420b5e7:	0f 85 85 00 00 00    	jne    800420b672 <trap_dispatch+0xf3>
		uint64_t call_num = tf->tf_regs.reg_rax;
  800420b5ed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b5f1:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b5f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		uint64_t arg1 = tf->tf_regs.reg_rdx;
  800420b5f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b5fd:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420b601:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		uint64_t arg2 = tf->tf_regs.reg_rcx;
  800420b605:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b609:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420b60d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		uint64_t arg3 = tf->tf_regs.reg_rbx;
  800420b611:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b615:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420b619:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		uint64_t arg4 = tf->tf_regs.reg_rdi;
  800420b61d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b621:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420b625:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		uint64_t arg5 = tf->tf_regs.reg_rsi;
  800420b629:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b62d:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420b631:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		
		tf->tf_regs.reg_rax = syscall(call_num, arg1, arg2, arg3, arg4, arg5);
  800420b635:	4c 8b 45 d0          	mov    -0x30(%rbp),%r8
  800420b639:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  800420b63d:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420b641:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420b645:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420b649:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b64d:	4d 89 c1             	mov    %r8,%r9
  800420b650:	49 89 f8             	mov    %rdi,%r8
  800420b653:	48 89 c7             	mov    %rax,%rdi
  800420b656:	48 b8 f1 cf 20 04 80 	movabs $0x800420cff1,%rax
  800420b65d:	00 00 00 
  800420b660:	ff d0                	callq  *%rax
  800420b662:	48 89 c2             	mov    %rax,%rdx
  800420b665:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b669:	48 89 50 70          	mov    %rdx,0x70(%rax)
		return;
  800420b66d:	e9 05 01 00 00       	jmpq   800420b777 <trap_dispatch+0x1f8>


	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420b672:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b676:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b67d:	48 83 f8 27          	cmp    $0x27,%rax
  800420b681:	75 33                	jne    800420b6b6 <trap_dispatch+0x137>
		cprintf("Spurious interrupt on irq 7\n");
  800420b683:	48 bf 12 78 21 04 80 	movabs $0x8004217812,%rdi
  800420b68a:	00 00 00 
  800420b68d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b692:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420b699:	00 00 00 
  800420b69c:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420b69e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b6a2:	48 89 c7             	mov    %rax,%rdi
  800420b6a5:	48 b8 25 b0 20 04 80 	movabs $0x800420b025,%rax
  800420b6ac:	00 00 00 
  800420b6af:	ff d0                	callq  *%rax
		return;
  800420b6b1:	e9 c1 00 00 00       	jmpq   800420b777 <trap_dispatch+0x1f8>

	// Handle clock interrupts. Don't forget to acknowledge the
	// interrupt using lapic_eoi() before calling the scheduler!
	// LAB 4: Your code here.

	if (tf->tf_trapno==IRQ_OFFSET+IRQ_TIMER){
  800420b6b6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b6ba:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b6c1:	48 83 f8 20          	cmp    $0x20,%rax
  800420b6c5:	75 18                	jne    800420b6df <trap_dispatch+0x160>
		lapic_eoi();
  800420b6c7:	48 b8 a8 5b 21 04 80 	movabs $0x8004215ba8,%rax
  800420b6ce:	00 00 00 
  800420b6d1:	ff d0                	callq  *%rax
		sched_yield();
  800420b6d3:	48 b8 2e c1 20 04 80 	movabs $0x800420c12e,%rax
  800420b6da:	00 00 00 
  800420b6dd:	ff d0                	callq  *%rax
		return;
	}	 

	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420b6df:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b6e3:	48 89 c7             	mov    %rax,%rdi
  800420b6e6:	48 b8 25 b0 20 04 80 	movabs $0x800420b025,%rax
  800420b6ed:	00 00 00 
  800420b6f0:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420b6f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420b6f6:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b6fd:	66 83 f8 08          	cmp    $0x8,%ax
  800420b701:	75 2a                	jne    800420b72d <trap_dispatch+0x1ae>
		panic("unhandled trap in kernel");
  800420b703:	48 ba 2f 78 21 04 80 	movabs $0x800421782f,%rdx
  800420b70a:	00 00 00 
  800420b70d:	be 3b 01 00 00       	mov    $0x13b,%esi
  800420b712:	48 bf 48 78 21 04 80 	movabs $0x8004217848,%rdi
  800420b719:	00 00 00 
  800420b71c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b721:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  800420b728:	00 00 00 
  800420b72b:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420b72d:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420b734:	00 00 00 
  800420b737:	ff d0                	callq  *%rax
  800420b739:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420b740:	00 00 00 
  800420b743:	48 98                	cltq   
  800420b745:	48 89 c2             	mov    %rax,%rdx
  800420b748:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420b74f:	00 
  800420b750:	48 89 c2             	mov    %rax,%rdx
  800420b753:	48 89 d0             	mov    %rdx,%rax
  800420b756:	48 c1 e0 04          	shl    $0x4,%rax
  800420b75a:	48 29 d0             	sub    %rdx,%rax
  800420b75d:	48 01 c8             	add    %rcx,%rax
  800420b760:	48 83 c0 08          	add    $0x8,%rax
  800420b764:	48 8b 00             	mov    (%rax),%rax
  800420b767:	48 89 c7             	mov    %rax,%rdi
  800420b76a:	48 b8 61 86 20 04 80 	movabs $0x8004208661,%rax
  800420b771:	00 00 00 
  800420b774:	ff d0                	callq  *%rax
		return;
  800420b776:	90                   	nop
	}
}
  800420b777:	c9                   	leaveq 
  800420b778:	c3                   	retq   

000000800420b779 <trap>:

void
trap(struct Trapframe *tf)
{
  800420b779:	55                   	push   %rbp
  800420b77a:	48 89 e5             	mov    %rsp,%rbp
  800420b77d:	48 83 ec 20          	sub    $0x20,%rsp
  800420b781:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420b785:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420b786:	48 b8 10 37 36 04 80 	movabs $0x8004363710,%rax
  800420b78d:	00 00 00 
  800420b790:	48 8b 00             	mov    (%rax),%rax
  800420b793:	48 85 c0             	test   %rax,%rax
  800420b796:	74 01                	je     800420b799 <trap+0x20>
		asm volatile("hlt");
  800420b798:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420b799:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420b7a0:	00 00 00 
  800420b7a3:	ff d0                	callq  *%rax
  800420b7a5:	48 98                	cltq   
  800420b7a7:	48 89 c2             	mov    %rax,%rdx
  800420b7aa:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420b7b1:	00 
  800420b7b2:	48 89 c2             	mov    %rax,%rdx
  800420b7b5:	48 89 d0             	mov    %rdx,%rax
  800420b7b8:	48 c1 e0 04          	shl    $0x4,%rax
  800420b7bc:	48 29 d0             	sub    %rdx,%rax
  800420b7bf:	48 ba 20 50 36 04 80 	movabs $0x8004365020,%rdx
  800420b7c6:	00 00 00 
  800420b7c9:	48 01 d0             	add    %rdx,%rax
  800420b7cc:	48 83 c0 04          	add    $0x4,%rax
  800420b7d0:	be 01 00 00 00       	mov    $0x1,%esi
  800420b7d5:	48 89 c7             	mov    %rax,%rdi
  800420b7d8:	48 b8 e2 8e 20 04 80 	movabs $0x8004208ee2,%rax
  800420b7df:	00 00 00 
  800420b7e2:	ff d0                	callq  *%rax
  800420b7e4:	83 f8 02             	cmp    $0x2,%eax
  800420b7e7:	75 0c                	jne    800420b7f5 <trap+0x7c>
		lock_kernel();
  800420b7e9:	48 b8 07 8f 20 04 80 	movabs $0x8004208f07,%rax
  800420b7f0:	00 00 00 
  800420b7f3:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
	uint64_t rflags;
	__asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420b7f5:	9c                   	pushfq 
  800420b7f6:	58                   	pop    %rax
  800420b7f7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return rflags;
  800420b7fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420b7ff:	25 00 02 00 00       	and    $0x200,%eax
  800420b804:	48 85 c0             	test   %rax,%rax
  800420b807:	74 35                	je     800420b83e <trap+0xc5>
  800420b809:	48 b9 54 78 21 04 80 	movabs $0x8004217854,%rcx
  800420b810:	00 00 00 
  800420b813:	48 ba 6d 78 21 04 80 	movabs $0x800421786d,%rdx
  800420b81a:	00 00 00 
  800420b81d:	be 56 01 00 00       	mov    $0x156,%esi
  800420b822:	48 bf 48 78 21 04 80 	movabs $0x8004217848,%rdi
  800420b829:	00 00 00 
  800420b82c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b831:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420b838:	00 00 00 
  800420b83b:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420b83e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b842:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b849:	0f b7 c0             	movzwl %ax,%eax
  800420b84c:	83 e0 03             	and    $0x3,%eax
  800420b84f:	83 f8 03             	cmp    $0x3,%eax
  800420b852:	0f 85 e9 01 00 00    	jne    800420ba41 <trap+0x2c8>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420b858:	48 b8 07 8f 20 04 80 	movabs $0x8004208f07,%rax
  800420b85f:	00 00 00 
  800420b862:	ff d0                	callq  *%rax

		assert(curenv);
  800420b864:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420b86b:	00 00 00 
  800420b86e:	ff d0                	callq  *%rax
  800420b870:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420b877:	00 00 00 
  800420b87a:	48 98                	cltq   
  800420b87c:	48 89 c2             	mov    %rax,%rdx
  800420b87f:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420b886:	00 
  800420b887:	48 89 c2             	mov    %rax,%rdx
  800420b88a:	48 89 d0             	mov    %rdx,%rax
  800420b88d:	48 c1 e0 04          	shl    $0x4,%rax
  800420b891:	48 29 d0             	sub    %rdx,%rax
  800420b894:	48 01 c8             	add    %rcx,%rax
  800420b897:	48 83 c0 08          	add    $0x8,%rax
  800420b89b:	48 8b 00             	mov    (%rax),%rax
  800420b89e:	48 85 c0             	test   %rax,%rax
  800420b8a1:	75 35                	jne    800420b8d8 <trap+0x15f>
  800420b8a3:	48 b9 82 78 21 04 80 	movabs $0x8004217882,%rcx
  800420b8aa:	00 00 00 
  800420b8ad:	48 ba 6d 78 21 04 80 	movabs $0x800421786d,%rdx
  800420b8b4:	00 00 00 
  800420b8b7:	be 5f 01 00 00       	mov    $0x15f,%esi
  800420b8bc:	48 bf 48 78 21 04 80 	movabs $0x8004217848,%rdi
  800420b8c3:	00 00 00 
  800420b8c6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b8cb:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420b8d2:	00 00 00 
  800420b8d5:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420b8d8:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420b8df:	00 00 00 
  800420b8e2:	ff d0                	callq  *%rax
  800420b8e4:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420b8eb:	00 00 00 
  800420b8ee:	48 98                	cltq   
  800420b8f0:	48 89 c2             	mov    %rax,%rdx
  800420b8f3:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420b8fa:	00 
  800420b8fb:	48 89 c2             	mov    %rax,%rdx
  800420b8fe:	48 89 d0             	mov    %rdx,%rax
  800420b901:	48 c1 e0 04          	shl    $0x4,%rax
  800420b905:	48 29 d0             	sub    %rdx,%rax
  800420b908:	48 01 c8             	add    %rcx,%rax
  800420b90b:	48 83 c0 08          	add    $0x8,%rax
  800420b90f:	48 8b 00             	mov    (%rax),%rax
  800420b912:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420b918:	83 f8 01             	cmp    $0x1,%eax
  800420b91b:	0f 85 93 00 00 00    	jne    800420b9b4 <trap+0x23b>
			env_free(curenv);
  800420b921:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420b928:	00 00 00 
  800420b92b:	ff d0                	callq  *%rax
  800420b92d:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420b934:	00 00 00 
  800420b937:	48 98                	cltq   
  800420b939:	48 89 c2             	mov    %rax,%rdx
  800420b93c:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420b943:	00 
  800420b944:	48 89 c2             	mov    %rax,%rdx
  800420b947:	48 89 d0             	mov    %rdx,%rax
  800420b94a:	48 c1 e0 04          	shl    $0x4,%rax
  800420b94e:	48 29 d0             	sub    %rdx,%rax
  800420b951:	48 01 c8             	add    %rcx,%rax
  800420b954:	48 83 c0 08          	add    $0x8,%rax
  800420b958:	48 8b 00             	mov    (%rax),%rax
  800420b95b:	48 89 c7             	mov    %rax,%rdi
  800420b95e:	48 b8 05 81 20 04 80 	movabs $0x8004208105,%rax
  800420b965:	00 00 00 
  800420b968:	ff d0                	callq  *%rax
			curenv = NULL;
  800420b96a:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420b971:	00 00 00 
  800420b974:	ff d0                	callq  *%rax
  800420b976:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420b97d:	00 00 00 
  800420b980:	48 98                	cltq   
  800420b982:	48 89 c2             	mov    %rax,%rdx
  800420b985:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420b98c:	00 
  800420b98d:	48 89 c2             	mov    %rax,%rdx
  800420b990:	48 89 d0             	mov    %rdx,%rax
  800420b993:	48 c1 e0 04          	shl    $0x4,%rax
  800420b997:	48 29 d0             	sub    %rdx,%rax
  800420b99a:	48 01 c8             	add    %rcx,%rax
  800420b99d:	48 83 c0 08          	add    $0x8,%rax
  800420b9a1:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420b9a8:	48 b8 2e c1 20 04 80 	movabs $0x800420c12e,%rax
  800420b9af:	00 00 00 
  800420b9b2:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420b9b4:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420b9bb:	00 00 00 
  800420b9be:	ff d0                	callq  *%rax
  800420b9c0:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420b9c7:	00 00 00 
  800420b9ca:	48 98                	cltq   
  800420b9cc:	48 89 c2             	mov    %rax,%rdx
  800420b9cf:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420b9d6:	00 
  800420b9d7:	48 89 c2             	mov    %rax,%rdx
  800420b9da:	48 89 d0             	mov    %rdx,%rax
  800420b9dd:	48 c1 e0 04          	shl    $0x4,%rax
  800420b9e1:	48 29 d0             	sub    %rdx,%rax
  800420b9e4:	48 01 c8             	add    %rcx,%rax
  800420b9e7:	48 83 c0 08          	add    $0x8,%rax
  800420b9eb:	48 8b 10             	mov    (%rax),%rdx
  800420b9ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b9f2:	48 89 c6             	mov    %rax,%rsi
  800420b9f5:	b8 18 00 00 00       	mov    $0x18,%eax
  800420b9fa:	48 89 d7             	mov    %rdx,%rdi
  800420b9fd:	48 89 c1             	mov    %rax,%rcx
  800420ba00:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420ba03:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420ba0a:	00 00 00 
  800420ba0d:	ff d0                	callq  *%rax
  800420ba0f:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420ba16:	00 00 00 
  800420ba19:	48 98                	cltq   
  800420ba1b:	48 89 c2             	mov    %rax,%rdx
  800420ba1e:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420ba25:	00 
  800420ba26:	48 89 c2             	mov    %rax,%rdx
  800420ba29:	48 89 d0             	mov    %rdx,%rax
  800420ba2c:	48 c1 e0 04          	shl    $0x4,%rax
  800420ba30:	48 29 d0             	sub    %rdx,%rax
  800420ba33:	48 01 c8             	add    %rcx,%rax
  800420ba36:	48 83 c0 08          	add    $0x8,%rax
  800420ba3a:	48 8b 00             	mov    (%rax),%rax
  800420ba3d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420ba41:	48 b8 90 32 36 04 80 	movabs $0x8004363290,%rax
  800420ba48:	00 00 00 
  800420ba4b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ba4f:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420ba52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ba56:	48 89 c7             	mov    %rax,%rdi
  800420ba59:	48 b8 7f b5 20 04 80 	movabs $0x800420b57f,%rax
  800420ba60:	00 00 00 
  800420ba63:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420ba65:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420ba6c:	00 00 00 
  800420ba6f:	ff d0                	callq  *%rax
  800420ba71:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420ba78:	00 00 00 
  800420ba7b:	48 98                	cltq   
  800420ba7d:	48 89 c2             	mov    %rax,%rdx
  800420ba80:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420ba87:	00 
  800420ba88:	48 89 c2             	mov    %rax,%rdx
  800420ba8b:	48 89 d0             	mov    %rdx,%rax
  800420ba8e:	48 c1 e0 04          	shl    $0x4,%rax
  800420ba92:	48 29 d0             	sub    %rdx,%rax
  800420ba95:	48 01 c8             	add    %rcx,%rax
  800420ba98:	48 83 c0 08          	add    $0x8,%rax
  800420ba9c:	48 8b 00             	mov    (%rax),%rax
  800420ba9f:	48 85 c0             	test   %rax,%rax
  800420baa2:	0f 84 8e 00 00 00    	je     800420bb36 <trap+0x3bd>
  800420baa8:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420baaf:	00 00 00 
  800420bab2:	ff d0                	callq  *%rax
  800420bab4:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420babb:	00 00 00 
  800420babe:	48 98                	cltq   
  800420bac0:	48 89 c2             	mov    %rax,%rdx
  800420bac3:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420baca:	00 
  800420bacb:	48 89 c2             	mov    %rax,%rdx
  800420bace:	48 89 d0             	mov    %rdx,%rax
  800420bad1:	48 c1 e0 04          	shl    $0x4,%rax
  800420bad5:	48 29 d0             	sub    %rdx,%rax
  800420bad8:	48 01 c8             	add    %rcx,%rax
  800420badb:	48 83 c0 08          	add    $0x8,%rax
  800420badf:	48 8b 00             	mov    (%rax),%rax
  800420bae2:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bae8:	83 f8 03             	cmp    $0x3,%eax
  800420baeb:	75 49                	jne    800420bb36 <trap+0x3bd>
		env_run(curenv);
  800420baed:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420baf4:	00 00 00 
  800420baf7:	ff d0                	callq  *%rax
  800420baf9:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420bb00:	00 00 00 
  800420bb03:	48 98                	cltq   
  800420bb05:	48 89 c2             	mov    %rax,%rdx
  800420bb08:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420bb0f:	00 
  800420bb10:	48 89 c2             	mov    %rax,%rdx
  800420bb13:	48 89 d0             	mov    %rdx,%rax
  800420bb16:	48 c1 e0 04          	shl    $0x4,%rax
  800420bb1a:	48 29 d0             	sub    %rdx,%rax
  800420bb1d:	48 01 c8             	add    %rcx,%rax
  800420bb20:	48 83 c0 08          	add    $0x8,%rax
  800420bb24:	48 8b 00             	mov    (%rax),%rax
  800420bb27:	48 89 c7             	mov    %rax,%rdi
  800420bb2a:	48 b8 54 88 20 04 80 	movabs $0x8004208854,%rax
  800420bb31:	00 00 00 
  800420bb34:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420bb36:	48 b8 2e c1 20 04 80 	movabs $0x800420c12e,%rax
  800420bb3d:	00 00 00 
  800420bb40:	ff d0                	callq  *%rax

000000800420bb42 <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420bb42:	55                   	push   %rbp
  800420bb43:	48 89 e5             	mov    %rsp,%rbp
  800420bb46:	53                   	push   %rbx
  800420bb47:	48 83 ec 48          	sub    $0x48,%rsp
  800420bb4b:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420bb4f:	0f 20 d0             	mov    %cr2,%rax
  800420bb52:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	return val;
  800420bb56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420bb5a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	// Handle kernel-mode page faults.

	// LAB 3: Your code here.
	if ((tf->tf_cs & 0x03) == 0){
  800420bb5e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420bb62:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420bb69:	0f b7 c0             	movzwl %ax,%eax
  800420bb6c:	83 e0 03             	and    $0x3,%eax
  800420bb6f:	85 c0                	test   %eax,%eax
  800420bb71:	75 2a                	jne    800420bb9d <page_fault_handler+0x5b>
		panic("kernel mode page fault");	
  800420bb73:	48 ba 89 78 21 04 80 	movabs $0x8004217889,%rdx
  800420bb7a:	00 00 00 
  800420bb7d:	be 8d 01 00 00       	mov    $0x18d,%esi
  800420bb82:	48 bf 48 78 21 04 80 	movabs $0x8004217848,%rdi
  800420bb89:	00 00 00 
  800420bb8c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bb91:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  800420bb98:	00 00 00 
  800420bb9b:	ff d1                	callq  *%rcx
	//   To change what the user environment runs, modify 'curenv->env_tf'
	//   (the 'tf' variable points at 'curenv->env_tf').

	// LAB 4: Your code here.

	if (curenv->env_pgfault_upcall)	
  800420bb9d:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420bba4:	00 00 00 
  800420bba7:	ff d0                	callq  *%rax
  800420bba9:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420bbb0:	00 00 00 
  800420bbb3:	48 98                	cltq   
  800420bbb5:	48 89 c2             	mov    %rax,%rdx
  800420bbb8:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420bbbf:	00 
  800420bbc0:	48 89 c2             	mov    %rax,%rdx
  800420bbc3:	48 89 d0             	mov    %rdx,%rax
  800420bbc6:	48 c1 e0 04          	shl    $0x4,%rax
  800420bbca:	48 29 d0             	sub    %rdx,%rax
  800420bbcd:	48 01 c8             	add    %rcx,%rax
  800420bbd0:	48 83 c0 08          	add    $0x8,%rax
  800420bbd4:	48 8b 00             	mov    (%rax),%rax
  800420bbd7:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420bbde:	48 85 c0             	test   %rax,%rax
  800420bbe1:	0f 84 c8 02 00 00    	je     800420beaf <page_fault_handler+0x36d>
	{
		//set up new trap frame
		uint64_t old_rsp = tf->tf_rsp;
  800420bbe7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420bbeb:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420bbf2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		uint64_t new_rsp;
		
		//not first time
		if (tf->tf_rsp <= UXSTACKTOP-1 && tf->tf_rsp >= (UXSTACKTOP-PGSIZE)){
  800420bbf6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420bbfa:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420bc01:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420bc06:	48 39 c2             	cmp    %rax,%rdx
  800420bc09:	77 36                	ja     800420bc41 <page_fault_handler+0xff>
  800420bc0b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420bc0f:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420bc16:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420bc1b:	48 39 c2             	cmp    %rax,%rdx
  800420bc1e:	76 21                	jbe    800420bc41 <page_fault_handler+0xff>
			tf->tf_rsp = old_rsp - 8;
  800420bc20:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bc24:	48 8d 50 f8          	lea    -0x8(%rax),%rdx
  800420bc28:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420bc2c:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
			new_rsp = old_rsp - 8;
  800420bc33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420bc37:	48 83 e8 08          	sub    $0x8,%rax
  800420bc3b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420bc3f:	eb 19                	jmp    800420bc5a <page_fault_handler+0x118>
		}else{ //first ime
			tf->tf_rsp=UXSTACKTOP;
  800420bc41:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420bc45:	be 00 00 80 ef       	mov    $0xef800000,%esi
  800420bc4a:	48 89 b0 b0 00 00 00 	mov    %rsi,0xb0(%rax)
			new_rsp = UXSTACKTOP;
  800420bc51:	b8 00 00 80 ef       	mov    $0xef800000,%eax
  800420bc56:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		}
		
		new_rsp = new_rsp- sizeof(struct UTrapframe);
  800420bc5a:	48 81 6d e8 a0 00 00 	subq   $0xa0,-0x18(%rbp)
  800420bc61:	00 
		struct UTrapframe *uxstack;
		user_mem_assert(curenv, (void *)new_rsp,1, PTE_W);
  800420bc62:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  800420bc66:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420bc6d:	00 00 00 
  800420bc70:	ff d0                	callq  *%rax
  800420bc72:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420bc79:	00 00 00 
  800420bc7c:	48 98                	cltq   
  800420bc7e:	48 89 c2             	mov    %rax,%rdx
  800420bc81:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420bc88:	00 
  800420bc89:	48 89 c2             	mov    %rax,%rdx
  800420bc8c:	48 89 d0             	mov    %rdx,%rax
  800420bc8f:	48 c1 e0 04          	shl    $0x4,%rax
  800420bc93:	48 29 d0             	sub    %rdx,%rax
  800420bc96:	48 01 c8             	add    %rcx,%rax
  800420bc99:	48 83 c0 08          	add    $0x8,%rax
  800420bc9d:	48 8b 00             	mov    (%rax),%rax
  800420bca0:	b9 02 00 00 00       	mov    $0x2,%ecx
  800420bca5:	ba 01 00 00 00       	mov    $0x1,%edx
  800420bcaa:	48 89 de             	mov    %rbx,%rsi
  800420bcad:	48 89 c7             	mov    %rax,%rdi
  800420bcb0:	48 b8 64 3a 20 04 80 	movabs $0x8004203a64,%rax
  800420bcb7:	00 00 00 
  800420bcba:	ff d0                	callq  *%rax

		uxstack = (struct UTrapframe *)new_rsp;
  800420bcbc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bcc0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

		//put input into new stack
		uxstack->utf_fault_va = fault_va;
  800420bcc4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bcc8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420bccc:	48 89 10             	mov    %rdx,(%rax)
		uxstack->utf_err = tf->tf_err;
  800420bccf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420bcd3:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420bcda:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bcde:	48 89 50 08          	mov    %rdx,0x8(%rax)
		uxstack->utf_regs = tf->tf_regs;
  800420bce2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bce6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420bcea:	48 8b 0a             	mov    (%rdx),%rcx
  800420bced:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420bcf1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420bcf5:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420bcf9:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420bcfd:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420bd01:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420bd05:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420bd09:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420bd0d:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420bd11:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420bd15:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420bd19:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420bd1d:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420bd21:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420bd25:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420bd29:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420bd2d:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420bd31:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420bd35:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420bd39:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420bd3d:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420bd41:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420bd45:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420bd49:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420bd4d:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420bd51:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420bd55:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420bd59:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420bd5d:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		uxstack->utf_rip = tf->tf_rip;
  800420bd64:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420bd68:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420bd6f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bd73:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		uxstack->utf_eflags = tf->tf_eflags;
  800420bd7a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420bd7e:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420bd85:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bd89:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		uxstack->utf_rsp = old_rsp;
  800420bd90:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420bd94:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420bd98:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)

		//branch to curenv->env_pgfault_upcall
		curenv->env_tf.tf_rip = (uintptr_t)curenv->env_pgfault_upcall;
  800420bd9f:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420bda6:	00 00 00 
  800420bda9:	ff d0                	callq  *%rax
  800420bdab:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420bdb2:	00 00 00 
  800420bdb5:	48 98                	cltq   
  800420bdb7:	48 89 c2             	mov    %rax,%rdx
  800420bdba:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420bdc1:	00 
  800420bdc2:	48 89 c2             	mov    %rax,%rdx
  800420bdc5:	48 89 d0             	mov    %rdx,%rax
  800420bdc8:	48 c1 e0 04          	shl    $0x4,%rax
  800420bdcc:	48 29 d0             	sub    %rdx,%rax
  800420bdcf:	48 01 c8             	add    %rcx,%rax
  800420bdd2:	48 83 c0 08          	add    $0x8,%rax
  800420bdd6:	48 8b 18             	mov    (%rax),%rbx
  800420bdd9:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420bde0:	00 00 00 
  800420bde3:	ff d0                	callq  *%rax
  800420bde5:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420bdec:	00 00 00 
  800420bdef:	48 98                	cltq   
  800420bdf1:	48 89 c2             	mov    %rax,%rdx
  800420bdf4:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420bdfb:	00 
  800420bdfc:	48 89 c2             	mov    %rax,%rdx
  800420bdff:	48 89 d0             	mov    %rdx,%rax
  800420be02:	48 c1 e0 04          	shl    $0x4,%rax
  800420be06:	48 29 d0             	sub    %rdx,%rax
  800420be09:	48 01 c8             	add    %rcx,%rax
  800420be0c:	48 83 c0 08          	add    $0x8,%rax
  800420be10:	48 8b 00             	mov    (%rax),%rax
  800420be13:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420be1a:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
		curenv->env_tf.tf_rsp = new_rsp;
  800420be21:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420be28:	00 00 00 
  800420be2b:	ff d0                	callq  *%rax
  800420be2d:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420be34:	00 00 00 
  800420be37:	48 98                	cltq   
  800420be39:	48 89 c2             	mov    %rax,%rdx
  800420be3c:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420be43:	00 
  800420be44:	48 89 c2             	mov    %rax,%rdx
  800420be47:	48 89 d0             	mov    %rdx,%rax
  800420be4a:	48 c1 e0 04          	shl    $0x4,%rax
  800420be4e:	48 29 d0             	sub    %rdx,%rax
  800420be51:	48 01 c8             	add    %rcx,%rax
  800420be54:	48 83 c0 08          	add    $0x8,%rax
  800420be58:	48 8b 00             	mov    (%rax),%rax
  800420be5b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420be5f:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		env_run(curenv); 
  800420be66:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420be6d:	00 00 00 
  800420be70:	ff d0                	callq  *%rax
  800420be72:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420be79:	00 00 00 
  800420be7c:	48 98                	cltq   
  800420be7e:	48 89 c2             	mov    %rax,%rdx
  800420be81:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420be88:	00 
  800420be89:	48 89 c2             	mov    %rax,%rdx
  800420be8c:	48 89 d0             	mov    %rdx,%rax
  800420be8f:	48 c1 e0 04          	shl    $0x4,%rax
  800420be93:	48 29 d0             	sub    %rdx,%rax
  800420be96:	48 01 c8             	add    %rcx,%rax
  800420be99:	48 83 c0 08          	add    $0x8,%rax
  800420be9d:	48 8b 00             	mov    (%rax),%rax
  800420bea0:	48 89 c7             	mov    %rax,%rdi
  800420bea3:	48 b8 54 88 20 04 80 	movabs $0x8004208854,%rax
  800420beaa:	00 00 00 
  800420bead:	ff d0                	callq  *%rax
	
	}
	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420beaf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420beb3:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
		curenv->env_id, fault_va, tf->tf_rip);
  800420beba:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420bec1:	00 00 00 
  800420bec4:	ff d0                	callq  *%rax
  800420bec6:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420becd:	00 00 00 
  800420bed0:	48 98                	cltq   
  800420bed2:	48 89 c2             	mov    %rax,%rdx
  800420bed5:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420bedc:	00 
  800420bedd:	48 89 c2             	mov    %rax,%rdx
  800420bee0:	48 89 d0             	mov    %rdx,%rax
  800420bee3:	48 c1 e0 04          	shl    $0x4,%rax
  800420bee7:	48 29 d0             	sub    %rdx,%rax
  800420beea:	48 01 c8             	add    %rcx,%rax
  800420beed:	48 83 c0 08          	add    $0x8,%rax
  800420bef1:	48 8b 00             	mov    (%rax),%rax
		curenv->env_tf.tf_rsp = new_rsp;
		env_run(curenv); 
	
	}
	// Destroy the environment that caused the fault.
	cprintf("[%08x] user fault va %08x ip %08x\n",
  800420bef4:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420befa:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420befe:	48 89 d9             	mov    %rbx,%rcx
  800420bf01:	89 c6                	mov    %eax,%esi
  800420bf03:	48 bf a0 78 21 04 80 	movabs $0x80042178a0,%rdi
  800420bf0a:	00 00 00 
  800420bf0d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bf12:	49 b8 0a 8e 20 04 80 	movabs $0x8004208e0a,%r8
  800420bf19:	00 00 00 
  800420bf1c:	41 ff d0             	callq  *%r8
		curenv->env_id, fault_va, tf->tf_rip);
	print_trapframe(tf);
  800420bf1f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420bf23:	48 89 c7             	mov    %rax,%rdi
  800420bf26:	48 b8 25 b0 20 04 80 	movabs $0x800420b025,%rax
  800420bf2d:	00 00 00 
  800420bf30:	ff d0                	callq  *%rax
	env_destroy(curenv);
  800420bf32:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420bf39:	00 00 00 
  800420bf3c:	ff d0                	callq  *%rax
  800420bf3e:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420bf45:	00 00 00 
  800420bf48:	48 98                	cltq   
  800420bf4a:	48 89 c2             	mov    %rax,%rdx
  800420bf4d:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420bf54:	00 
  800420bf55:	48 89 c2             	mov    %rax,%rdx
  800420bf58:	48 89 d0             	mov    %rdx,%rax
  800420bf5b:	48 c1 e0 04          	shl    $0x4,%rax
  800420bf5f:	48 29 d0             	sub    %rdx,%rax
  800420bf62:	48 01 c8             	add    %rcx,%rax
  800420bf65:	48 83 c0 08          	add    $0x8,%rax
  800420bf69:	48 8b 00             	mov    (%rax),%rax
  800420bf6c:	48 89 c7             	mov    %rax,%rdi
  800420bf6f:	48 b8 61 86 20 04 80 	movabs $0x8004208661,%rax
  800420bf76:	00 00 00 
  800420bf79:	ff d0                	callq  *%rax
}
  800420bf7b:	90                   	nop
  800420bf7c:	48 83 c4 48          	add    $0x48,%rsp
  800420bf80:	5b                   	pop    %rbx
  800420bf81:	5d                   	pop    %rbp
  800420bf82:	c3                   	retq   
  800420bf83:	90                   	nop

000000800420bf84 <XTRAPX_divzero>:
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */

	TRAPHANDLER_NOEC(XTRAPX_divzero, T_DIVIDE)
  800420bf84:	6a 00                	pushq  $0x0
  800420bf86:	6a 00                	pushq  $0x0
  800420bf88:	e9 95 00 00 00       	jmpq   800420c022 <_alltraps>
  800420bf8d:	90                   	nop

000000800420bf8e <XTRAPX_debug>:
	TRAPHANDLER_NOEC(XTRAPX_debug, T_DEBUG)
  800420bf8e:	6a 00                	pushq  $0x0
  800420bf90:	6a 01                	pushq  $0x1
  800420bf92:	e9 8b 00 00 00       	jmpq   800420c022 <_alltraps>
  800420bf97:	90                   	nop

000000800420bf98 <XTRAPX_nonmask>:
	TRAPHANDLER_NOEC(XTRAPX_nonmask, T_NMI)
  800420bf98:	6a 00                	pushq  $0x0
  800420bf9a:	6a 02                	pushq  $0x2
  800420bf9c:	e9 81 00 00 00       	jmpq   800420c022 <_alltraps>
  800420bfa1:	90                   	nop

000000800420bfa2 <XTRAPX_breakpoint>:
	TRAPHANDLER_NOEC(XTRAPX_breakpoint, T_BRKPT)
  800420bfa2:	6a 00                	pushq  $0x0
  800420bfa4:	6a 03                	pushq  $0x3
  800420bfa6:	eb 7a                	jmp    800420c022 <_alltraps>

000000800420bfa8 <XTRAPX_overflow>:
	TRAPHANDLER_NOEC(XTRAPX_overflow, T_OFLOW)
  800420bfa8:	6a 00                	pushq  $0x0
  800420bfaa:	6a 04                	pushq  $0x4
  800420bfac:	eb 74                	jmp    800420c022 <_alltraps>

000000800420bfae <XTRAPX_bound>:
	TRAPHANDLER_NOEC(XTRAPX_bound, T_BOUND)
  800420bfae:	6a 00                	pushq  $0x0
  800420bfb0:	6a 05                	pushq  $0x5
  800420bfb2:	eb 6e                	jmp    800420c022 <_alltraps>

000000800420bfb4 <XTRAPX_illop>:
	TRAPHANDLER_NOEC(XTRAPX_illop, T_ILLOP)
  800420bfb4:	6a 00                	pushq  $0x0
  800420bfb6:	6a 06                	pushq  $0x6
  800420bfb8:	eb 68                	jmp    800420c022 <_alltraps>

000000800420bfba <XTRAPX_device>:
	TRAPHANDLER_NOEC(XTRAPX_device, T_DEVICE)
  800420bfba:	6a 00                	pushq  $0x0
  800420bfbc:	6a 07                	pushq  $0x7
  800420bfbe:	eb 62                	jmp    800420c022 <_alltraps>

000000800420bfc0 <XTRAPX_dblflt>:
	TRAPHANDLER(XTRAPX_dblflt, T_DBLFLT)
  800420bfc0:	6a 08                	pushq  $0x8
  800420bfc2:	eb 5e                	jmp    800420c022 <_alltraps>

000000800420bfc4 <XTRAPX_tss>:

	TRAPHANDLER(XTRAPX_tss, T_TSS)	
  800420bfc4:	6a 0a                	pushq  $0xa
  800420bfc6:	eb 5a                	jmp    800420c022 <_alltraps>

000000800420bfc8 <XTRAPX_segnp>:
	TRAPHANDLER(XTRAPX_segnp, T_SEGNP)
  800420bfc8:	6a 0b                	pushq  $0xb
  800420bfca:	eb 56                	jmp    800420c022 <_alltraps>

000000800420bfcc <XTRAPX_stack>:
	TRAPHANDLER(XTRAPX_stack, T_STACK)
  800420bfcc:	6a 0c                	pushq  $0xc
  800420bfce:	eb 52                	jmp    800420c022 <_alltraps>

000000800420bfd0 <XTRAPX_gpflt>:
	TRAPHANDLER(XTRAPX_gpflt, T_GPFLT)
  800420bfd0:	6a 0d                	pushq  $0xd
  800420bfd2:	eb 4e                	jmp    800420c022 <_alltraps>

000000800420bfd4 <XTRAPX_pgflt>:
	TRAPHANDLER(XTRAPX_pgflt, T_PGFLT)
  800420bfd4:	6a 0e                	pushq  $0xe
  800420bfd6:	eb 4a                	jmp    800420c022 <_alltraps>

000000800420bfd8 <XTRAPX_fperr>:

	TRAPHANDLER_NOEC(XTRAPX_fperr, T_FPERR)
  800420bfd8:	6a 00                	pushq  $0x0
  800420bfda:	6a 10                	pushq  $0x10
  800420bfdc:	eb 44                	jmp    800420c022 <_alltraps>

000000800420bfde <XTRAPX_align>:
	TRAPHANDLER(XTRAPX_align, T_ALIGN)
  800420bfde:	6a 11                	pushq  $0x11
  800420bfe0:	eb 40                	jmp    800420c022 <_alltraps>

000000800420bfe2 <XTRAPX_mchk>:
	TRAPHANDLER_NOEC(XTRAPX_mchk, T_MCHK)
  800420bfe2:	6a 00                	pushq  $0x0
  800420bfe4:	6a 12                	pushq  $0x12
  800420bfe6:	eb 3a                	jmp    800420c022 <_alltraps>

000000800420bfe8 <XTRAPX_simderr>:
	TRAPHANDLER_NOEC(XTRAPX_simderr, T_SIMDERR)
  800420bfe8:	6a 00                	pushq  $0x0
  800420bfea:	6a 13                	pushq  $0x13
  800420bfec:	eb 34                	jmp    800420c022 <_alltraps>

000000800420bfee <XTRAPX_syscall>:

	TRAPHANDLER_NOEC(XTRAPX_syscall, T_SYSCALL)
  800420bfee:	6a 00                	pushq  $0x0
  800420bff0:	6a 30                	pushq  $0x30
  800420bff2:	eb 2e                	jmp    800420c022 <_alltraps>

000000800420bff4 <XTRAPX_default>:
	TRAPHANDLER_NOEC(XTRAPX_default, T_DEFAULT)
  800420bff4:	6a 00                	pushq  $0x0
  800420bff6:	68 f4 01 00 00       	pushq  $0x1f4
  800420bffb:	eb 25                	jmp    800420c022 <_alltraps>
  800420bffd:	90                   	nop

000000800420bffe <XTRAPX_irq_timer>:

	TRAPHANDLER_NOEC(XTRAPX_irq_timer, IRQ_OFFSET + IRQ_TIMER)
  800420bffe:	6a 00                	pushq  $0x0
  800420c000:	6a 20                	pushq  $0x20
  800420c002:	eb 1e                	jmp    800420c022 <_alltraps>

000000800420c004 <XTRAPX_irq_kbd>:
	TRAPHANDLER_NOEC(XTRAPX_irq_kbd, IRQ_OFFSET + IRQ_KBD)
  800420c004:	6a 00                	pushq  $0x0
  800420c006:	6a 21                	pushq  $0x21
  800420c008:	eb 18                	jmp    800420c022 <_alltraps>

000000800420c00a <XTRAPX_irq_serial>:
	TRAPHANDLER_NOEC(XTRAPX_irq_serial, IRQ_OFFSET + IRQ_SERIAL)
  800420c00a:	6a 00                	pushq  $0x0
  800420c00c:	6a 24                	pushq  $0x24
  800420c00e:	eb 12                	jmp    800420c022 <_alltraps>

000000800420c010 <XTRAPX_irq_spurious>:
	TRAPHANDLER_NOEC(XTRAPX_irq_spurious, IRQ_OFFSET + IRQ_SPURIOUS)
  800420c010:	6a 00                	pushq  $0x0
  800420c012:	6a 27                	pushq  $0x27
  800420c014:	eb 0c                	jmp    800420c022 <_alltraps>

000000800420c016 <XTRAPX_irq_ide>:
	TRAPHANDLER_NOEC(XTRAPX_irq_ide, IRQ_OFFSET + IRQ_IDE)
  800420c016:	6a 00                	pushq  $0x0
  800420c018:	6a 2e                	pushq  $0x2e
  800420c01a:	eb 06                	jmp    800420c022 <_alltraps>

000000800420c01c <XTRAPX_irq_error>:
	TRAPHANDLER_NOEC(XTRAPX_irq_error, IRQ_OFFSET + IRQ_ERROR)
  800420c01c:	6a 00                	pushq  $0x0
  800420c01e:	6a 33                	pushq  $0x33
  800420c020:	eb 00                	jmp    800420c022 <_alltraps>

000000800420c022 <_alltraps>:
 *       for how to pass a pointer to the trapframe.
 */


_alltraps:
	subq $8,%rsp
  800420c022:	48 83 ec 08          	sub    $0x8,%rsp
	movw %es, (%rsp)
  800420c026:	8c 04 24             	mov    %es,(%rsp)
	subq $8,%rsp
  800420c029:	48 83 ec 08          	sub    $0x8,%rsp
	movw %ds, (%rsp)
  800420c02d:	8c 1c 24             	mov    %ds,(%rsp)

	PUSHA
  800420c030:	48 83 ec 78          	sub    $0x78,%rsp
  800420c034:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420c039:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420c03e:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420c043:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420c048:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420c04d:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420c052:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420c057:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420c05c:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420c061:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420c066:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420c06b:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420c070:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420c075:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420c07a:	4c 89 3c 24          	mov    %r15,(%rsp)
	movw $GD_KD, %ax
  800420c07e:	66 b8 10 00          	mov    $0x10,%ax
	movw %ax, %ds
  800420c082:	8e d8                	mov    %eax,%ds
	movw %ax, %es
  800420c084:	8e c0                	mov    %eax,%es
	movq %rsp, %rdi
  800420c086:	48 89 e7             	mov    %rsp,%rdi
	
	call trap
  800420c089:	e8 eb f6 ff ff       	callq  800420b779 <trap>

	POPA_
  800420c08e:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420c092:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420c097:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420c09c:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420c0a1:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420c0a6:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420c0ab:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420c0b0:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420c0b5:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420c0ba:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420c0bf:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420c0c4:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420c0c9:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420c0ce:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420c0d3:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420c0d8:	48 83 c4 78          	add    $0x78,%rsp
	
	addq $8, %rsp
  800420c0dc:	48 83 c4 08          	add    $0x8,%rsp
	movw (%rsp), %es
  800420c0e0:	8e 04 24             	mov    (%rsp),%es
	addq $8, %rsp
  800420c0e3:	48 83 c4 08          	add    $0x8,%rsp
	movw (%rsp), %ds
  800420c0e7:	8e 1c 24             	mov    (%rsp),%ds

000000800420c0ea <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420c0ea:	55                   	push   %rbp
  800420c0eb:	48 89 e5             	mov    %rsp,%rbp
  800420c0ee:	48 83 ec 20          	sub    $0x20,%rsp
  800420c0f2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420c0f6:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420c0f9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c0fd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420c100:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420c104:	f0 87 02             	lock xchg %eax,(%rdx)
  800420c107:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420c10a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420c10d:	c9                   	leaveq 
  800420c10e:	c3                   	retq   

000000800420c10f <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420c10f:	55                   	push   %rbp
  800420c110:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420c113:	48 bf 80 b7 22 04 80 	movabs $0x800422b780,%rdi
  800420c11a:	00 00 00 
  800420c11d:	48 b8 ee 5f 21 04 80 	movabs $0x8004215fee,%rax
  800420c124:	00 00 00 
  800420c127:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420c129:	f3 90                	pause  
}
  800420c12b:	90                   	nop
  800420c12c:	5d                   	pop    %rbp
  800420c12d:	c3                   	retq   

000000800420c12e <sched_yield>:


// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420c12e:	55                   	push   %rbp
  800420c12f:	48 89 e5             	mov    %rsp,%rbp
  800420c132:	48 83 ec 10          	sub    $0x10,%rsp
	// no runnable environments, simply drop through to the code
	// below to halt the cpu.

	// LAB 4: Your code here.
	
	int cur_id = 0;
  800420c136:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

	if (curenv){
  800420c13d:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c144:	00 00 00 
  800420c147:	ff d0                	callq  *%rax
  800420c149:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c150:	00 00 00 
  800420c153:	48 98                	cltq   
  800420c155:	48 89 c2             	mov    %rax,%rdx
  800420c158:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c15f:	00 
  800420c160:	48 89 c2             	mov    %rax,%rdx
  800420c163:	48 89 d0             	mov    %rdx,%rax
  800420c166:	48 c1 e0 04          	shl    $0x4,%rax
  800420c16a:	48 29 d0             	sub    %rdx,%rax
  800420c16d:	48 01 c8             	add    %rcx,%rax
  800420c170:	48 83 c0 08          	add    $0x8,%rax
  800420c174:	48 8b 00             	mov    (%rax),%rax
  800420c177:	48 85 c0             	test   %rax,%rax
  800420c17a:	74 48                	je     800420c1c4 <sched_yield+0x96>
		cur_id = ENVX(curenv->env_id);
  800420c17c:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c183:	00 00 00 
  800420c186:	ff d0                	callq  *%rax
  800420c188:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c18f:	00 00 00 
  800420c192:	48 98                	cltq   
  800420c194:	48 89 c2             	mov    %rax,%rdx
  800420c197:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c19e:	00 
  800420c19f:	48 89 c2             	mov    %rax,%rdx
  800420c1a2:	48 89 d0             	mov    %rdx,%rax
  800420c1a5:	48 c1 e0 04          	shl    $0x4,%rax
  800420c1a9:	48 29 d0             	sub    %rdx,%rax
  800420c1ac:	48 01 c8             	add    %rcx,%rax
  800420c1af:	48 83 c0 08          	add    $0x8,%rax
  800420c1b3:	48 8b 00             	mov    (%rax),%rax
  800420c1b6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c1bc:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420c1c1:	89 45 fc             	mov    %eax,-0x4(%rbp)
	}

	//cprintf("NENV: %d\n", NENV);
	++cur_id;
  800420c1c4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	int next_id;

	for (int i=cur_id; i<=NENV+cur_id; i++){
  800420c1c8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c1cb:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800420c1ce:	eb 79                	jmp    800420c249 <sched_yield+0x11b>
		//cprintf("cur_id :%d\n", cur_id);
		//cprintf("next_id :%d\n", i);
	
		next_id = i%NENV;
  800420c1d0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420c1d3:	99                   	cltd   
  800420c1d4:	c1 ea 16             	shr    $0x16,%edx
  800420c1d7:	01 d0                	add    %edx,%eax
  800420c1d9:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420c1de:	29 d0                	sub    %edx,%eax
  800420c1e0:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (envs[next_id].env_status==ENV_RUNNABLE){
  800420c1e3:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  800420c1ea:	00 00 00 
  800420c1ed:	48 8b 08             	mov    (%rax),%rcx
  800420c1f0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c1f3:	48 63 d0             	movslq %eax,%rdx
  800420c1f6:	48 89 d0             	mov    %rdx,%rax
  800420c1f9:	48 c1 e0 03          	shl    $0x3,%rax
  800420c1fd:	48 01 d0             	add    %rdx,%rax
  800420c200:	48 c1 e0 05          	shl    $0x5,%rax
  800420c204:	48 01 c8             	add    %rcx,%rax
  800420c207:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c20d:	83 f8 02             	cmp    $0x2,%eax
  800420c210:	75 33                	jne    800420c245 <sched_yield+0x117>
			env_run(&envs[next_id]);
  800420c212:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  800420c219:	00 00 00 
  800420c21c:	48 8b 08             	mov    (%rax),%rcx
  800420c21f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420c222:	48 63 d0             	movslq %eax,%rdx
  800420c225:	48 89 d0             	mov    %rdx,%rax
  800420c228:	48 c1 e0 03          	shl    $0x3,%rax
  800420c22c:	48 01 d0             	add    %rdx,%rax
  800420c22f:	48 c1 e0 05          	shl    $0x5,%rax
  800420c233:	48 01 c8             	add    %rcx,%rax
  800420c236:	48 89 c7             	mov    %rax,%rdi
  800420c239:	48 b8 54 88 20 04 80 	movabs $0x8004208854,%rax
  800420c240:	00 00 00 
  800420c243:	ff d0                	callq  *%rax

	//cprintf("NENV: %d\n", NENV);
	++cur_id;
	int next_id;

	for (int i=cur_id; i<=NENV+cur_id; i++){
  800420c245:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800420c249:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c24c:	05 00 04 00 00       	add    $0x400,%eax
  800420c251:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  800420c254:	0f 8d 76 ff ff ff    	jge    800420c1d0 <sched_yield+0xa2>
			env_run(&envs[next_id]);
		}	
	}
	
	//no next runable but current is
	if (curenv && curenv->env_status==ENV_RUNNING){
  800420c25a:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c261:	00 00 00 
  800420c264:	ff d0                	callq  *%rax
  800420c266:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c26d:	00 00 00 
  800420c270:	48 98                	cltq   
  800420c272:	48 89 c2             	mov    %rax,%rdx
  800420c275:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c27c:	00 
  800420c27d:	48 89 c2             	mov    %rax,%rdx
  800420c280:	48 89 d0             	mov    %rdx,%rax
  800420c283:	48 c1 e0 04          	shl    $0x4,%rax
  800420c287:	48 29 d0             	sub    %rdx,%rax
  800420c28a:	48 01 c8             	add    %rcx,%rax
  800420c28d:	48 83 c0 08          	add    $0x8,%rax
  800420c291:	48 8b 00             	mov    (%rax),%rax
  800420c294:	48 85 c0             	test   %rax,%rax
  800420c297:	0f 84 8e 00 00 00    	je     800420c32b <sched_yield+0x1fd>
  800420c29d:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c2a4:	00 00 00 
  800420c2a7:	ff d0                	callq  *%rax
  800420c2a9:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c2b0:	00 00 00 
  800420c2b3:	48 98                	cltq   
  800420c2b5:	48 89 c2             	mov    %rax,%rdx
  800420c2b8:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c2bf:	00 
  800420c2c0:	48 89 c2             	mov    %rax,%rdx
  800420c2c3:	48 89 d0             	mov    %rdx,%rax
  800420c2c6:	48 c1 e0 04          	shl    $0x4,%rax
  800420c2ca:	48 29 d0             	sub    %rdx,%rax
  800420c2cd:	48 01 c8             	add    %rcx,%rax
  800420c2d0:	48 83 c0 08          	add    $0x8,%rax
  800420c2d4:	48 8b 00             	mov    (%rax),%rax
  800420c2d7:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c2dd:	83 f8 03             	cmp    $0x3,%eax
  800420c2e0:	75 49                	jne    800420c32b <sched_yield+0x1fd>
		env_run(curenv);
  800420c2e2:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c2e9:	00 00 00 
  800420c2ec:	ff d0                	callq  *%rax
  800420c2ee:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c2f5:	00 00 00 
  800420c2f8:	48 98                	cltq   
  800420c2fa:	48 89 c2             	mov    %rax,%rdx
  800420c2fd:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c304:	00 
  800420c305:	48 89 c2             	mov    %rax,%rdx
  800420c308:	48 89 d0             	mov    %rdx,%rax
  800420c30b:	48 c1 e0 04          	shl    $0x4,%rax
  800420c30f:	48 29 d0             	sub    %rdx,%rax
  800420c312:	48 01 c8             	add    %rcx,%rax
  800420c315:	48 83 c0 08          	add    $0x8,%rax
  800420c319:	48 8b 00             	mov    (%rax),%rax
  800420c31c:	48 89 c7             	mov    %rax,%rdi
  800420c31f:	48 b8 54 88 20 04 80 	movabs $0x8004208854,%rax
  800420c326:	00 00 00 
  800420c329:	ff d0                	callq  *%rax
	} 
	
	sched_halt();
  800420c32b:	48 b8 3a c3 20 04 80 	movabs $0x800420c33a,%rax
  800420c332:	00 00 00 
  800420c335:	ff d0                	callq  *%rax

}
  800420c337:	90                   	nop
  800420c338:	c9                   	leaveq 
  800420c339:	c3                   	retq   

000000800420c33a <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
{
  800420c33a:	55                   	push   %rbp
  800420c33b:	48 89 e5             	mov    %rsp,%rbp
  800420c33e:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420c342:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420c349:	e9 91 00 00 00       	jmpq   800420c3df <sched_halt+0xa5>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420c34e:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  800420c355:	00 00 00 
  800420c358:	48 8b 08             	mov    (%rax),%rcx
  800420c35b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c35e:	48 63 d0             	movslq %eax,%rdx
  800420c361:	48 89 d0             	mov    %rdx,%rax
  800420c364:	48 c1 e0 03          	shl    $0x3,%rax
  800420c368:	48 01 d0             	add    %rdx,%rax
  800420c36b:	48 c1 e0 05          	shl    $0x5,%rax
  800420c36f:	48 01 c8             	add    %rcx,%rax
  800420c372:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c378:	83 f8 02             	cmp    $0x2,%eax
  800420c37b:	74 6f                	je     800420c3ec <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
  800420c37d:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  800420c384:	00 00 00 
  800420c387:	48 8b 08             	mov    (%rax),%rcx
  800420c38a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c38d:	48 63 d0             	movslq %eax,%rdx
  800420c390:	48 89 d0             	mov    %rdx,%rax
  800420c393:	48 c1 e0 03          	shl    $0x3,%rax
  800420c397:	48 01 d0             	add    %rdx,%rax
  800420c39a:	48 c1 e0 05          	shl    $0x5,%rax
  800420c39e:	48 01 c8             	add    %rcx,%rax
  800420c3a1:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420c3a7:	83 f8 03             	cmp    $0x3,%eax
  800420c3aa:	74 40                	je     800420c3ec <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420c3ac:	48 b8 50 22 36 04 80 	movabs $0x8004362250,%rax
  800420c3b3:	00 00 00 
  800420c3b6:	48 8b 08             	mov    (%rax),%rcx
  800420c3b9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c3bc:	48 63 d0             	movslq %eax,%rdx
  800420c3bf:	48 89 d0             	mov    %rdx,%rax
  800420c3c2:	48 c1 e0 03          	shl    $0x3,%rax
  800420c3c6:	48 01 d0             	add    %rdx,%rax
  800420c3c9:	48 c1 e0 05          	shl    $0x5,%rax
  800420c3cd:	48 01 c8             	add    %rcx,%rax
  800420c3d0:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420c3d6:	83 f8 01             	cmp    $0x1,%eax
  800420c3d9:	74 11                	je     800420c3ec <sched_halt+0xb2>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420c3db:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420c3df:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420c3e6:	0f 8e 62 ff ff ff    	jle    800420c34e <sched_halt+0x14>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420c3ec:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420c3f3:	75 2e                	jne    800420c423 <sched_halt+0xe9>
		cprintf("No runnable environments in the system!\n");
  800420c3f5:	48 bf c0 7a 21 04 80 	movabs $0x8004217ac0,%rdi
  800420c3fc:	00 00 00 
  800420c3ff:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c404:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420c40b:	00 00 00 
  800420c40e:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420c410:	bf 00 00 00 00       	mov    $0x0,%edi
  800420c415:	48 b8 4e 18 20 04 80 	movabs $0x800420184e,%rax
  800420c41c:	00 00 00 
  800420c41f:	ff d0                	callq  *%rax
  800420c421:	eb ed                	jmp    800420c410 <sched_halt+0xd6>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420c423:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c42a:	00 00 00 
  800420c42d:	ff d0                	callq  *%rax
  800420c42f:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c436:	00 00 00 
  800420c439:	48 98                	cltq   
  800420c43b:	48 89 c2             	mov    %rax,%rdx
  800420c43e:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c445:	00 
  800420c446:	48 89 c2             	mov    %rax,%rdx
  800420c449:	48 89 d0             	mov    %rdx,%rax
  800420c44c:	48 c1 e0 04          	shl    $0x4,%rax
  800420c450:	48 29 d0             	sub    %rdx,%rax
  800420c453:	48 01 c8             	add    %rcx,%rax
  800420c456:	48 83 c0 08          	add    $0x8,%rax
  800420c45a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	lcr3(PADDR(boot_pml4e));
  800420c461:	48 b8 28 37 36 04 80 	movabs $0x8004363728,%rax
  800420c468:	00 00 00 
  800420c46b:	48 8b 00             	mov    (%rax),%rax
  800420c46e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420c472:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420c479:	00 00 00 
  800420c47c:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420c480:	77 32                	ja     800420c4b4 <sched_halt+0x17a>
  800420c482:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c486:	48 89 c1             	mov    %rax,%rcx
  800420c489:	48 ba f0 7a 21 04 80 	movabs $0x8004217af0,%rdx
  800420c490:	00 00 00 
  800420c493:	be 58 00 00 00       	mov    $0x58,%esi
  800420c498:	48 bf 14 7b 21 04 80 	movabs $0x8004217b14,%rdi
  800420c49f:	00 00 00 
  800420c4a2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c4a7:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420c4ae:	00 00 00 
  800420c4b1:	41 ff d0             	callq  *%r8
  800420c4b4:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420c4bb:	ff ff ff 
  800420c4be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c4c2:	48 01 d0             	add    %rdx,%rax
  800420c4c5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420c4c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c4cd:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420c4d0:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c4d7:	00 00 00 
  800420c4da:	ff d0                	callq  *%rax
  800420c4dc:	48 98                	cltq   
  800420c4de:	48 89 c2             	mov    %rax,%rdx
  800420c4e1:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c4e8:	00 
  800420c4e9:	48 89 c2             	mov    %rax,%rdx
  800420c4ec:	48 89 d0             	mov    %rdx,%rax
  800420c4ef:	48 c1 e0 04          	shl    $0x4,%rax
  800420c4f3:	48 29 d0             	sub    %rdx,%rax
  800420c4f6:	48 ba 20 50 36 04 80 	movabs $0x8004365020,%rdx
  800420c4fd:	00 00 00 
  800420c500:	48 01 d0             	add    %rdx,%rax
  800420c503:	48 83 c0 04          	add    $0x4,%rax
  800420c507:	be 02 00 00 00       	mov    $0x2,%esi
  800420c50c:	48 89 c7             	mov    %rax,%rdi
  800420c50f:	48 b8 ea c0 20 04 80 	movabs $0x800420c0ea,%rax
  800420c516:	00 00 00 
  800420c519:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420c51b:	48 b8 0f c1 20 04 80 	movabs $0x800420c10f,%rax
  800420c522:	00 00 00 
  800420c525:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420c527:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c52e:	00 00 00 
  800420c531:	ff d0                	callq  *%rax
  800420c533:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c53a:	00 00 00 
  800420c53d:	48 98                	cltq   
  800420c53f:	48 89 c2             	mov    %rax,%rdx
  800420c542:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c549:	00 
  800420c54a:	48 89 c2             	mov    %rax,%rdx
  800420c54d:	48 89 d0             	mov    %rdx,%rax
  800420c550:	48 c1 e0 04          	shl    $0x4,%rax
  800420c554:	48 29 d0             	sub    %rdx,%rax
  800420c557:	48 01 c8             	add    %rcx,%rax
  800420c55a:	48 83 c0 10          	add    $0x10,%rax
  800420c55e:	48 8b 40 04          	mov    0x4(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420c562:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420c569:	48 89 c4             	mov    %rax,%rsp
  800420c56c:	6a 00                	pushq  $0x0
  800420c56e:	6a 00                	pushq  $0x0
  800420c570:	fb                   	sti    
  800420c571:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
		: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420c572:	90                   	nop
  800420c573:	c9                   	leaveq 
  800420c574:	c3                   	retq   

000000800420c575 <sys_cputs>:

// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420c575:	55                   	push   %rbp
  800420c576:	48 89 e5             	mov    %rsp,%rbp
  800420c579:	48 83 ec 10          	sub    $0x10,%rsp
  800420c57d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c581:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, s, len, PTE_U);
  800420c585:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c58c:	00 00 00 
  800420c58f:	ff d0                	callq  *%rax
  800420c591:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c598:	00 00 00 
  800420c59b:	48 98                	cltq   
  800420c59d:	48 89 c2             	mov    %rax,%rdx
  800420c5a0:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c5a7:	00 
  800420c5a8:	48 89 c2             	mov    %rax,%rdx
  800420c5ab:	48 89 d0             	mov    %rdx,%rax
  800420c5ae:	48 c1 e0 04          	shl    $0x4,%rax
  800420c5b2:	48 29 d0             	sub    %rdx,%rax
  800420c5b5:	48 01 c8             	add    %rcx,%rax
  800420c5b8:	48 83 c0 08          	add    $0x8,%rax
  800420c5bc:	48 8b 00             	mov    (%rax),%rax
  800420c5bf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c5c3:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420c5c7:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420c5cc:	48 89 c7             	mov    %rax,%rdi
  800420c5cf:	48 b8 64 3a 20 04 80 	movabs $0x8004203a64,%rax
  800420c5d6:	00 00 00 
  800420c5d9:	ff d0                	callq  *%rax

	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420c5db:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c5df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c5e3:	48 89 c6             	mov    %rax,%rsi
  800420c5e6:	48 bf 28 7b 21 04 80 	movabs $0x8004217b28,%rdi
  800420c5ed:	00 00 00 
  800420c5f0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c5f5:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  800420c5fc:	00 00 00 
  800420c5ff:	ff d1                	callq  *%rcx
}
  800420c601:	90                   	nop
  800420c602:	c9                   	leaveq 
  800420c603:	c3                   	retq   

000000800420c604 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420c604:	55                   	push   %rbp
  800420c605:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420c608:	48 b8 54 10 20 04 80 	movabs $0x8004201054,%rax
  800420c60f:	00 00 00 
  800420c612:	ff d0                	callq  *%rax
}
  800420c614:	5d                   	pop    %rbp
  800420c615:	c3                   	retq   

000000800420c616 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420c616:	55                   	push   %rbp
  800420c617:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420c61a:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c621:	00 00 00 
  800420c624:	ff d0                	callq  *%rax
  800420c626:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c62d:	00 00 00 
  800420c630:	48 98                	cltq   
  800420c632:	48 89 c2             	mov    %rax,%rdx
  800420c635:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c63c:	00 
  800420c63d:	48 89 c2             	mov    %rax,%rdx
  800420c640:	48 89 d0             	mov    %rdx,%rax
  800420c643:	48 c1 e0 04          	shl    $0x4,%rax
  800420c647:	48 29 d0             	sub    %rdx,%rax
  800420c64a:	48 01 c8             	add    %rcx,%rax
  800420c64d:	48 83 c0 08          	add    $0x8,%rax
  800420c651:	48 8b 00             	mov    (%rax),%rax
  800420c654:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420c65a:	5d                   	pop    %rbp
  800420c65b:	c3                   	retq   

000000800420c65c <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420c65c:	55                   	push   %rbp
  800420c65d:	48 89 e5             	mov    %rsp,%rbp
  800420c660:	53                   	push   %rbx
  800420c661:	48 83 ec 28          	sub    $0x28,%rsp
  800420c665:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420c668:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420c66c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c66f:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c674:	48 89 ce             	mov    %rcx,%rsi
  800420c677:	89 c7                	mov    %eax,%edi
  800420c679:	48 b8 1a 77 20 04 80 	movabs $0x800420771a,%rax
  800420c680:	00 00 00 
  800420c683:	ff d0                	callq  *%rax
  800420c685:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420c688:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c68c:	79 08                	jns    800420c696 <sys_env_destroy+0x3a>
		return r;
  800420c68e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c691:	e9 23 01 00 00       	jmpq   800420c7b9 <sys_env_destroy+0x15d>
	if (e == curenv)
  800420c696:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c69d:	00 00 00 
  800420c6a0:	ff d0                	callq  *%rax
  800420c6a2:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c6a9:	00 00 00 
  800420c6ac:	48 98                	cltq   
  800420c6ae:	48 89 c2             	mov    %rax,%rdx
  800420c6b1:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c6b8:	00 
  800420c6b9:	48 89 c2             	mov    %rax,%rdx
  800420c6bc:	48 89 d0             	mov    %rdx,%rax
  800420c6bf:	48 c1 e0 04          	shl    $0x4,%rax
  800420c6c3:	48 29 d0             	sub    %rdx,%rax
  800420c6c6:	48 01 c8             	add    %rcx,%rax
  800420c6c9:	48 83 c0 08          	add    $0x8,%rax
  800420c6cd:	48 8b 10             	mov    (%rax),%rdx
  800420c6d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c6d4:	48 39 c2             	cmp    %rax,%rdx
  800420c6d7:	75 5f                	jne    800420c738 <sys_env_destroy+0xdc>
		cprintf("[%08x] exiting gracefully\n", curenv->env_id);
  800420c6d9:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c6e0:	00 00 00 
  800420c6e3:	ff d0                	callq  *%rax
  800420c6e5:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c6ec:	00 00 00 
  800420c6ef:	48 98                	cltq   
  800420c6f1:	48 89 c2             	mov    %rax,%rdx
  800420c6f4:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c6fb:	00 
  800420c6fc:	48 89 c2             	mov    %rax,%rdx
  800420c6ff:	48 89 d0             	mov    %rdx,%rax
  800420c702:	48 c1 e0 04          	shl    $0x4,%rax
  800420c706:	48 29 d0             	sub    %rdx,%rax
  800420c709:	48 01 c8             	add    %rcx,%rax
  800420c70c:	48 83 c0 08          	add    $0x8,%rax
  800420c710:	48 8b 00             	mov    (%rax),%rax
  800420c713:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c719:	89 c6                	mov    %eax,%esi
  800420c71b:	48 bf 2d 7b 21 04 80 	movabs $0x8004217b2d,%rdi
  800420c722:	00 00 00 
  800420c725:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c72a:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420c731:	00 00 00 
  800420c734:	ff d2                	callq  *%rdx
  800420c736:	eb 69                	jmp    800420c7a1 <sys_env_destroy+0x145>
	else
		cprintf("[%08x] destroying %08x\n", curenv->env_id, e->env_id);
  800420c738:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c73c:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  800420c742:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c749:	00 00 00 
  800420c74c:	ff d0                	callq  *%rax
  800420c74e:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c755:	00 00 00 
  800420c758:	48 98                	cltq   
  800420c75a:	48 89 c2             	mov    %rax,%rdx
  800420c75d:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c764:	00 
  800420c765:	48 89 c2             	mov    %rax,%rdx
  800420c768:	48 89 d0             	mov    %rdx,%rax
  800420c76b:	48 c1 e0 04          	shl    $0x4,%rax
  800420c76f:	48 29 d0             	sub    %rdx,%rax
  800420c772:	48 01 c8             	add    %rcx,%rax
  800420c775:	48 83 c0 08          	add    $0x8,%rax
  800420c779:	48 8b 00             	mov    (%rax),%rax
  800420c77c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c782:	89 da                	mov    %ebx,%edx
  800420c784:	89 c6                	mov    %eax,%esi
  800420c786:	48 bf 48 7b 21 04 80 	movabs $0x8004217b48,%rdi
  800420c78d:	00 00 00 
  800420c790:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c795:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  800420c79c:	00 00 00 
  800420c79f:	ff d1                	callq  *%rcx
	env_destroy(e);
  800420c7a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c7a5:	48 89 c7             	mov    %rax,%rdi
  800420c7a8:	48 b8 61 86 20 04 80 	movabs $0x8004208661,%rax
  800420c7af:	00 00 00 
  800420c7b2:	ff d0                	callq  *%rax
	return 0;
  800420c7b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c7b9:	48 83 c4 28          	add    $0x28,%rsp
  800420c7bd:	5b                   	pop    %rbx
  800420c7be:	5d                   	pop    %rbp
  800420c7bf:	c3                   	retq   

000000800420c7c0 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420c7c0:	55                   	push   %rbp
  800420c7c1:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420c7c4:	48 b8 2e c1 20 04 80 	movabs $0x800420c12e,%rax
  800420c7cb:	00 00 00 
  800420c7ce:	ff d0                	callq  *%rax

000000800420c7d0 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420c7d0:	55                   	push   %rbp
  800420c7d1:	48 89 e5             	mov    %rsp,%rbp
  800420c7d4:	53                   	push   %rbx
  800420c7d5:	48 83 ec 18          	sub    $0x18,%rsp
	// will appear to return 0.

	// LAB 4: Your code here.

	struct Env *new_env;
	int result = env_alloc(&new_env, curenv->env_id);
  800420c7d9:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c7e0:	00 00 00 
  800420c7e3:	ff d0                	callq  *%rax
  800420c7e5:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c7ec:	00 00 00 
  800420c7ef:	48 98                	cltq   
  800420c7f1:	48 89 c2             	mov    %rax,%rdx
  800420c7f4:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c7fb:	00 
  800420c7fc:	48 89 c2             	mov    %rax,%rdx
  800420c7ff:	48 89 d0             	mov    %rdx,%rax
  800420c802:	48 c1 e0 04          	shl    $0x4,%rax
  800420c806:	48 29 d0             	sub    %rdx,%rax
  800420c809:	48 01 c8             	add    %rcx,%rax
  800420c80c:	48 83 c0 08          	add    $0x8,%rax
  800420c810:	48 8b 00             	mov    (%rax),%rax
  800420c813:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420c819:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420c81d:	89 d6                	mov    %edx,%esi
  800420c81f:	48 89 c7             	mov    %rax,%rdi
  800420c822:	48 b8 f0 7a 20 04 80 	movabs $0x8004207af0,%rax
  800420c829:	00 00 00 
  800420c82c:	ff d0                	callq  *%rax
  800420c82e:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (result<0){
  800420c831:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c835:	79 05                	jns    800420c83c <sys_exofork+0x6c>
		return result;
  800420c837:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c83a:	eb 76                	jmp    800420c8b2 <sys_exofork+0xe2>
	//}else if(result==-E_NO_MEM){
	//	return -E_NO_MEM;
	//}
		
	//set status as not runnabel
	new_env->env_status=ENV_NOT_RUNNABLE;
  800420c83c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c840:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420c847:	00 00 00 
	//copy regs
	new_env->env_tf = curenv->env_tf;
  800420c84a:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420c84e:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420c855:	00 00 00 
  800420c858:	ff d0                	callq  *%rax
  800420c85a:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420c861:	00 00 00 
  800420c864:	48 98                	cltq   
  800420c866:	48 89 c2             	mov    %rax,%rdx
  800420c869:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420c870:	00 
  800420c871:	48 89 c2             	mov    %rax,%rdx
  800420c874:	48 89 d0             	mov    %rdx,%rax
  800420c877:	48 c1 e0 04          	shl    $0x4,%rax
  800420c87b:	48 29 d0             	sub    %rdx,%rax
  800420c87e:	48 01 c8             	add    %rcx,%rax
  800420c881:	48 83 c0 08          	add    $0x8,%rax
  800420c885:	48 8b 00             	mov    (%rax),%rax
  800420c888:	48 89 da             	mov    %rbx,%rdx
  800420c88b:	48 89 c6             	mov    %rax,%rsi
  800420c88e:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c893:	48 89 d7             	mov    %rdx,%rdi
  800420c896:	48 89 c1             	mov    %rax,%rcx
  800420c899:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	//sys_exofork returns 0
	new_env->env_tf.tf_regs.reg_rax = 0;
  800420c89c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c8a0:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420c8a7:	00 
	
	return new_env->env_id;
  800420c8a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c8ac:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
	//panic("sys_exofork not implemented");
}
  800420c8b2:	48 83 c4 18          	add    $0x18,%rsp
  800420c8b6:	5b                   	pop    %rbx
  800420c8b7:	5d                   	pop    %rbp
  800420c8b8:	c3                   	retq   

000000800420c8b9 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420c8b9:	55                   	push   %rbp
  800420c8ba:	48 89 e5             	mov    %rsp,%rbp
  800420c8bd:	48 83 ec 20          	sub    $0x20,%rsp
  800420c8c1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c8c4:	89 75 e8             	mov    %esi,-0x18(%rbp)
	// envid's status.

	// LAB 4: Your code here.

	struct Env *changed_env;
	int result = envid2env(envid, &changed_env,1);
  800420c8c7:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c8cb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c8ce:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c8d3:	48 89 ce             	mov    %rcx,%rsi
  800420c8d6:	89 c7                	mov    %eax,%edi
  800420c8d8:	48 b8 1a 77 20 04 80 	movabs $0x800420771a,%rax
  800420c8df:	00 00 00 
  800420c8e2:	ff d0                	callq  *%rax
  800420c8e4:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result<0){
  800420c8e7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c8eb:	79 07                	jns    800420c8f4 <sys_env_set_status+0x3b>
                return -E_BAD_ENV;
  800420c8ed:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420c8f2:	eb 25                	jmp    800420c919 <sys_env_set_status+0x60>
        }else if (status!=ENV_RUNNABLE && status!=ENV_NOT_RUNNABLE){
  800420c8f4:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420c8f8:	74 0d                	je     800420c907 <sys_env_set_status+0x4e>
  800420c8fa:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420c8fe:	74 07                	je     800420c907 <sys_env_set_status+0x4e>
		return -E_INVAL;
  800420c900:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c905:	eb 12                	jmp    800420c919 <sys_env_set_status+0x60>
	}

	changed_env->env_status=status;
  800420c907:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c90b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420c90e:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return 0;
  800420c914:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c919:	c9                   	leaveq 
  800420c91a:	c3                   	retq   

000000800420c91b <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420c91b:	55                   	push   %rbp
  800420c91c:	48 89 e5             	mov    %rsp,%rbp
  800420c91f:	48 83 ec 20          	sub    $0x20,%rsp
  800420c923:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c926:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
//	cprintf("fails here: upcall\n");
	// LAB 4: Your code here.
	struct Env *used_env;
	int result = envid2env(envid, &used_env,1);
  800420c92a:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c92e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c931:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c936:	48 89 ce             	mov    %rcx,%rsi
  800420c939:	89 c7                	mov    %eax,%edi
  800420c93b:	48 b8 1a 77 20 04 80 	movabs $0x800420771a,%rax
  800420c942:	00 00 00 
  800420c945:	ff d0                	callq  *%rax
  800420c947:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if(result<0){
  800420c94a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c94e:	79 07                	jns    800420c957 <sys_env_set_pgfault_upcall+0x3c>
                return -E_BAD_ENV;
  800420c950:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420c955:	eb 14                	jmp    800420c96b <sys_env_set_pgfault_upcall+0x50>
	}
	used_env->env_pgfault_upcall=func;
  800420c957:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c95b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c95f:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420c966:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_pgfault_upcall not implemented");
}
  800420c96b:	c9                   	leaveq 
  800420c96c:	c3                   	retq   

000000800420c96d <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420c96d:	55                   	push   %rbp
  800420c96e:	48 89 e5             	mov    %rsp,%rbp
  800420c971:	48 83 ec 30          	sub    $0x30,%rsp
  800420c975:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420c978:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420c97c:	89 55 d8             	mov    %edx,-0x28(%rbp)
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	// LAB 4: Your code here.
	struct Env *used_env;
	int result = envid2env(envid, &used_env,1);
  800420c97f:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420c983:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c986:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c98b:	48 89 ce             	mov    %rcx,%rsi
  800420c98e:	89 c7                	mov    %eax,%edi
  800420c990:	48 b8 1a 77 20 04 80 	movabs $0x800420771a,%rax
  800420c997:	00 00 00 
  800420c99a:	ff d0                	callq  *%rax
  800420c99c:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if(result<0){
  800420c99f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c9a3:	79 0a                	jns    800420c9af <sys_page_alloc+0x42>
                return -E_BAD_ENV;
  800420c9a5:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420c9aa:	e9 bb 00 00 00       	jmpq   800420ca6a <sys_page_alloc+0xfd>
	}

	uintptr_t int_va = (uintptr_t)va;
  800420c9af:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c9b3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(int_va>=UTOP || int_va%PGSIZE!=0){
  800420c9b7:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c9be:	00 00 00 
  800420c9c1:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420c9c5:	77 0e                	ja     800420c9d5 <sys_page_alloc+0x68>
  800420c9c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c9cb:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c9d0:	48 85 c0             	test   %rax,%rax
  800420c9d3:	74 0a                	je     800420c9df <sys_page_alloc+0x72>
		return -E_INVAL;
  800420c9d5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c9da:	e9 8b 00 00 00       	jmpq   800420ca6a <sys_page_alloc+0xfd>
	}
//	if(!(perm&(PTE_U|PTE_P)) || (perm& !PTE_SYSCALL)){
//		return -E_INVAL;
//	}  

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & !PTE_SYSCALL))
  800420c9df:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420c9e2:	83 e0 04             	and    $0x4,%eax
  800420c9e5:	85 c0                	test   %eax,%eax
  800420c9e7:	74 0a                	je     800420c9f3 <sys_page_alloc+0x86>
  800420c9e9:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420c9ec:	83 e0 01             	and    $0x1,%eax
  800420c9ef:	85 c0                	test   %eax,%eax
  800420c9f1:	75 07                	jne    800420c9fa <sys_page_alloc+0x8d>
		return -E_INVAL;
  800420c9f3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c9f8:	eb 70                	jmp    800420ca6a <sys_page_alloc+0xfd>
	
	struct PageInfo *new_page = page_alloc(ALLOC_ZERO);
  800420c9fa:	bf 01 00 00 00       	mov    $0x1,%edi
  800420c9ff:	48 b8 e5 2a 20 04 80 	movabs $0x8004202ae5,%rax
  800420ca06:	00 00 00 
  800420ca09:	ff d0                	callq  *%rax
  800420ca0b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (!new_page){
  800420ca0f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ca14:	75 07                	jne    800420ca1d <sys_page_alloc+0xb0>
		return -E_NO_MEM;
  800420ca16:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420ca1b:	eb 4d                	jmp    800420ca6a <sys_page_alloc+0xfd>
	}
	
	result = page_insert(used_env->env_pml4e, new_page, va, perm);
  800420ca1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ca21:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ca28:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420ca2b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420ca2f:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420ca33:	48 89 c7             	mov    %rax,%rdi
  800420ca36:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  800420ca3d:	00 00 00 
  800420ca40:	ff d0                	callq  *%rax
  800420ca42:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result<0){
  800420ca45:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ca49:	79 1a                	jns    800420ca65 <sys_page_alloc+0xf8>
		page_free(new_page);
  800420ca4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ca4f:	48 89 c7             	mov    %rax,%rdi
  800420ca52:	48 b8 f4 2b 20 04 80 	movabs $0x8004202bf4,%rax
  800420ca59:	00 00 00 
  800420ca5c:	ff d0                	callq  *%rax
                return -E_NO_MEM;
  800420ca5e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420ca63:	eb 05                	jmp    800420ca6a <sys_page_alloc+0xfd>
        }
	return 0;
  800420ca65:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_alloc not implemented");
}
  800420ca6a:	c9                   	leaveq 
  800420ca6b:	c3                   	retq   

000000800420ca6c <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420ca6c:	55                   	push   %rbp
  800420ca6d:	48 89 e5             	mov    %rsp,%rbp
  800420ca70:	48 83 ec 50          	sub    $0x50,%rsp
  800420ca74:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420ca77:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420ca7b:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420ca7e:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420ca82:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	//   check the current permissions on the page.

	// LAB 4: Your code heire.
	struct Env *src_env;
	struct Env *dst_env;
        int result = envid2env(srcenvid, &src_env,1);
  800420ca86:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420ca8a:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420ca8d:	ba 01 00 00 00       	mov    $0x1,%edx
  800420ca92:	48 89 ce             	mov    %rcx,%rsi
  800420ca95:	89 c7                	mov    %eax,%edi
  800420ca97:	48 b8 1a 77 20 04 80 	movabs $0x800420771a,%rax
  800420ca9e:	00 00 00 
  800420caa1:	ff d0                	callq  *%rax
  800420caa3:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if(result<0){
  800420caa6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420caaa:	79 0a                	jns    800420cab6 <sys_page_map+0x4a>
                return -E_BAD_ENV;
  800420caac:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420cab1:	e9 2d 01 00 00       	jmpq   800420cbe3 <sys_page_map+0x177>
        }
	result = envid2env(dstenvid, &dst_env,1);
  800420cab6:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420caba:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420cabd:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cac2:	48 89 ce             	mov    %rcx,%rsi
  800420cac5:	89 c7                	mov    %eax,%edi
  800420cac7:	48 b8 1a 77 20 04 80 	movabs $0x800420771a,%rax
  800420cace:	00 00 00 
  800420cad1:	ff d0                	callq  *%rax
  800420cad3:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if(result<0){
  800420cad6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cada:	79 0a                	jns    800420cae6 <sys_page_map+0x7a>
                return -E_BAD_ENV;
  800420cadc:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420cae1:	e9 fd 00 00 00       	jmpq   800420cbe3 <sys_page_map+0x177>
        }

	//page alligned or above utop
	uintptr_t int_va = (uintptr_t)srcva;
  800420cae6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420caea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        if(int_va>=UTOP || int_va%PGSIZE!=0){
  800420caee:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420caf5:	00 00 00 
  800420caf8:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420cafc:	77 0e                	ja     800420cb0c <sys_page_map+0xa0>
  800420cafe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb02:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cb07:	48 85 c0             	test   %rax,%rax
  800420cb0a:	74 0a                	je     800420cb16 <sys_page_map+0xaa>
                return -E_INVAL;
  800420cb0c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cb11:	e9 cd 00 00 00       	jmpq   800420cbe3 <sys_page_map+0x177>
        }
	int_va = (uintptr_t)dstva;
  800420cb16:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420cb1a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        if(int_va>=UTOP || int_va%PGSIZE!=0){
  800420cb1e:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cb25:	00 00 00 
  800420cb28:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420cb2c:	77 0e                	ja     800420cb3c <sys_page_map+0xd0>
  800420cb2e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cb32:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cb37:	48 85 c0             	test   %rax,%rax
  800420cb3a:	74 0a                	je     800420cb46 <sys_page_map+0xda>
                return -E_INVAL;
  800420cb3c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cb41:	e9 9d 00 00 00       	jmpq   800420cbe3 <sys_page_map+0x177>
        }

	pte_t *ptr_pte;
	//srcva is not mapped in srcenvid's address space
	struct PageInfo *found_page = page_lookup(src_env->env_pml4e, srcva, &ptr_pte);
  800420cb46:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cb4a:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cb51:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800420cb55:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420cb59:	48 89 ce             	mov    %rcx,%rsi
  800420cb5c:	48 89 c7             	mov    %rax,%rdi
  800420cb5f:	48 b8 c5 35 20 04 80 	movabs $0x80042035c5,%rax
  800420cb66:	00 00 00 
  800420cb69:	ff d0                	callq  *%rax
  800420cb6b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        if (!found_page){
  800420cb6f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420cb74:	75 07                	jne    800420cb7d <sys_page_map+0x111>
                return -E_INVAL;
  800420cb76:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cb7b:	eb 66                	jmp    800420cbe3 <sys_page_map+0x177>
        }

	//perm is inappropriate
	if(!(perm&(PTE_U|PTE_P)) || (perm& !PTE_SYSCALL)){
  800420cb7d:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420cb80:	83 e0 05             	and    $0x5,%eax
  800420cb83:	85 c0                	test   %eax,%eax
  800420cb85:	75 07                	jne    800420cb8e <sys_page_map+0x122>
                return -E_INVAL;
  800420cb87:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cb8c:	eb 55                	jmp    800420cbe3 <sys_page_map+0x177>
        }
        
	//(perm & PTE_W), but srcva is read-only in srcenvid
	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & !PTE_SYSCALL))
  800420cb8e:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420cb91:	83 e0 04             	and    $0x4,%eax
  800420cb94:	85 c0                	test   %eax,%eax
  800420cb96:	74 0a                	je     800420cba2 <sys_page_map+0x136>
  800420cb98:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420cb9b:	83 e0 01             	and    $0x1,%eax
  800420cb9e:	85 c0                	test   %eax,%eax
  800420cba0:	75 07                	jne    800420cba9 <sys_page_map+0x13d>
		return -E_INVAL;
  800420cba2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cba7:	eb 3a                	jmp    800420cbe3 <sys_page_map+0x177>
	

	result = page_insert(dst_env->env_pml4e, found_page, dstva, perm);
  800420cba9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cbad:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cbb4:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420cbb7:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420cbbb:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420cbbf:	48 89 c7             	mov    %rax,%rdi
  800420cbc2:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  800420cbc9:	00 00 00 
  800420cbcc:	ff d0                	callq  *%rax
  800420cbce:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if(result<0){
  800420cbd1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cbd5:	79 07                	jns    800420cbde <sys_page_map+0x172>
                return -E_NO_MEM;
  800420cbd7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420cbdc:	eb 05                	jmp    800420cbe3 <sys_page_map+0x177>
        }
	return 0;
  800420cbde:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420cbe3:	c9                   	leaveq 
  800420cbe4:	c3                   	retq   

000000800420cbe5 <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420cbe5:	55                   	push   %rbp
  800420cbe6:	48 89 e5             	mov    %rsp,%rbp
  800420cbe9:	48 83 ec 30          	sub    $0x30,%rsp
  800420cbed:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420cbf0:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// Hint: This function is a wrapper around page_remove().
//	cprintf("fails here: unmap\n");
	// LAB 4: Your code here.
	struct Env *used_env;
        int result = envid2env(envid, &used_env,1);
  800420cbf4:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420cbf8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420cbfb:	ba 01 00 00 00       	mov    $0x1,%edx
  800420cc00:	48 89 ce             	mov    %rcx,%rsi
  800420cc03:	89 c7                	mov    %eax,%edi
  800420cc05:	48 b8 1a 77 20 04 80 	movabs $0x800420771a,%rax
  800420cc0c:	00 00 00 
  800420cc0f:	ff d0                	callq  *%rax
  800420cc11:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if(result<0){
  800420cc14:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420cc18:	79 07                	jns    800420cc21 <sys_page_unmap+0x3c>
                return -E_BAD_ENV;
  800420cc1a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420cc1f:	eb 53                	jmp    800420cc74 <sys_page_unmap+0x8f>
        }
	uintptr_t int_va = (uintptr_t)va;
  800420cc21:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cc25:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        if(int_va>=UTOP || int_va%PGSIZE!=0){
  800420cc29:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cc30:	00 00 00 
  800420cc33:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420cc37:	77 0e                	ja     800420cc47 <sys_page_unmap+0x62>
  800420cc39:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cc3d:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cc42:	48 85 c0             	test   %rax,%rax
  800420cc45:	74 07                	je     800420cc4e <sys_page_unmap+0x69>
                return -E_INVAL;
  800420cc47:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cc4c:	eb 26                	jmp    800420cc74 <sys_page_unmap+0x8f>
        }

	page_remove(used_env->env_pml4e, va);
  800420cc4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc52:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cc59:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420cc5d:	48 89 d6             	mov    %rdx,%rsi
  800420cc60:	48 89 c7             	mov    %rax,%rdi
  800420cc63:	48 b8 49 36 20 04 80 	movabs $0x8004203649,%rax
  800420cc6a:	00 00 00 
  800420cc6d:	ff d0                	callq  *%rax
	return 0;
  800420cc6f:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_unmap not implemented");

}
  800420cc74:	c9                   	leaveq 
  800420cc75:	c3                   	retq   

000000800420cc76 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420cc76:	55                   	push   %rbp
  800420cc77:	48 89 e5             	mov    %rsp,%rbp
  800420cc7a:	53                   	push   %rbx
  800420cc7b:	48 83 ec 48          	sub    $0x48,%rsp
  800420cc7f:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420cc82:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800420cc85:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420cc89:	89 4d bc             	mov    %ecx,-0x44(%rbp)
		// LAB 4: Your code here.
		//cprintf("sys_ipc_send\n");		
		struct Env *target;
		int result = envid2env(envid, &target, 0); 
  800420cc8c:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420cc90:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420cc93:	ba 00 00 00 00       	mov    $0x0,%edx
  800420cc98:	48 89 ce             	mov    %rcx,%rsi
  800420cc9b:	89 c7                	mov    %eax,%edi
  800420cc9d:	48 b8 1a 77 20 04 80 	movabs $0x800420771a,%rax
  800420cca4:	00 00 00 
  800420cca7:	ff d0                	callq  *%rax
  800420cca9:	89 45 ec             	mov    %eax,-0x14(%rbp)
		if (result<0){
  800420ccac:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420ccb0:	79 0a                	jns    800420ccbc <sys_ipc_try_send+0x46>
			return -E_BAD_ENV;
  800420ccb2:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420ccb7:	e9 d5 01 00 00       	jmpq   800420ce91 <sys_ipc_try_send+0x21b>

		}
		//target not blocked
		//from inc.env bool env_ipc_recving;
		bool status  = target->env_ipc_recving;
  800420ccbc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ccc0:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420ccc7:	88 45 eb             	mov    %al,-0x15(%rbp)
		if(!status){
  800420ccca:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800420ccce:	83 f0 01             	xor    $0x1,%eax
  800420ccd1:	84 c0                	test   %al,%al
  800420ccd3:	74 0a                	je     800420ccdf <sys_ipc_try_send+0x69>
			return -E_IPC_NOT_RECV;
  800420ccd5:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420ccda:	e9 b2 01 00 00       	jmpq   800420ce91 <sys_ipc_try_send+0x21b>
		}
		

		//page transfer
		if ((uintptr_t)srcva<UTOP){
  800420ccdf:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420cce3:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ccea:	00 00 00 
  800420cced:	48 39 c2             	cmp    %rax,%rdx
  800420ccf0:	0f 87 4e 01 00 00    	ja     800420ce44 <sys_ipc_try_send+0x1ce>
			if ((uintptr_t)srcva%PGSIZE!=0){
  800420ccf6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420ccfa:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420ccff:	48 85 c0             	test   %rax,%rax
  800420cd02:	74 0a                	je     800420cd0e <sys_ipc_try_send+0x98>
				return -E_INVAL;
  800420cd04:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cd09:	e9 83 01 00 00       	jmpq   800420ce91 <sys_ipc_try_send+0x21b>
			}
			if (!(perm & PTE_U) || !(perm & PTE_P) || (perm & !PTE_SYSCALL)){
  800420cd0e:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420cd11:	83 e0 04             	and    $0x4,%eax
  800420cd14:	85 c0                	test   %eax,%eax
  800420cd16:	74 0a                	je     800420cd22 <sys_ipc_try_send+0xac>
  800420cd18:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420cd1b:	83 e0 01             	and    $0x1,%eax
  800420cd1e:	85 c0                	test   %eax,%eax
  800420cd20:	75 0a                	jne    800420cd2c <sys_ipc_try_send+0xb6>
				return -E_INVAL;
  800420cd22:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cd27:	e9 65 01 00 00       	jmpq   800420ce91 <sys_ipc_try_send+0x21b>
			}

			struct PageInfo *page;
			pte_t *pte;
			page = page_lookup(curenv->env_pml4e, srcva, &pte); 
  800420cd2c:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420cd33:	00 00 00 
  800420cd36:	ff d0                	callq  *%rax
  800420cd38:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420cd3f:	00 00 00 
  800420cd42:	48 98                	cltq   
  800420cd44:	48 89 c2             	mov    %rax,%rdx
  800420cd47:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420cd4e:	00 
  800420cd4f:	48 89 c2             	mov    %rax,%rdx
  800420cd52:	48 89 d0             	mov    %rdx,%rax
  800420cd55:	48 c1 e0 04          	shl    $0x4,%rax
  800420cd59:	48 29 d0             	sub    %rdx,%rax
  800420cd5c:	48 01 c8             	add    %rcx,%rax
  800420cd5f:	48 83 c0 08          	add    $0x8,%rax
  800420cd63:	48 8b 00             	mov    (%rax),%rax
  800420cd66:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420cd6d:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800420cd71:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420cd75:	48 89 ce             	mov    %rcx,%rsi
  800420cd78:	48 89 c7             	mov    %rax,%rdi
  800420cd7b:	48 b8 c5 35 20 04 80 	movabs $0x80042035c5,%rax
  800420cd82:	00 00 00 
  800420cd85:	ff d0                	callq  *%rax
  800420cd87:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
			if (page==NULL){
  800420cd8b:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420cd90:	75 0a                	jne    800420cd9c <sys_ipc_try_send+0x126>
				return -E_INVAL;
  800420cd92:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cd97:	e9 f5 00 00 00       	jmpq   800420ce91 <sys_ipc_try_send+0x21b>
			}
			if ((perm & PTE_W) && !(*pte & PTE_W)){
  800420cd9c:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420cd9f:	83 e0 02             	and    $0x2,%eax
  800420cda2:	85 c0                	test   %eax,%eax
  800420cda4:	74 19                	je     800420cdbf <sys_ipc_try_send+0x149>
  800420cda6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cdaa:	48 8b 00             	mov    (%rax),%rax
  800420cdad:	83 e0 02             	and    $0x2,%eax
  800420cdb0:	48 85 c0             	test   %rax,%rax
  800420cdb3:	75 0a                	jne    800420cdbf <sys_ipc_try_send+0x149>
				return -E_INVAL;
  800420cdb5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cdba:	e9 d2 00 00 00       	jmpq   800420ce91 <sys_ipc_try_send+0x21b>
			}
		
			//dst is mappable to (page trander
			if ((uintptr_t)target->env_ipc_dstva<UTOP){
  800420cdbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cdc3:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
  800420cdca:	48 89 c2             	mov    %rax,%rdx
  800420cdcd:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420cdd4:	00 00 00 
  800420cdd7:	48 39 c2             	cmp    %rax,%rdx
  800420cdda:	77 68                	ja     800420ce44 <sys_ipc_try_send+0x1ce>
				if ((uintptr_t)target->env_ipc_dstva%PGSIZE!=0){
  800420cddc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cde0:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
  800420cde7:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cdec:	48 85 c0             	test   %rax,%rax
  800420cdef:	74 0a                	je     800420cdfb <sys_ipc_try_send+0x185>
					return -E_INVAL;
  800420cdf1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420cdf6:	e9 96 00 00 00       	jmpq   800420ce91 <sys_ipc_try_send+0x21b>
				}
				result = page_insert(target->env_pml4e, page, target->env_ipc_dstva, perm);
  800420cdfb:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  800420cdfe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce02:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420ce09:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce0d:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ce14:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420ce18:	48 89 c7             	mov    %rax,%rdi
  800420ce1b:	48 b8 f8 34 20 04 80 	movabs $0x80042034f8,%rax
  800420ce22:	00 00 00 
  800420ce25:	ff d0                	callq  *%rax
  800420ce27:	89 45 ec             	mov    %eax,-0x14(%rbp)
				if(result<0){
  800420ce2a:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420ce2e:	79 07                	jns    800420ce37 <sys_ipc_try_send+0x1c1>
					return -E_NO_MEM;
  800420ce30:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420ce35:	eb 5a                	jmp    800420ce91 <sys_ipc_try_send+0x21b>
				}
				
				target->env_ipc_perm = perm;				
  800420ce37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce3b:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420ce3e:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
			}
		}

                target->env_ipc_recving = 0;
  800420ce44:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce48:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
                target->env_ipc_from = sys_getenvid();
  800420ce4f:	48 8b 5d d8          	mov    -0x28(%rbp),%rbx
  800420ce53:	48 b8 16 c6 20 04 80 	movabs $0x800420c616,%rax
  800420ce5a:	00 00 00 
  800420ce5d:	ff d0                	callq  *%rax
  800420ce5f:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
                target->env_ipc_value = value;
  800420ce65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce69:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800420ce6c:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
		target->env_status = ENV_RUNNABLE;
  800420ce72:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce76:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420ce7d:	00 00 00 
		target->env_tf.tf_regs.reg_rax = 0;
  800420ce80:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ce84:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420ce8b:	00 
		return 0;
  800420ce8c:	b8 00 00 00 00       	mov    $0x0,%eax

			//panic("sys_ipc_try_send not implemented");
}
  800420ce91:	48 83 c4 48          	add    $0x48,%rsp
  800420ce95:	5b                   	pop    %rbx
  800420ce96:	5d                   	pop    %rbp
  800420ce97:	c3                   	retq   

000000800420ce98 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420ce98:	55                   	push   %rbp
  800420ce99:	48 89 e5             	mov    %rsp,%rbp
  800420ce9c:	48 83 ec 10          	sub    $0x10,%rsp
  800420cea0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 4: Your code here.
	//cprintf("sys_ipc_recv\n");
	if ((uintptr_t)dstva<UTOP){
  800420cea4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420cea8:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ceaf:	00 00 00 
  800420ceb2:	48 39 c2             	cmp    %rax,%rdx
  800420ceb5:	77 5d                	ja     800420cf14 <sys_ipc_recv+0x7c>
		if ((uintptr_t)dstva%PGSIZE!=0){
  800420ceb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cebb:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420cec0:	48 85 c0             	test   %rax,%rax
  800420cec3:	74 0a                	je     800420cecf <sys_ipc_recv+0x37>
			return -E_INVAL;
  800420cec5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ceca:	e9 20 01 00 00       	jmpq   800420cfef <sys_ipc_recv+0x157>
		}
		curenv->env_ipc_dstva = dstva;
  800420cecf:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420ced6:	00 00 00 
  800420ced9:	ff d0                	callq  *%rax
  800420cedb:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420cee2:	00 00 00 
  800420cee5:	48 98                	cltq   
  800420cee7:	48 89 c2             	mov    %rax,%rdx
  800420ceea:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420cef1:	00 
  800420cef2:	48 89 c2             	mov    %rax,%rdx
  800420cef5:	48 89 d0             	mov    %rdx,%rax
  800420cef8:	48 c1 e0 04          	shl    $0x4,%rax
  800420cefc:	48 29 d0             	sub    %rdx,%rax
  800420ceff:	48 01 c8             	add    %rcx,%rax
  800420cf02:	48 83 c0 08          	add    $0x8,%rax
  800420cf06:	48 8b 00             	mov    (%rax),%rax
  800420cf09:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420cf0d:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	}
	curenv->env_ipc_recving = 1;
  800420cf14:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420cf1b:	00 00 00 
  800420cf1e:	ff d0                	callq  *%rax
  800420cf20:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420cf27:	00 00 00 
  800420cf2a:	48 98                	cltq   
  800420cf2c:	48 89 c2             	mov    %rax,%rdx
  800420cf2f:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420cf36:	00 
  800420cf37:	48 89 c2             	mov    %rax,%rdx
  800420cf3a:	48 89 d0             	mov    %rdx,%rax
  800420cf3d:	48 c1 e0 04          	shl    $0x4,%rax
  800420cf41:	48 29 d0             	sub    %rdx,%rax
  800420cf44:	48 01 c8             	add    %rcx,%rax
  800420cf47:	48 83 c0 08          	add    $0x8,%rax
  800420cf4b:	48 8b 00             	mov    (%rax),%rax
  800420cf4e:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	curenv->env_status = ENV_NOT_RUNNABLE;
  800420cf55:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420cf5c:	00 00 00 
  800420cf5f:	ff d0                	callq  *%rax
  800420cf61:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420cf68:	00 00 00 
  800420cf6b:	48 98                	cltq   
  800420cf6d:	48 89 c2             	mov    %rax,%rdx
  800420cf70:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420cf77:	00 
  800420cf78:	48 89 c2             	mov    %rax,%rdx
  800420cf7b:	48 89 d0             	mov    %rdx,%rax
  800420cf7e:	48 c1 e0 04          	shl    $0x4,%rax
  800420cf82:	48 29 d0             	sub    %rdx,%rax
  800420cf85:	48 01 c8             	add    %rcx,%rax
  800420cf88:	48 83 c0 08          	add    $0x8,%rax
  800420cf8c:	48 8b 00             	mov    (%rax),%rax
  800420cf8f:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420cf96:	00 00 00 
	curenv->env_ipc_dstva = dstva;
  800420cf99:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420cfa0:	00 00 00 
  800420cfa3:	ff d0                	callq  *%rax
  800420cfa5:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420cfac:	00 00 00 
  800420cfaf:	48 98                	cltq   
  800420cfb1:	48 89 c2             	mov    %rax,%rdx
  800420cfb4:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420cfbb:	00 
  800420cfbc:	48 89 c2             	mov    %rax,%rdx
  800420cfbf:	48 89 d0             	mov    %rdx,%rax
  800420cfc2:	48 c1 e0 04          	shl    $0x4,%rax
  800420cfc6:	48 29 d0             	sub    %rdx,%rax
  800420cfc9:	48 01 c8             	add    %rcx,%rax
  800420cfcc:	48 83 c0 08          	add    $0x8,%rax
  800420cfd0:	48 8b 00             	mov    (%rax),%rax
  800420cfd3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420cfd7:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	//cprintf("sys_ipc_recv exit\n");

	sys_yield();
  800420cfde:	48 b8 c0 c7 20 04 80 	movabs $0x800420c7c0,%rax
  800420cfe5:	00 00 00 
  800420cfe8:	ff d0                	callq  *%rax
	//panic("sys_ipc_recv not implemented");
	return 0;
  800420cfea:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420cfef:	c9                   	leaveq 
  800420cff0:	c3                   	retq   

000000800420cff1 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420cff1:	55                   	push   %rbp
  800420cff2:	48 89 e5             	mov    %rsp,%rbp
  800420cff5:	48 83 ec 30          	sub    $0x30,%rsp
  800420cff9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420cffd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420d001:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420d005:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420d009:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420d00d:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
	// Return any appropriate return value.
	// LAB 3: Your code here.

	//panic("syscall not implemented");	

	switch (syscallno) {
  800420d011:	48 83 7d f8 0c       	cmpq   $0xc,-0x8(%rbp)
  800420d016:	0f 87 a5 01 00 00    	ja     800420d1c1 <syscall+0x1d0>
  800420d01c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d020:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420d027:	00 
  800420d028:	48 b8 60 7b 21 04 80 	movabs $0x8004217b60,%rax
  800420d02f:	00 00 00 
  800420d032:	48 01 d0             	add    %rdx,%rax
  800420d035:	48 8b 00             	mov    (%rax),%rax
  800420d038:	ff e0                	jmpq   *%rax
		case SYS_cputs:
			sys_cputs((const char *)a1, (size_t)a2);
  800420d03a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d03e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d042:	48 89 d6             	mov    %rdx,%rsi
  800420d045:	48 89 c7             	mov    %rax,%rdi
  800420d048:	48 b8 75 c5 20 04 80 	movabs $0x800420c575,%rax
  800420d04f:	00 00 00 
  800420d052:	ff d0                	callq  *%rax
			return 0;
  800420d054:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d059:	e9 6a 01 00 00       	jmpq   800420d1c8 <syscall+0x1d7>
		case SYS_cgetc:
			return sys_cgetc();
  800420d05e:	48 b8 04 c6 20 04 80 	movabs $0x800420c604,%rax
  800420d065:	00 00 00 
  800420d068:	ff d0                	callq  *%rax
  800420d06a:	48 98                	cltq   
  800420d06c:	e9 57 01 00 00       	jmpq   800420d1c8 <syscall+0x1d7>
		case SYS_getenvid:
			return sys_getenvid();
  800420d071:	48 b8 16 c6 20 04 80 	movabs $0x800420c616,%rax
  800420d078:	00 00 00 
  800420d07b:	ff d0                	callq  *%rax
  800420d07d:	48 98                	cltq   
  800420d07f:	e9 44 01 00 00       	jmpq   800420d1c8 <syscall+0x1d7>
		case SYS_env_destroy:
			return sys_env_destroy((envid_t)a1);
  800420d084:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d088:	89 c7                	mov    %eax,%edi
  800420d08a:	48 b8 5c c6 20 04 80 	movabs $0x800420c65c,%rax
  800420d091:	00 00 00 
  800420d094:	ff d0                	callq  *%rax
  800420d096:	48 98                	cltq   
  800420d098:	e9 2b 01 00 00       	jmpq   800420d1c8 <syscall+0x1d7>
		case SYS_yield:
			sys_yield();
  800420d09d:	48 b8 c0 c7 20 04 80 	movabs $0x800420c7c0,%rax
  800420d0a4:	00 00 00 
  800420d0a7:	ff d0                	callq  *%rax
			return 0;
  800420d0a9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d0ae:	e9 15 01 00 00       	jmpq   800420d1c8 <syscall+0x1d7>
		case SYS_exofork:
			return sys_exofork();
  800420d0b3:	48 b8 d0 c7 20 04 80 	movabs $0x800420c7d0,%rax
  800420d0ba:	00 00 00 
  800420d0bd:	ff d0                	callq  *%rax
  800420d0bf:	48 98                	cltq   
  800420d0c1:	e9 02 01 00 00       	jmpq   800420d1c8 <syscall+0x1d7>
		case SYS_env_set_status:
			return sys_env_set_status(a1, a2);
  800420d0c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d0ca:	89 c2                	mov    %eax,%edx
  800420d0cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d0d0:	89 d6                	mov    %edx,%esi
  800420d0d2:	89 c7                	mov    %eax,%edi
  800420d0d4:	48 b8 b9 c8 20 04 80 	movabs $0x800420c8b9,%rax
  800420d0db:	00 00 00 
  800420d0de:	ff d0                	callq  *%rax
  800420d0e0:	48 98                	cltq   
  800420d0e2:	e9 e1 00 00 00       	jmpq   800420d1c8 <syscall+0x1d7>
		case SYS_page_alloc:
			return sys_page_alloc(a1, (void *)a2, a3);
  800420d0e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d0eb:	89 c6                	mov    %eax,%esi
  800420d0ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d0f1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d0f5:	89 d1                	mov    %edx,%ecx
  800420d0f7:	89 f2                	mov    %esi,%edx
  800420d0f9:	48 89 c6             	mov    %rax,%rsi
  800420d0fc:	89 cf                	mov    %ecx,%edi
  800420d0fe:	48 b8 6d c9 20 04 80 	movabs $0x800420c96d,%rax
  800420d105:	00 00 00 
  800420d108:	ff d0                	callq  *%rax
  800420d10a:	48 98                	cltq   
  800420d10c:	e9 b7 00 00 00       	jmpq   800420d1c8 <syscall+0x1d7>
		case SYS_page_map:
			return sys_page_map(a1,(void *)a2,a3,(void *)a4,a5);
  800420d111:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d115:	41 89 c0             	mov    %eax,%r8d
  800420d118:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420d11c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d120:	89 c6                	mov    %eax,%esi
  800420d122:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d126:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420d12a:	89 cf                	mov    %ecx,%edi
  800420d12c:	48 89 d1             	mov    %rdx,%rcx
  800420d12f:	89 f2                	mov    %esi,%edx
  800420d131:	48 89 c6             	mov    %rax,%rsi
  800420d134:	48 b8 6c ca 20 04 80 	movabs $0x800420ca6c,%rax
  800420d13b:	00 00 00 
  800420d13e:	ff d0                	callq  *%rax
  800420d140:	48 98                	cltq   
  800420d142:	e9 81 00 00 00       	jmpq   800420d1c8 <syscall+0x1d7>
		case SYS_page_unmap:
			return sys_page_unmap(a1,(void *)a2);
  800420d147:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d14b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d14f:	48 89 c6             	mov    %rax,%rsi
  800420d152:	89 d7                	mov    %edx,%edi
  800420d154:	48 b8 e5 cb 20 04 80 	movabs $0x800420cbe5,%rax
  800420d15b:	00 00 00 
  800420d15e:	ff d0                	callq  *%rax
  800420d160:	48 98                	cltq   
  800420d162:	eb 64                	jmp    800420d1c8 <syscall+0x1d7>
		case SYS_env_set_pgfault_upcall:
			return sys_env_set_pgfault_upcall((envid_t)a1, (void*)a2);
  800420d164:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d168:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d16c:	48 89 c6             	mov    %rax,%rsi
  800420d16f:	89 d7                	mov    %edx,%edi
  800420d171:	48 b8 1b c9 20 04 80 	movabs $0x800420c91b,%rax
  800420d178:	00 00 00 
  800420d17b:	ff d0                	callq  *%rax
  800420d17d:	48 98                	cltq   
  800420d17f:	eb 47                	jmp    800420d1c8 <syscall+0x1d7>
		case SYS_ipc_try_send:
			return sys_ipc_try_send((envid_t)a1, a2, (void *)a3, a4);
  800420d181:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d185:	89 c1                	mov    %eax,%ecx
  800420d187:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d18b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d18f:	89 d6                	mov    %edx,%esi
  800420d191:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d195:	89 d7                	mov    %edx,%edi
  800420d197:	48 89 c2             	mov    %rax,%rdx
  800420d19a:	48 b8 76 cc 20 04 80 	movabs $0x800420cc76,%rax
  800420d1a1:	00 00 00 
  800420d1a4:	ff d0                	callq  *%rax
  800420d1a6:	48 98                	cltq   
  800420d1a8:	eb 1e                	jmp    800420d1c8 <syscall+0x1d7>
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
  800420d1aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d1ae:	48 89 c7             	mov    %rax,%rdi
  800420d1b1:	48 b8 98 ce 20 04 80 	movabs $0x800420ce98,%rax
  800420d1b8:	00 00 00 
  800420d1bb:	ff d0                	callq  *%rax
  800420d1bd:	48 98                	cltq   
  800420d1bf:	eb 07                	jmp    800420d1c8 <syscall+0x1d7>
		default:
			return -E_NO_SYS;
  800420d1c1:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax

	}

	return 0;	
}
  800420d1c8:	c9                   	leaveq 
  800420d1c9:	c3                   	retq   

000000800420d1ca <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420d1ca:	55                   	push   %rbp
  800420d1cb:	48 89 e5             	mov    %rsp,%rbp
  800420d1ce:	48 81 ec c0 61 00 00 	sub    $0x61c0,%rsp
  800420d1d5:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420d1dc:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420d1e3:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420d1ea:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d1f1:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420d1f8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420d1fc:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d203:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d20a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420d20e:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420d215:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d21c:	48 89 d1             	mov    %rdx,%rcx
  800420d21f:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d224:	48 89 ce             	mov    %rcx,%rsi
  800420d227:	48 89 c7             	mov    %rax,%rdi
  800420d22a:	48 b8 19 ee 20 04 80 	movabs $0x800420ee19,%rax
  800420d231:	00 00 00 
  800420d234:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420d236:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420d23d:	00 
	uint64_t ret_offset=0;
  800420d23e:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d245:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420d246:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d24d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d251:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420d255:	74 0a                	je     800420d261 <list_func_die+0x97>
		return 0;
  800420d257:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d25c:	e9 8d 06 00 00       	jmpq   800420d8ee <list_func_die+0x724>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420d261:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420d268:	ba 38 00 00 00       	mov    $0x38,%edx
  800420d26d:	be 00 00 00 00       	mov    $0x0,%esi
  800420d272:	48 89 c7             	mov    %rax,%rdi
  800420d275:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  800420d27c:	00 00 00 
  800420d27f:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420d281:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d288:	be 11 00 00 00       	mov    $0x11,%esi
  800420d28d:	48 89 c7             	mov    %rax,%rdi
  800420d290:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  800420d297:	00 00 00 
  800420d29a:	ff d0                	callq  *%rax
  800420d29c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420d2a0:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d2a7:	be 12 00 00 00       	mov    $0x12,%esi
  800420d2ac:	48 89 c7             	mov    %rax,%rdi
  800420d2af:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  800420d2b6:	00 00 00 
  800420d2b9:	ff d0                	callq  *%rax
  800420d2bb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420d2bf:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420d2c4:	0f 84 1f 06 00 00    	je     800420d8e9 <list_func_die+0x71f>
  800420d2ca:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d2ce:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d2d2:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420d2d9:	0f 83 0a 06 00 00    	jae    800420d8e9 <list_func_die+0x71f>
  800420d2df:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420d2e4:	0f 84 ff 05 00 00    	je     800420d8e9 <list_func_die+0x71f>
  800420d2ea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d2ee:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d2f2:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420d2f9:	0f 86 ea 05 00 00    	jbe    800420d8e9 <list_func_die+0x71f>
	{
		info->rip_file = die->cu_die->die_name;
  800420d2ff:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d306:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d30d:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420d314:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d31b:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420d31e:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d325:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420d32c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d333:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420d337:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d33e:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420d345:	48 89 c7             	mov    %rax,%rdi
  800420d348:	48 b8 71 e9 20 04 80 	movabs $0x800420e971,%rax
  800420d34f:	00 00 00 
  800420d352:	ff d0                	callq  *%rax
  800420d354:	89 c2                	mov    %eax,%edx
  800420d356:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d35d:	89 50 18             	mov    %edx,0x18(%rax)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420d360:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d364:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420d368:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d36f:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420d373:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d37a:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d381:	48 85 c0             	test   %rax,%rax
  800420d384:	75 35                	jne    800420d3bb <list_func_die+0x1f1>
  800420d386:	48 b9 00 7f 21 04 80 	movabs $0x8004217f00,%rcx
  800420d38d:	00 00 00 
  800420d390:	48 ba 0c 7f 21 04 80 	movabs $0x8004217f0c,%rdx
  800420d397:	00 00 00 
  800420d39a:	be 91 00 00 00       	mov    $0x91,%esi
  800420d39f:	48 bf 21 7f 21 04 80 	movabs $0x8004217f21,%rdi
  800420d3a6:	00 00 00 
  800420d3a9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d3ae:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420d3b5:	00 00 00 
  800420d3b8:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420d3bb:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420d3c2:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d3c9:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420d3d0:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420d3d7:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420d3dc:	48 89 c7             	mov    %rax,%rdi
  800420d3df:	48 b8 0d 41 21 04 80 	movabs $0x800421410d,%rax
  800420d3e6:	00 00 00 
  800420d3e9:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420d3eb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420d3f2:	89 c2                	mov    %eax,%edx
  800420d3f4:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d3fb:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420d3fe:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d405:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420d40c:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d413:	00 00 00 
  800420d416:	48 8b 00             	mov    (%rax),%rax
  800420d419:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d420:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d427:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420d42b:	48 89 c7             	mov    %rax,%rdi
  800420d42e:	48 b8 ea 0d 21 04 80 	movabs $0x8004210dea,%rax
  800420d435:	00 00 00 
  800420d438:	ff d0                	callq  *%rax
  800420d43a:	83 f8 04             	cmp    $0x4,%eax
  800420d43d:	0f 84 9f 04 00 00    	je     800420d8e2 <list_func_die+0x718>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420d443:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420d44a:	48 83 f8 05          	cmp    $0x5,%rax
  800420d44e:	0f 85 8a 04 00 00    	jne    800420d8de <list_func_die+0x714>
				goto last;

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d454:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d45b:	be 49 00 00 00       	mov    $0x49,%esi
  800420d460:	48 89 c7             	mov    %rax,%rdi
  800420d463:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  800420d46a:	00 00 00 
  800420d46d:	ff d0                	callq  *%rax
  800420d46f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420d473:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d478:	0f 84 b6 00 00 00    	je     800420d534 <list_func_die+0x36a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d47e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d482:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d486:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d48a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d48e:	48 01 d0             	add    %rdx,%rax
  800420d491:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420d495:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d49c:	00 00 00 
  800420d49f:	48 8b 08             	mov    (%rax),%rcx
  800420d4a2:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d4a9:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420d4ad:	48 83 ec 08          	sub    $0x8,%rsp
  800420d4b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d4b5:	ff 70 30             	pushq  0x30(%rax)
  800420d4b8:	ff 70 28             	pushq  0x28(%rax)
  800420d4bb:	ff 70 20             	pushq  0x20(%rax)
  800420d4be:	ff 70 18             	pushq  0x18(%rax)
  800420d4c1:	ff 70 10             	pushq  0x10(%rax)
  800420d4c4:	ff 70 08             	pushq  0x8(%rax)
  800420d4c7:	ff 30                	pushq  (%rax)
  800420d4c9:	48 89 cf             	mov    %rcx,%rdi
  800420d4cc:	48 b8 73 0a 21 04 80 	movabs $0x8004210a73,%rax
  800420d4d3:	00 00 00 
  800420d4d6:	ff d0                	callq  *%rax
  800420d4d8:	48 83 c4 40          	add    $0x40,%rsp
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d4dc:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d4e3:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d4e8:	48 89 c7             	mov    %rax,%rdi
  800420d4eb:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  800420d4f2:	00 00 00 
  800420d4f5:	ff d0                	callq  *%rax
  800420d4f7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420d4fb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d500:	74 0e                	je     800420d510 <list_func_die+0x346>
				{
					ret_val = attr->u[0].u64;
  800420d502:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d506:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d50a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d50e:	eb 24                	jmp    800420d534 <list_func_die+0x36a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420d510:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d517:	be 49 00 00 00       	mov    $0x49,%esi
  800420d51c:	48 89 c7             	mov    %rax,%rdi
  800420d51f:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  800420d526:	00 00 00 
  800420d529:	ff d0                	callq  *%rax
  800420d52b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420d52f:	e9 3f ff ff ff       	jmpq   800420d473 <list_func_die+0x2a9>
				}
			}

			ret_offset = 0;
  800420d534:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d53b:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420d53c:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d543:	be 02 00 00 00       	mov    $0x2,%esi
  800420d548:	48 89 c7             	mov    %rax,%rdi
  800420d54b:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  800420d552:	00 00 00 
  800420d555:	ff d0                	callq  *%rax
  800420d557:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420d55b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d560:	0f 84 a0 00 00 00    	je     800420d606 <list_func_die+0x43c>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420d566:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d56a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420d56e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420d572:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d576:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420d57a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420d57e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d582:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d586:	48 83 f8 03          	cmp    $0x3,%rax
  800420d58a:	72 7a                	jb     800420d606 <list_func_die+0x43c>
  800420d58c:	48 83 f8 04          	cmp    $0x4,%rax
  800420d590:	76 06                	jbe    800420d598 <list_func_die+0x3ce>
  800420d592:	48 83 f8 0a          	cmp    $0xa,%rax
  800420d596:	75 6e                	jne    800420d606 <list_func_die+0x43c>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420d598:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420d59f:	00 
						atom = *(loc_ptr++);
  800420d5a0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d5a4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d5a8:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420d5ac:	0f b6 00             	movzbl (%rax),%eax
  800420d5af:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420d5b2:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420d5b7:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420d5bb:	75 48                	jne    800420d605 <list_func_die+0x43b>
							uint8_t *p = loc_ptr;
  800420d5bd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d5c1:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420d5c8:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420d5cf:	48 89 c7             	mov    %rax,%rdi
  800420d5d2:	48 b8 0e f8 20 04 80 	movabs $0x800420f80e,%rax
  800420d5d9:	00 00 00 
  800420d5dc:	ff d0                	callq  *%rax
  800420d5de:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420d5e2:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420d5e9:	48 89 c2             	mov    %rax,%rdx
  800420d5ec:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420d5f0:	48 29 c2             	sub    %rax,%rdx
  800420d5f3:	48 89 d0             	mov    %rdx,%rax
  800420d5f6:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420d5fa:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420d601:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420d605:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420d606:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d60d:	8b 50 28             	mov    0x28(%rax),%edx
  800420d610:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d614:	89 c1                	mov    %eax,%ecx
  800420d616:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d61d:	48 63 d2             	movslq %edx,%rdx
  800420d620:	48 83 c2 08          	add    $0x8,%rdx
  800420d624:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420d628:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d62f:	8b 50 28             	mov    0x28(%rax),%edx
  800420d632:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d639:	48 63 d2             	movslq %edx,%rdx
  800420d63c:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420d640:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d644:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420d649:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d650:	8b 40 28             	mov    0x28(%rax),%eax
  800420d653:	8d 50 01             	lea    0x1(%rax),%edx
  800420d656:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d65d:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420d660:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d667:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d66e:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d673:	48 89 ce             	mov    %rcx,%rsi
  800420d676:	48 89 c7             	mov    %rax,%rdi
  800420d679:	48 b8 19 ee 20 04 80 	movabs $0x800420ee19,%rax
  800420d680:	00 00 00 
  800420d683:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d685:	e9 1c 02 00 00       	jmpq   800420d8a6 <list_func_die+0x6dc>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420d68a:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420d691:	48 83 f8 05          	cmp    $0x5,%rax
  800420d695:	0f 85 46 02 00 00    	jne    800420d8e1 <list_func_die+0x717>
					break;

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d69b:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d6a2:	be 49 00 00 00       	mov    $0x49,%esi
  800420d6a7:	48 89 c7             	mov    %rax,%rdi
  800420d6aa:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  800420d6b1:	00 00 00 
  800420d6b4:	ff d0                	callq  *%rax
  800420d6b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420d6ba:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d6bf:	0f 84 90 00 00 00    	je     800420d755 <list_func_die+0x58b>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d6c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d6c9:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d6cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d6d1:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d6d5:	48 01 d0             	add    %rdx,%rax
  800420d6d8:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420d6dc:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d6e3:	00 00 00 
  800420d6e6:	48 8b 08             	mov    (%rax),%rcx
  800420d6e9:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420d6f0:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420d6f4:	48 83 ec 08          	sub    $0x8,%rsp
  800420d6f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d6fc:	ff 70 30             	pushq  0x30(%rax)
  800420d6ff:	ff 70 28             	pushq  0x28(%rax)
  800420d702:	ff 70 20             	pushq  0x20(%rax)
  800420d705:	ff 70 18             	pushq  0x18(%rax)
  800420d708:	ff 70 10             	pushq  0x10(%rax)
  800420d70b:	ff 70 08             	pushq  0x8(%rax)
  800420d70e:	ff 30                	pushq  (%rax)
  800420d710:	48 89 cf             	mov    %rcx,%rdi
  800420d713:	48 b8 73 0a 21 04 80 	movabs $0x8004210a73,%rax
  800420d71a:	00 00 00 
  800420d71d:	ff d0                	callq  *%rax
  800420d71f:	48 83 c4 40          	add    $0x40,%rsp
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d723:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d72a:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d72f:	48 89 c7             	mov    %rax,%rdi
  800420d732:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  800420d739:	00 00 00 
  800420d73c:	ff d0                	callq  *%rax
  800420d73e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420d742:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d747:	74 0c                	je     800420d755 <list_func_die+0x58b>
					{
						ret_val = attr->u[0].u64;
  800420d749:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d74d:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d751:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420d755:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d75c:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420d75d:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420d764:	be 02 00 00 00       	mov    $0x2,%esi
  800420d769:	48 89 c7             	mov    %rax,%rdi
  800420d76c:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  800420d773:	00 00 00 
  800420d776:	ff d0                	callq  *%rax
  800420d778:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420d77c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420d781:	0f 84 a0 00 00 00    	je     800420d827 <list_func_die+0x65d>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420d787:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d78b:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420d78f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420d793:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d797:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420d79b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420d79f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d7a3:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420d7a7:	48 83 f8 03          	cmp    $0x3,%rax
  800420d7ab:	72 7a                	jb     800420d827 <list_func_die+0x65d>
  800420d7ad:	48 83 f8 04          	cmp    $0x4,%rax
  800420d7b1:	76 06                	jbe    800420d7b9 <list_func_die+0x5ef>
  800420d7b3:	48 83 f8 0a          	cmp    $0xa,%rax
  800420d7b7:	75 6e                	jne    800420d827 <list_func_die+0x65d>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420d7b9:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420d7c0:	00 
							atom = *(loc_ptr++);
  800420d7c1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d7c5:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420d7c9:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420d7cd:	0f b6 00             	movzbl (%rax),%eax
  800420d7d0:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420d7d3:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420d7d8:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420d7dc:	75 48                	jne    800420d826 <list_func_die+0x65c>
								uint8_t *p = loc_ptr;
  800420d7de:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d7e2:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420d7e9:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420d7f0:	48 89 c7             	mov    %rax,%rdi
  800420d7f3:	48 b8 0e f8 20 04 80 	movabs $0x800420f80e,%rax
  800420d7fa:	00 00 00 
  800420d7fd:	ff d0                	callq  *%rax
  800420d7ff:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420d803:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420d80a:	48 89 c2             	mov    %rax,%rdx
  800420d80d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420d811:	48 29 c2             	sub    %rax,%rdx
  800420d814:	48 89 d0             	mov    %rdx,%rax
  800420d817:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420d81b:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420d822:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420d826:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420d827:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d82e:	8b 50 28             	mov    0x28(%rax),%edx
  800420d831:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d835:	89 c1                	mov    %eax,%ecx
  800420d837:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d83e:	48 63 d2             	movslq %edx,%rdx
  800420d841:	48 83 c2 08          	add    $0x8,%rdx
  800420d845:	89 4c 90 0c          	mov    %ecx,0xc(%rax,%rdx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420d849:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d850:	8b 50 28             	mov    0x28(%rax),%edx
  800420d853:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d85a:	48 63 d2             	movslq %edx,%rdx
  800420d85d:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420d861:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d865:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420d86a:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d871:	8b 40 28             	mov    0x28(%rax),%eax
  800420d874:	8d 50 01             	lea    0x1(%rax),%edx
  800420d877:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420d87e:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420d881:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420d888:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420d88f:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d894:	48 89 ce             	mov    %rcx,%rsi
  800420d897:	48 89 c7             	mov    %rax,%rdi
  800420d89a:	48 b8 19 ee 20 04 80 	movabs $0x800420ee19,%rax
  800420d8a1:	00 00 00 
  800420d8a4:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d8a6:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420d8ad:	00 00 00 
  800420d8b0:	48 8b 00             	mov    (%rax),%rax
  800420d8b3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420d8b7:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420d8be:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420d8c5:	48 89 c7             	mov    %rax,%rdi
  800420d8c8:	48 b8 e8 0b 21 04 80 	movabs $0x8004210be8,%rax
  800420d8cf:	00 00 00 
  800420d8d2:	ff d0                	callq  *%rax
  800420d8d4:	85 c0                	test   %eax,%eax
  800420d8d6:	0f 84 ae fd ff ff    	je     800420d68a <list_func_die+0x4c0>
  800420d8dc:	eb 04                	jmp    800420d8e2 <list_func_die+0x718>
		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
				goto last;
  800420d8de:	90                   	nop
  800420d8df:	eb 01                	jmp    800420d8e2 <list_func_die+0x718>
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
					break;
  800420d8e1:	90                   	nop
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420d8e2:	b8 01 00 00 00       	mov    $0x1,%eax
  800420d8e7:	eb 05                	jmp    800420d8ee <list_func_die+0x724>
	}

	return 0;
  800420d8e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d8ee:	c9                   	leaveq 
  800420d8ef:	c3                   	retq   

000000800420d8f0 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420d8f0:	55                   	push   %rbp
  800420d8f1:	48 89 e5             	mov    %rsp,%rbp
  800420d8f4:	48 81 ec c0 91 00 00 	sub    $0x91c0,%rsp
  800420d8fb:	48 89 bd 48 6e ff ff 	mov    %rdi,-0x91b8(%rbp)
  800420d902:	48 89 b5 40 6e ff ff 	mov    %rsi,-0x91c0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420d909:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d910:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420d911:	48 8b 85 48 6e ff ff 	mov    -0x91b8(%rbp),%rax
  800420d918:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420d91c:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d923:	48 bf 2f 7f 21 04 80 	movabs $0x8004217f2f,%rdi
  800420d92a:	00 00 00 
  800420d92d:	48 89 38             	mov    %rdi,(%rax)
	info->rip_line = 0;
  800420d930:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d937:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420d93e:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d945:	48 bf 2f 7f 21 04 80 	movabs $0x8004217f2f,%rdi
  800420d94c:	00 00 00 
  800420d94f:	48 89 78 10          	mov    %rdi,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420d953:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d95a:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420d961:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d968:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420d96f:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420d973:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d97a:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420d981:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420d988:	00 00 00 
  800420d98b:	48 39 85 48 6e ff ff 	cmp    %rax,-0x91b8(%rbp)
  800420d992:	76 13                	jbe    800420d9a7 <debuginfo_rip+0xb7>
		elf = (void *)0x10000 + KERNBASE;
  800420d994:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420d99b:	00 00 00 
  800420d99e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d9a2:	e9 2c 01 00 00       	jmpq   800420dad3 <debuginfo_rip+0x1e3>
	} else {
		if(curenv != lastenv) {
  800420d9a7:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420d9ae:	00 00 00 
  800420d9b1:	ff d0                	callq  *%rax
  800420d9b3:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420d9ba:	00 00 00 
  800420d9bd:	48 98                	cltq   
  800420d9bf:	48 89 c2             	mov    %rax,%rdx
  800420d9c2:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420d9c9:	00 
  800420d9ca:	48 89 c2             	mov    %rax,%rdx
  800420d9cd:	48 89 d0             	mov    %rdx,%rax
  800420d9d0:	48 c1 e0 04          	shl    $0x4,%rax
  800420d9d4:	48 29 d0             	sub    %rdx,%rax
  800420d9d7:	48 01 c8             	add    %rcx,%rax
  800420d9da:	48 83 c0 08          	add    $0x8,%rax
  800420d9de:	48 8b 10             	mov    (%rax),%rdx
  800420d9e1:	48 b8 98 32 36 04 80 	movabs $0x8004363298,%rax
  800420d9e8:	00 00 00 
  800420d9eb:	48 8b 00             	mov    (%rax),%rax
  800420d9ee:	48 39 c2             	cmp    %rax,%rdx
  800420d9f1:	0f 84 97 00 00 00    	je     800420da8e <debuginfo_rip+0x19e>
			find_debug_sections((uintptr_t)curenv->elf);
  800420d9f7:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420d9fe:	00 00 00 
  800420da01:	ff d0                	callq  *%rax
  800420da03:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420da0a:	00 00 00 
  800420da0d:	48 98                	cltq   
  800420da0f:	48 89 c2             	mov    %rax,%rdx
  800420da12:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420da19:	00 
  800420da1a:	48 89 c2             	mov    %rax,%rdx
  800420da1d:	48 89 d0             	mov    %rdx,%rax
  800420da20:	48 c1 e0 04          	shl    $0x4,%rax
  800420da24:	48 29 d0             	sub    %rdx,%rax
  800420da27:	48 01 c8             	add    %rcx,%rax
  800420da2a:	48 83 c0 08          	add    $0x8,%rax
  800420da2e:	48 8b 00             	mov    (%rax),%rax
  800420da31:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420da38:	48 89 c7             	mov    %rax,%rdi
  800420da3b:	48 b8 08 43 21 04 80 	movabs $0x8004214308,%rax
  800420da42:	00 00 00 
  800420da45:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420da47:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420da4e:	00 00 00 
  800420da51:	ff d0                	callq  *%rax
  800420da53:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420da5a:	00 00 00 
  800420da5d:	48 98                	cltq   
  800420da5f:	48 89 c2             	mov    %rax,%rdx
  800420da62:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420da69:	00 
  800420da6a:	48 89 c2             	mov    %rax,%rdx
  800420da6d:	48 89 d0             	mov    %rdx,%rax
  800420da70:	48 c1 e0 04          	shl    $0x4,%rax
  800420da74:	48 29 d0             	sub    %rdx,%rax
  800420da77:	48 01 c8             	add    %rcx,%rax
  800420da7a:	48 83 c0 08          	add    $0x8,%rax
  800420da7e:	48 8b 10             	mov    (%rax),%rdx
  800420da81:	48 b8 98 32 36 04 80 	movabs $0x8004363298,%rax
  800420da88:	00 00 00 
  800420da8b:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420da8e:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800420da95:	00 00 00 
  800420da98:	ff d0                	callq  *%rax
  800420da9a:	48 b9 20 50 36 04 80 	movabs $0x8004365020,%rcx
  800420daa1:	00 00 00 
  800420daa4:	48 98                	cltq   
  800420daa6:	48 89 c2             	mov    %rax,%rdx
  800420daa9:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800420dab0:	00 
  800420dab1:	48 89 c2             	mov    %rax,%rdx
  800420dab4:	48 89 d0             	mov    %rdx,%rax
  800420dab7:	48 c1 e0 04          	shl    $0x4,%rax
  800420dabb:	48 29 d0             	sub    %rdx,%rax
  800420dabe:	48 01 c8             	add    %rcx,%rax
  800420dac1:	48 83 c0 08          	add    $0x8,%rax
  800420dac5:	48 8b 00             	mov    (%rax),%rax
  800420dac8:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420dacf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420dad3:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420dada:	00 00 00 
  800420dadd:	48 8b 00             	mov    (%rax),%rax
  800420dae0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420dae4:	48 89 d6             	mov    %rdx,%rsi
  800420dae7:	48 89 c7             	mov    %rax,%rdi
  800420daea:	48 b8 bd fa 20 04 80 	movabs $0x800420fabd,%rax
  800420daf1:	00 00 00 
  800420daf4:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420daf6:	48 bf 39 7f 21 04 80 	movabs $0x8004217f39,%rdi
  800420dafd:	00 00 00 
  800420db00:	48 b8 88 42 21 04 80 	movabs $0x8004214288,%rax
  800420db07:	00 00 00 
  800420db0a:	ff d0                	callq  *%rax
  800420db0c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420db10:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420db17:	00 00 00 
  800420db1a:	48 8b 00             	mov    (%rax),%rax
  800420db1d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420db21:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420db25:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420db29:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420db30:	00 00 00 
  800420db33:	48 8b 00             	mov    (%rax),%rax
  800420db36:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420db3a:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420db3e:	48 89 50 10          	mov    %rdx,0x10(%rax)

	assert(dbg->dbg_info_size);
  800420db42:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420db49:	00 00 00 
  800420db4c:	48 8b 00             	mov    (%rax),%rax
  800420db4f:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420db53:	48 85 c0             	test   %rax,%rax
  800420db56:	0f 85 78 01 00 00    	jne    800420dcd4 <debuginfo_rip+0x3e4>
  800420db5c:	48 b9 45 7f 21 04 80 	movabs $0x8004217f45,%rcx
  800420db63:	00 00 00 
  800420db66:	48 ba 0c 7f 21 04 80 	movabs $0x8004217f0c,%rdx
  800420db6d:	00 00 00 
  800420db70:	be 37 01 00 00       	mov    $0x137,%esi
  800420db75:	48 bf 21 7f 21 04 80 	movabs $0x8004217f21,%rdi
  800420db7c:	00 00 00 
  800420db7f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420db84:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420db8b:	00 00 00 
  800420db8e:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420db91:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420db98:	00 00 00 
  800420db9b:	48 8b 00             	mov    (%rax),%rax
  800420db9e:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  800420dba2:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  800420dba9:	be 00 00 00 00       	mov    $0x0,%esi
  800420dbae:	48 89 c7             	mov    %rax,%rdi
  800420dbb1:	48 b8 e8 0b 21 04 80 	movabs $0x8004210be8,%rax
  800420dbb8:	00 00 00 
  800420dbbb:	ff d0                	callq  *%rax
  800420dbbd:	83 f8 04             	cmp    $0x4,%eax
  800420dbc0:	75 05                	jne    800420dbc7 <debuginfo_rip+0x2d7>
			continue;
  800420dbc2:	e9 0d 01 00 00       	jmpq   800420dcd4 <debuginfo_rip+0x3e4>

		cudie.cu_header = &cu;
  800420dbc7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420dbcb:	48 89 85 20 a2 ff ff 	mov    %rax,-0x5de0(%rbp)
		cudie.cu_die = NULL;
  800420dbd2:	48 c7 85 28 a2 ff ff 	movq   $0x0,-0x5dd8(%rbp)
  800420dbd9:	00 00 00 00 

		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420dbdd:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420dbe4:	00 00 00 
  800420dbe7:	48 8b 00             	mov    (%rax),%rax
  800420dbea:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800420dbf1:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  800420dbf8:	48 8d 75 a0          	lea    -0x60(%rbp),%rsi
  800420dbfc:	48 89 c7             	mov    %rax,%rdi
  800420dbff:	48 b8 ea 0d 21 04 80 	movabs $0x8004210dea,%rax
  800420dc06:	00 00 00 
  800420dc09:	ff d0                	callq  *%rax
  800420dc0b:	83 f8 04             	cmp    $0x4,%eax
  800420dc0e:	75 05                	jne    800420dc15 <debuginfo_rip+0x325>
			continue;
  800420dc10:	e9 bf 00 00 00       	jmpq   800420dcd4 <debuginfo_rip+0x3e4>

		die.cu_header = &cu;
  800420dc15:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420dc19:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
		die.cu_die = &cudie;
  800420dc20:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  800420dc27:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420dc2e:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420dc35:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800420dc3c:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420dc43:	48 89 ce             	mov    %rcx,%rsi
  800420dc46:	48 89 c7             	mov    %rax,%rdi
  800420dc49:	48 b8 ca d1 20 04 80 	movabs $0x800420d1ca,%rax
  800420dc50:	00 00 00 
  800420dc53:	ff d0                	callq  *%rax
  800420dc55:	85 c0                	test   %eax,%eax
  800420dc57:	0f 85 ac 00 00 00    	jne    800420dd09 <debuginfo_rip+0x419>
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420dc5d:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420dc64:	00 00 00 
  800420dc67:	48 8b 00             	mov    (%rax),%rax
  800420dc6a:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  800420dc6e:	48 8d 95 50 6e ff ff 	lea    -0x91b0(%rbp),%rdx
  800420dc75:	48 8d b5 30 cf ff ff 	lea    -0x30d0(%rbp),%rsi
  800420dc7c:	48 89 c7             	mov    %rax,%rdi
  800420dc7f:	48 b8 e8 0b 21 04 80 	movabs $0x8004210be8,%rax
  800420dc86:	00 00 00 
  800420dc89:	ff d0                	callq  *%rax
  800420dc8b:	85 c0                	test   %eax,%eax
  800420dc8d:	79 02                	jns    800420dc91 <debuginfo_rip+0x3a1>
				break; 
  800420dc8f:	eb 43                	jmp    800420dcd4 <debuginfo_rip+0x3e4>
			die = die2;
  800420dc91:	48 8d 85 30 cf ff ff 	lea    -0x30d0(%rbp),%rax
  800420dc98:	48 8d 8d 50 6e ff ff 	lea    -0x91b0(%rbp),%rcx
  800420dc9f:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420dca4:	48 89 ce             	mov    %rcx,%rsi
  800420dca7:	48 89 c7             	mov    %rax,%rdi
  800420dcaa:	48 b8 19 ee 20 04 80 	movabs $0x800420ee19,%rax
  800420dcb1:	00 00 00 
  800420dcb4:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420dcb6:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420dcba:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
			die.cu_die = &cudie;
  800420dcc1:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  800420dcc8:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
		}
  800420dccf:	e9 5a ff ff ff       	jmpq   800420dc2e <debuginfo_rip+0x33e>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;

	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420dcd4:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420dcdb:	00 00 00 
  800420dcde:	48 8b 00             	mov    (%rax),%rax
  800420dce1:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420dce5:	48 89 d6             	mov    %rdx,%rsi
  800420dce8:	48 89 c7             	mov    %rax,%rdi
  800420dceb:	48 b8 99 fb 20 04 80 	movabs $0x800420fb99,%rax
  800420dcf2:	00 00 00 
  800420dcf5:	ff d0                	callq  *%rax
  800420dcf7:	85 c0                	test   %eax,%eax
  800420dcf9:	0f 84 92 fe ff ff    	je     800420db91 <debuginfo_rip+0x2a1>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}

	return -1;
  800420dcff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420dd04:	e9 c7 00 00 00       	jmpq   800420ddd0 <debuginfo_rip+0x4e0>
		die.cu_header = &cu;
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
  800420dd09:	90                   	nop

	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420dd0a:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420dd11:	00 00 00 
  800420dd14:	48 8b 00             	mov    (%rax),%rax
  800420dd17:	be 00 00 00 00       	mov    $0x0,%esi
  800420dd1c:	48 89 c7             	mov    %rax,%rdi
  800420dd1f:	48 b8 00 35 21 04 80 	movabs $0x8004213500,%rax
  800420dd26:	00 00 00 
  800420dd29:	ff d0                	callq  *%rax
  800420dd2b:	83 f8 01             	cmp    $0x1,%eax
  800420dd2e:	75 0a                	jne    800420dd3a <debuginfo_rip+0x44a>
		return -1;
  800420dd30:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420dd35:	e9 96 00 00 00       	jmpq   800420ddd0 <debuginfo_rip+0x4e0>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420dd3a:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  800420dd41:	00 00 00 
  800420dd44:	48 8b 08             	mov    (%rax),%rcx
  800420dd47:	48 b8 98 b6 22 04 80 	movabs $0x800422b698,%rax
  800420dd4e:	00 00 00 
  800420dd51:	48 8b 10             	mov    (%rax),%rdx
  800420dd54:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420dd5b:	00 00 00 
  800420dd5e:	48 8b 00             	mov    (%rax),%rax
  800420dd61:	48 8b b5 48 6e ff ff 	mov    -0x91b8(%rbp),%rsi
  800420dd68:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420dd6e:	48 89 c7             	mov    %rax,%rdi
  800420dd71:	48 b8 08 10 21 04 80 	movabs $0x8004211008,%rax
  800420dd78:	00 00 00 
  800420dd7b:	ff d0                	callq  *%rax
  800420dd7d:	85 c0                	test   %eax,%eax
  800420dd7f:	75 4a                	jne    800420ddcb <debuginfo_rip+0x4db>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr,
  800420dd81:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420dd88:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420dd8f:	48 b8 98 b6 22 04 80 	movabs $0x800422b698,%rax
  800420dd96:	00 00 00 
  800420dd99:	48 8b 30             	mov    (%rax),%rsi
  800420dd9c:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800420dda3:	00 00 00 
  800420dda6:	48 8b 00             	mov    (%rax),%rax
  800420dda9:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420ddb0:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420ddb6:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420ddbc:	48 89 c7             	mov    %rax,%rdi
  800420ddbf:	48 b8 f8 22 21 04 80 	movabs $0x80042122f8,%rax
  800420ddc6:	00 00 00 
  800420ddc9:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420ddcb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ddd0:	c9                   	leaveq 
  800420ddd1:	c3                   	retq   

000000800420ddd2 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420ddd2:	55                   	push   %rbp
  800420ddd3:	48 89 e5             	mov    %rsp,%rbp
  800420ddd6:	48 83 ec 30          	sub    $0x30,%rsp
  800420ddda:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ddde:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420dde2:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420dde6:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  800420dde9:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  800420dded:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420ddf1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420ddf4:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420ddf8:	77 54                	ja     800420de4e <printnum+0x7c>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420ddfa:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800420ddfd:	8d 78 ff             	lea    -0x1(%rax),%edi
  800420de00:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  800420de03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de07:	ba 00 00 00 00       	mov    $0x0,%edx
  800420de0c:	48 f7 f6             	div    %rsi
  800420de0f:	49 89 c2             	mov    %rax,%r10
  800420de12:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  800420de15:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420de18:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420de1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de20:	41 89 c9             	mov    %ecx,%r9d
  800420de23:	41 89 f8             	mov    %edi,%r8d
  800420de26:	89 d1                	mov    %edx,%ecx
  800420de28:	4c 89 d2             	mov    %r10,%rdx
  800420de2b:	48 89 c7             	mov    %rax,%rdi
  800420de2e:	48 b8 d2 dd 20 04 80 	movabs $0x800420ddd2,%rax
  800420de35:	00 00 00 
  800420de38:	ff d0                	callq  *%rax
  800420de3a:	eb 1c                	jmp    800420de58 <printnum+0x86>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800420de3c:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420de40:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420de43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de47:	48 89 ce             	mov    %rcx,%rsi
  800420de4a:	89 d7                	mov    %edx,%edi
  800420de4c:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420de4e:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  800420de52:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  800420de56:	7f e4                	jg     800420de3c <printnum+0x6a>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420de58:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420de5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de5f:	ba 00 00 00 00       	mov    $0x0,%edx
  800420de64:	48 f7 f1             	div    %rcx
  800420de67:	48 b8 b0 80 21 04 80 	movabs $0x80042180b0,%rax
  800420de6e:	00 00 00 
  800420de71:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
  800420de75:	0f be d0             	movsbl %al,%edx
  800420de78:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420de7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de80:	48 89 ce             	mov    %rcx,%rsi
  800420de83:	89 d7                	mov    %edx,%edi
  800420de85:	ff d0                	callq  *%rax
}
  800420de87:	90                   	nop
  800420de88:	c9                   	leaveq 
  800420de89:	c3                   	retq   

000000800420de8a <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420de8a:	55                   	push   %rbp
  800420de8b:	48 89 e5             	mov    %rsp,%rbp
  800420de8e:	48 83 ec 20          	sub    $0x20,%rsp
  800420de92:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420de96:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420de99:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420de9d:	7e 4f                	jle    800420deee <getuint+0x64>
		x= va_arg(*ap, unsigned long long);
  800420de9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dea3:	8b 00                	mov    (%rax),%eax
  800420dea5:	83 f8 30             	cmp    $0x30,%eax
  800420dea8:	73 24                	jae    800420dece <getuint+0x44>
  800420deaa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420deae:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420deb2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420deb6:	8b 00                	mov    (%rax),%eax
  800420deb8:	89 c0                	mov    %eax,%eax
  800420deba:	48 01 d0             	add    %rdx,%rax
  800420debd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dec1:	8b 12                	mov    (%rdx),%edx
  800420dec3:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420dec6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420deca:	89 0a                	mov    %ecx,(%rdx)
  800420decc:	eb 14                	jmp    800420dee2 <getuint+0x58>
  800420dece:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ded2:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ded6:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420deda:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dede:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420dee2:	48 8b 00             	mov    (%rax),%rax
  800420dee5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420dee9:	e9 9d 00 00 00       	jmpq   800420df8b <getuint+0x101>
	else if (lflag)
  800420deee:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420def2:	74 4c                	je     800420df40 <getuint+0xb6>
		x= va_arg(*ap, unsigned long);
  800420def4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420def8:	8b 00                	mov    (%rax),%eax
  800420defa:	83 f8 30             	cmp    $0x30,%eax
  800420defd:	73 24                	jae    800420df23 <getuint+0x99>
  800420deff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df03:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420df07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df0b:	8b 00                	mov    (%rax),%eax
  800420df0d:	89 c0                	mov    %eax,%eax
  800420df0f:	48 01 d0             	add    %rdx,%rax
  800420df12:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df16:	8b 12                	mov    (%rdx),%edx
  800420df18:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420df1b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df1f:	89 0a                	mov    %ecx,(%rdx)
  800420df21:	eb 14                	jmp    800420df37 <getuint+0xad>
  800420df23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df27:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420df2b:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420df2f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df33:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420df37:	48 8b 00             	mov    (%rax),%rax
  800420df3a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420df3e:	eb 4b                	jmp    800420df8b <getuint+0x101>
	else
		x= va_arg(*ap, unsigned int);
  800420df40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df44:	8b 00                	mov    (%rax),%eax
  800420df46:	83 f8 30             	cmp    $0x30,%eax
  800420df49:	73 24                	jae    800420df6f <getuint+0xe5>
  800420df4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df4f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420df53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df57:	8b 00                	mov    (%rax),%eax
  800420df59:	89 c0                	mov    %eax,%eax
  800420df5b:	48 01 d0             	add    %rdx,%rax
  800420df5e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df62:	8b 12                	mov    (%rdx),%edx
  800420df64:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420df67:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df6b:	89 0a                	mov    %ecx,(%rdx)
  800420df6d:	eb 14                	jmp    800420df83 <getuint+0xf9>
  800420df6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420df73:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420df77:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420df7b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df7f:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420df83:	8b 00                	mov    (%rax),%eax
  800420df85:	89 c0                	mov    %eax,%eax
  800420df87:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420df8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420df8f:	c9                   	leaveq 
  800420df90:	c3                   	retq   

000000800420df91 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420df91:	55                   	push   %rbp
  800420df92:	48 89 e5             	mov    %rsp,%rbp
  800420df95:	48 83 ec 20          	sub    $0x20,%rsp
  800420df99:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420df9d:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420dfa0:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420dfa4:	7e 4f                	jle    800420dff5 <getint+0x64>
		x=va_arg(*ap, long long);
  800420dfa6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfaa:	8b 00                	mov    (%rax),%eax
  800420dfac:	83 f8 30             	cmp    $0x30,%eax
  800420dfaf:	73 24                	jae    800420dfd5 <getint+0x44>
  800420dfb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfb5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420dfb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfbd:	8b 00                	mov    (%rax),%eax
  800420dfbf:	89 c0                	mov    %eax,%eax
  800420dfc1:	48 01 d0             	add    %rdx,%rax
  800420dfc4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dfc8:	8b 12                	mov    (%rdx),%edx
  800420dfca:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420dfcd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dfd1:	89 0a                	mov    %ecx,(%rdx)
  800420dfd3:	eb 14                	jmp    800420dfe9 <getint+0x58>
  800420dfd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfd9:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420dfdd:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420dfe1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dfe5:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420dfe9:	48 8b 00             	mov    (%rax),%rax
  800420dfec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420dff0:	e9 9d 00 00 00       	jmpq   800420e092 <getint+0x101>
	else if (lflag)
  800420dff5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420dff9:	74 4c                	je     800420e047 <getint+0xb6>
		x=va_arg(*ap, long);
  800420dffb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dfff:	8b 00                	mov    (%rax),%eax
  800420e001:	83 f8 30             	cmp    $0x30,%eax
  800420e004:	73 24                	jae    800420e02a <getint+0x99>
  800420e006:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e00a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e00e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e012:	8b 00                	mov    (%rax),%eax
  800420e014:	89 c0                	mov    %eax,%eax
  800420e016:	48 01 d0             	add    %rdx,%rax
  800420e019:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e01d:	8b 12                	mov    (%rdx),%edx
  800420e01f:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e022:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e026:	89 0a                	mov    %ecx,(%rdx)
  800420e028:	eb 14                	jmp    800420e03e <getint+0xad>
  800420e02a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e02e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e032:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420e036:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e03a:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e03e:	48 8b 00             	mov    (%rax),%rax
  800420e041:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e045:	eb 4b                	jmp    800420e092 <getint+0x101>
	else
		x=va_arg(*ap, int);
  800420e047:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e04b:	8b 00                	mov    (%rax),%eax
  800420e04d:	83 f8 30             	cmp    $0x30,%eax
  800420e050:	73 24                	jae    800420e076 <getint+0xe5>
  800420e052:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e056:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420e05a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e05e:	8b 00                	mov    (%rax),%eax
  800420e060:	89 c0                	mov    %eax,%eax
  800420e062:	48 01 d0             	add    %rdx,%rax
  800420e065:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e069:	8b 12                	mov    (%rdx),%edx
  800420e06b:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420e06e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e072:	89 0a                	mov    %ecx,(%rdx)
  800420e074:	eb 14                	jmp    800420e08a <getint+0xf9>
  800420e076:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e07a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e07e:	48 8d 48 08          	lea    0x8(%rax),%rcx
  800420e082:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e086:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420e08a:	8b 00                	mov    (%rax),%eax
  800420e08c:	48 98                	cltq   
  800420e08e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420e092:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e096:	c9                   	leaveq 
  800420e097:	c3                   	retq   

000000800420e098 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420e098:	55                   	push   %rbp
  800420e099:	48 89 e5             	mov    %rsp,%rbp
  800420e09c:	41 54                	push   %r12
  800420e09e:	53                   	push   %rbx
  800420e09f:	48 83 ec 60          	sub    $0x60,%rsp
  800420e0a3:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420e0a7:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420e0ab:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e0af:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420e0b3:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e0b7:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420e0bb:	48 8b 0a             	mov    (%rdx),%rcx
  800420e0be:	48 89 08             	mov    %rcx,(%rax)
  800420e0c1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e0c5:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e0c9:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e0cd:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e0d1:	eb 17                	jmp    800420e0ea <vprintfmt+0x52>
			if (ch == '\0')
  800420e0d3:	85 db                	test   %ebx,%ebx
  800420e0d5:	0f 84 b9 04 00 00    	je     800420e594 <vprintfmt+0x4fc>
				return;
			putch(ch, putdat);
  800420e0db:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e0df:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e0e3:	48 89 d6             	mov    %rdx,%rsi
  800420e0e6:	89 df                	mov    %ebx,%edi
  800420e0e8:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420e0ea:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e0ee:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e0f2:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e0f6:	0f b6 00             	movzbl (%rax),%eax
  800420e0f9:	0f b6 d8             	movzbl %al,%ebx
  800420e0fc:	83 fb 25             	cmp    $0x25,%ebx
  800420e0ff:	75 d2                	jne    800420e0d3 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420e101:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420e105:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420e10c:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420e113:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420e11a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420e121:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e125:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e129:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e12d:	0f b6 00             	movzbl (%rax),%eax
  800420e130:	0f b6 d8             	movzbl %al,%ebx
  800420e133:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420e136:	83 f8 55             	cmp    $0x55,%eax
  800420e139:	0f 87 22 04 00 00    	ja     800420e561 <vprintfmt+0x4c9>
  800420e13f:	89 c0                	mov    %eax,%eax
  800420e141:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420e148:	00 
  800420e149:	48 b8 d8 80 21 04 80 	movabs $0x80042180d8,%rax
  800420e150:	00 00 00 
  800420e153:	48 01 d0             	add    %rdx,%rax
  800420e156:	48 8b 00             	mov    (%rax),%rax
  800420e159:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420e15b:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420e15f:	eb c0                	jmp    800420e121 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420e161:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420e165:	eb ba                	jmp    800420e121 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420e167:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420e16e:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420e171:	89 d0                	mov    %edx,%eax
  800420e173:	c1 e0 02             	shl    $0x2,%eax
  800420e176:	01 d0                	add    %edx,%eax
  800420e178:	01 c0                	add    %eax,%eax
  800420e17a:	01 d8                	add    %ebx,%eax
  800420e17c:	83 e8 30             	sub    $0x30,%eax
  800420e17f:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420e182:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e186:	0f b6 00             	movzbl (%rax),%eax
  800420e189:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420e18c:	83 fb 2f             	cmp    $0x2f,%ebx
  800420e18f:	7e 60                	jle    800420e1f1 <vprintfmt+0x159>
  800420e191:	83 fb 39             	cmp    $0x39,%ebx
  800420e194:	7f 5b                	jg     800420e1f1 <vprintfmt+0x159>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420e196:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420e19b:	eb d1                	jmp    800420e16e <vprintfmt+0xd6>
			goto process_precision;

		case '*':
			precision = va_arg(aq, int);
  800420e19d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e1a0:	83 f8 30             	cmp    $0x30,%eax
  800420e1a3:	73 17                	jae    800420e1bc <vprintfmt+0x124>
  800420e1a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e1a9:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e1ac:	89 d2                	mov    %edx,%edx
  800420e1ae:	48 01 d0             	add    %rdx,%rax
  800420e1b1:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e1b4:	83 c2 08             	add    $0x8,%edx
  800420e1b7:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e1ba:	eb 0c                	jmp    800420e1c8 <vprintfmt+0x130>
  800420e1bc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e1c0:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420e1c4:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e1c8:	8b 00                	mov    (%rax),%eax
  800420e1ca:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420e1cd:	eb 23                	jmp    800420e1f2 <vprintfmt+0x15a>

		case '.':
			if (width < 0)
  800420e1cf:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e1d3:	0f 89 48 ff ff ff    	jns    800420e121 <vprintfmt+0x89>
				width = 0;
  800420e1d9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420e1e0:	e9 3c ff ff ff       	jmpq   800420e121 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420e1e5:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420e1ec:	e9 30 ff ff ff       	jmpq   800420e121 <vprintfmt+0x89>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
  800420e1f1:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  800420e1f2:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e1f6:	0f 89 25 ff ff ff    	jns    800420e121 <vprintfmt+0x89>
				width = precision, precision = -1;
  800420e1fc:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e1ff:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420e202:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420e209:	e9 13 ff ff ff       	jmpq   800420e121 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420e20e:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420e212:	e9 0a ff ff ff       	jmpq   800420e121 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420e217:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e21a:	83 f8 30             	cmp    $0x30,%eax
  800420e21d:	73 17                	jae    800420e236 <vprintfmt+0x19e>
  800420e21f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e223:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e226:	89 d2                	mov    %edx,%edx
  800420e228:	48 01 d0             	add    %rdx,%rax
  800420e22b:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e22e:	83 c2 08             	add    $0x8,%edx
  800420e231:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e234:	eb 0c                	jmp    800420e242 <vprintfmt+0x1aa>
  800420e236:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e23a:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420e23e:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e242:	8b 10                	mov    (%rax),%edx
  800420e244:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420e248:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e24c:	48 89 ce             	mov    %rcx,%rsi
  800420e24f:	89 d7                	mov    %edx,%edi
  800420e251:	ff d0                	callq  *%rax
			break;
  800420e253:	e9 37 03 00 00       	jmpq   800420e58f <vprintfmt+0x4f7>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420e258:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e25b:	83 f8 30             	cmp    $0x30,%eax
  800420e25e:	73 17                	jae    800420e277 <vprintfmt+0x1df>
  800420e260:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e264:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e267:	89 d2                	mov    %edx,%edx
  800420e269:	48 01 d0             	add    %rdx,%rax
  800420e26c:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e26f:	83 c2 08             	add    $0x8,%edx
  800420e272:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e275:	eb 0c                	jmp    800420e283 <vprintfmt+0x1eb>
  800420e277:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e27b:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420e27f:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e283:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420e285:	85 db                	test   %ebx,%ebx
  800420e287:	79 02                	jns    800420e28b <vprintfmt+0x1f3>
				err = -err;
  800420e289:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420e28b:	83 fb 15             	cmp    $0x15,%ebx
  800420e28e:	7f 16                	jg     800420e2a6 <vprintfmt+0x20e>
  800420e290:	48 b8 00 80 21 04 80 	movabs $0x8004218000,%rax
  800420e297:	00 00 00 
  800420e29a:	48 63 d3             	movslq %ebx,%rdx
  800420e29d:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420e2a1:	4d 85 e4             	test   %r12,%r12
  800420e2a4:	75 2e                	jne    800420e2d4 <vprintfmt+0x23c>
				printfmt(putch, putdat, "error %d", err);
  800420e2a6:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e2aa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e2ae:	89 d9                	mov    %ebx,%ecx
  800420e2b0:	48 ba c1 80 21 04 80 	movabs $0x80042180c1,%rdx
  800420e2b7:	00 00 00 
  800420e2ba:	48 89 c7             	mov    %rax,%rdi
  800420e2bd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e2c2:	49 b8 9e e5 20 04 80 	movabs $0x800420e59e,%r8
  800420e2c9:	00 00 00 
  800420e2cc:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420e2cf:	e9 bb 02 00 00       	jmpq   800420e58f <vprintfmt+0x4f7>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420e2d4:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e2d8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e2dc:	4c 89 e1             	mov    %r12,%rcx
  800420e2df:	48 ba ca 80 21 04 80 	movabs $0x80042180ca,%rdx
  800420e2e6:	00 00 00 
  800420e2e9:	48 89 c7             	mov    %rax,%rdi
  800420e2ec:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e2f1:	49 b8 9e e5 20 04 80 	movabs $0x800420e59e,%r8
  800420e2f8:	00 00 00 
  800420e2fb:	41 ff d0             	callq  *%r8
			break;
  800420e2fe:	e9 8c 02 00 00       	jmpq   800420e58f <vprintfmt+0x4f7>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420e303:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e306:	83 f8 30             	cmp    $0x30,%eax
  800420e309:	73 17                	jae    800420e322 <vprintfmt+0x28a>
  800420e30b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e30f:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e312:	89 d2                	mov    %edx,%edx
  800420e314:	48 01 d0             	add    %rdx,%rax
  800420e317:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e31a:	83 c2 08             	add    $0x8,%edx
  800420e31d:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420e320:	eb 0c                	jmp    800420e32e <vprintfmt+0x296>
  800420e322:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e326:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420e32a:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e32e:	4c 8b 20             	mov    (%rax),%r12
  800420e331:	4d 85 e4             	test   %r12,%r12
  800420e334:	75 0a                	jne    800420e340 <vprintfmt+0x2a8>
				p = "(null)";
  800420e336:	49 bc cd 80 21 04 80 	movabs $0x80042180cd,%r12
  800420e33d:	00 00 00 
			if (width > 0 && padc != '-')
  800420e340:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e344:	7e 78                	jle    800420e3be <vprintfmt+0x326>
  800420e346:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420e34a:	74 72                	je     800420e3be <vprintfmt+0x326>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420e34c:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e34f:	48 98                	cltq   
  800420e351:	48 89 c6             	mov    %rax,%rsi
  800420e354:	4c 89 e7             	mov    %r12,%rdi
  800420e357:	48 b8 9f e9 20 04 80 	movabs $0x800420e99f,%rax
  800420e35e:	00 00 00 
  800420e361:	ff d0                	callq  *%rax
  800420e363:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420e366:	eb 17                	jmp    800420e37f <vprintfmt+0x2e7>
					putch(padc, putdat);
  800420e368:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420e36c:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420e370:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e374:	48 89 ce             	mov    %rcx,%rsi
  800420e377:	89 d7                	mov    %edx,%edi
  800420e379:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420e37b:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e37f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e383:	7f e3                	jg     800420e368 <vprintfmt+0x2d0>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420e385:	eb 37                	jmp    800420e3be <vprintfmt+0x326>
				if (altflag && (ch < ' ' || ch > '~'))
  800420e387:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420e38b:	74 1e                	je     800420e3ab <vprintfmt+0x313>
  800420e38d:	83 fb 1f             	cmp    $0x1f,%ebx
  800420e390:	7e 05                	jle    800420e397 <vprintfmt+0x2ff>
  800420e392:	83 fb 7e             	cmp    $0x7e,%ebx
  800420e395:	7e 14                	jle    800420e3ab <vprintfmt+0x313>
					putch('?', putdat);
  800420e397:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e39b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e39f:	48 89 d6             	mov    %rdx,%rsi
  800420e3a2:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420e3a7:	ff d0                	callq  *%rax
  800420e3a9:	eb 0f                	jmp    800420e3ba <vprintfmt+0x322>
				else
					putch(ch, putdat);
  800420e3ab:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e3af:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e3b3:	48 89 d6             	mov    %rdx,%rsi
  800420e3b6:	89 df                	mov    %ebx,%edi
  800420e3b8:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420e3ba:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e3be:	4c 89 e0             	mov    %r12,%rax
  800420e3c1:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420e3c5:	0f b6 00             	movzbl (%rax),%eax
  800420e3c8:	0f be d8             	movsbl %al,%ebx
  800420e3cb:	85 db                	test   %ebx,%ebx
  800420e3cd:	74 28                	je     800420e3f7 <vprintfmt+0x35f>
  800420e3cf:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420e3d3:	78 b2                	js     800420e387 <vprintfmt+0x2ef>
  800420e3d5:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420e3d9:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420e3dd:	79 a8                	jns    800420e387 <vprintfmt+0x2ef>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420e3df:	eb 16                	jmp    800420e3f7 <vprintfmt+0x35f>
				putch(' ', putdat);
  800420e3e1:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e3e5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e3e9:	48 89 d6             	mov    %rdx,%rsi
  800420e3ec:	bf 20 00 00 00       	mov    $0x20,%edi
  800420e3f1:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420e3f3:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420e3f7:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420e3fb:	7f e4                	jg     800420e3e1 <vprintfmt+0x349>
				putch(' ', putdat);
			break;
  800420e3fd:	e9 8d 01 00 00       	jmpq   800420e58f <vprintfmt+0x4f7>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420e402:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e406:	be 03 00 00 00       	mov    $0x3,%esi
  800420e40b:	48 89 c7             	mov    %rax,%rdi
  800420e40e:	48 b8 91 df 20 04 80 	movabs $0x800420df91,%rax
  800420e415:	00 00 00 
  800420e418:	ff d0                	callq  *%rax
  800420e41a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420e41e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e422:	48 85 c0             	test   %rax,%rax
  800420e425:	79 1d                	jns    800420e444 <vprintfmt+0x3ac>
				putch('-', putdat);
  800420e427:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e42b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e42f:	48 89 d6             	mov    %rdx,%rsi
  800420e432:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420e437:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420e439:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e43d:	48 f7 d8             	neg    %rax
  800420e440:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420e444:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420e44b:	e9 d2 00 00 00       	jmpq   800420e522 <vprintfmt+0x48a>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420e450:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e454:	be 03 00 00 00       	mov    $0x3,%esi
  800420e459:	48 89 c7             	mov    %rax,%rdi
  800420e45c:	48 b8 8a de 20 04 80 	movabs $0x800420de8a,%rax
  800420e463:	00 00 00 
  800420e466:	ff d0                	callq  *%rax
  800420e468:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420e46c:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420e473:	e9 aa 00 00 00       	jmpq   800420e522 <vprintfmt+0x48a>

			// (unsigned) octal
		case 'o':
			num = getuint(&aq, 3);
  800420e478:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e47c:	be 03 00 00 00       	mov    $0x3,%esi
  800420e481:	48 89 c7             	mov    %rax,%rdi
  800420e484:	48 b8 8a de 20 04 80 	movabs $0x800420de8a,%rax
  800420e48b:	00 00 00 
  800420e48e:	ff d0                	callq  *%rax
  800420e490:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  800420e494:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  800420e49b:	e9 82 00 00 00       	jmpq   800420e522 <vprintfmt+0x48a>
			break;

			// pointer
		case 'p':
			putch('0', putdat);
  800420e4a0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e4a4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e4a8:	48 89 d6             	mov    %rdx,%rsi
  800420e4ab:	bf 30 00 00 00       	mov    $0x30,%edi
  800420e4b0:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420e4b2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e4b6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e4ba:	48 89 d6             	mov    %rdx,%rsi
  800420e4bd:	bf 78 00 00 00       	mov    $0x78,%edi
  800420e4c2:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420e4c4:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420e4c7:	83 f8 30             	cmp    $0x30,%eax
  800420e4ca:	73 17                	jae    800420e4e3 <vprintfmt+0x44b>
  800420e4cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e4d0:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e4d3:	89 d2                	mov    %edx,%edx
  800420e4d5:	48 01 d0             	add    %rdx,%rax
  800420e4d8:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420e4db:	83 c2 08             	add    $0x8,%edx
  800420e4de:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420e4e1:	eb 0c                	jmp    800420e4ef <vprintfmt+0x457>
				(uintptr_t) va_arg(aq, void *);
  800420e4e3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e4e7:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420e4eb:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e4ef:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420e4f2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420e4f6:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420e4fd:	eb 23                	jmp    800420e522 <vprintfmt+0x48a>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420e4ff:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420e503:	be 03 00 00 00       	mov    $0x3,%esi
  800420e508:	48 89 c7             	mov    %rax,%rdi
  800420e50b:	48 b8 8a de 20 04 80 	movabs $0x800420de8a,%rax
  800420e512:	00 00 00 
  800420e515:	ff d0                	callq  *%rax
  800420e517:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420e51b:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420e522:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420e527:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420e52a:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420e52d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e531:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420e535:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e539:	45 89 c1             	mov    %r8d,%r9d
  800420e53c:	41 89 f8             	mov    %edi,%r8d
  800420e53f:	48 89 c7             	mov    %rax,%rdi
  800420e542:	48 b8 d2 dd 20 04 80 	movabs $0x800420ddd2,%rax
  800420e549:	00 00 00 
  800420e54c:	ff d0                	callq  *%rax
			break;
  800420e54e:	eb 3f                	jmp    800420e58f <vprintfmt+0x4f7>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420e550:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e554:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e558:	48 89 d6             	mov    %rdx,%rsi
  800420e55b:	89 df                	mov    %ebx,%edi
  800420e55d:	ff d0                	callq  *%rax
			break;
  800420e55f:	eb 2e                	jmp    800420e58f <vprintfmt+0x4f7>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420e561:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420e565:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420e569:	48 89 d6             	mov    %rdx,%rsi
  800420e56c:	bf 25 00 00 00       	mov    $0x25,%edi
  800420e571:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420e573:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420e578:	eb 05                	jmp    800420e57f <vprintfmt+0x4e7>
  800420e57a:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420e57f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e583:	48 83 e8 01          	sub    $0x1,%rax
  800420e587:	0f b6 00             	movzbl (%rax),%eax
  800420e58a:	3c 25                	cmp    $0x25,%al
  800420e58c:	75 ec                	jne    800420e57a <vprintfmt+0x4e2>
				/* do nothing */;
			break;
  800420e58e:	90                   	nop
		}
	}
  800420e58f:	e9 3d fb ff ff       	jmpq   800420e0d1 <vprintfmt+0x39>
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
  800420e594:	90                   	nop
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420e595:	48 83 c4 60          	add    $0x60,%rsp
  800420e599:	5b                   	pop    %rbx
  800420e59a:	41 5c                	pop    %r12
  800420e59c:	5d                   	pop    %rbp
  800420e59d:	c3                   	retq   

000000800420e59e <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420e59e:	55                   	push   %rbp
  800420e59f:	48 89 e5             	mov    %rsp,%rbp
  800420e5a2:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420e5a9:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420e5b0:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420e5b7:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
  800420e5be:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e5c5:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e5cc:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e5d3:	84 c0                	test   %al,%al
  800420e5d5:	74 20                	je     800420e5f7 <printfmt+0x59>
  800420e5d7:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e5db:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e5df:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e5e3:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e5e7:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e5eb:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e5ef:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e5f3:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420e5f7:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420e5fe:	00 00 00 
  800420e601:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420e608:	00 00 00 
  800420e60b:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e60f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420e616:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e61d:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420e624:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420e62b:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420e632:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420e639:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420e640:	48 89 c7             	mov    %rax,%rdi
  800420e643:	48 b8 98 e0 20 04 80 	movabs $0x800420e098,%rax
  800420e64a:	00 00 00 
  800420e64d:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420e64f:	90                   	nop
  800420e650:	c9                   	leaveq 
  800420e651:	c3                   	retq   

000000800420e652 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420e652:	55                   	push   %rbp
  800420e653:	48 89 e5             	mov    %rsp,%rbp
  800420e656:	48 83 ec 10          	sub    $0x10,%rsp
  800420e65a:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420e65d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420e661:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e665:	8b 40 10             	mov    0x10(%rax),%eax
  800420e668:	8d 50 01             	lea    0x1(%rax),%edx
  800420e66b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e66f:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420e672:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e676:	48 8b 10             	mov    (%rax),%rdx
  800420e679:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e67d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e681:	48 39 c2             	cmp    %rax,%rdx
  800420e684:	73 17                	jae    800420e69d <sprintputch+0x4b>
		*b->buf++ = ch;
  800420e686:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e68a:	48 8b 00             	mov    (%rax),%rax
  800420e68d:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420e691:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e695:	48 89 0a             	mov    %rcx,(%rdx)
  800420e698:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420e69b:	88 10                	mov    %dl,(%rax)
}
  800420e69d:	90                   	nop
  800420e69e:	c9                   	leaveq 
  800420e69f:	c3                   	retq   

000000800420e6a0 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420e6a0:	55                   	push   %rbp
  800420e6a1:	48 89 e5             	mov    %rsp,%rbp
  800420e6a4:	48 83 ec 50          	sub    $0x50,%rsp
  800420e6a8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420e6ac:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420e6af:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420e6b3:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420e6b7:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420e6bb:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e6bf:	48 8b 0a             	mov    (%rdx),%rcx
  800420e6c2:	48 89 08             	mov    %rcx,(%rax)
  800420e6c5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e6c9:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e6cd:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e6d1:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420e6d5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e6d9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420e6dd:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420e6e0:	48 98                	cltq   
  800420e6e2:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420e6e6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e6ea:	48 01 d0             	add    %rdx,%rax
  800420e6ed:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420e6f1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420e6f8:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e6fd:	74 06                	je     800420e705 <vsnprintf+0x65>
  800420e6ff:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420e703:	7f 07                	jg     800420e70c <vsnprintf+0x6c>
		return -E_INVAL;
  800420e705:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e70a:	eb 2f                	jmp    800420e73b <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420e70c:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e710:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e714:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420e718:	48 89 c6             	mov    %rax,%rsi
  800420e71b:	48 bf 52 e6 20 04 80 	movabs $0x800420e652,%rdi
  800420e722:	00 00 00 
  800420e725:	48 b8 98 e0 20 04 80 	movabs $0x800420e098,%rax
  800420e72c:	00 00 00 
  800420e72f:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420e731:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e735:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420e738:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420e73b:	c9                   	leaveq 
  800420e73c:	c3                   	retq   

000000800420e73d <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420e73d:	55                   	push   %rbp
  800420e73e:	48 89 e5             	mov    %rsp,%rbp
  800420e741:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420e748:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420e74f:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420e755:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
  800420e75c:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e763:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e76a:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e771:	84 c0                	test   %al,%al
  800420e773:	74 20                	je     800420e795 <snprintf+0x58>
  800420e775:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e779:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e77d:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e781:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e785:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e789:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e78d:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e791:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420e795:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420e79c:	00 00 00 
  800420e79f:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420e7a6:	00 00 00 
  800420e7a9:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e7ad:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420e7b4:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e7bb:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420e7c2:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420e7c9:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420e7d0:	48 8b 0a             	mov    (%rdx),%rcx
  800420e7d3:	48 89 08             	mov    %rcx,(%rax)
  800420e7d6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e7da:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e7de:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e7e2:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420e7e6:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420e7ed:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420e7f4:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420e7fa:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420e801:	48 89 c7             	mov    %rax,%rdi
  800420e804:	48 b8 a0 e6 20 04 80 	movabs $0x800420e6a0,%rax
  800420e80b:	00 00 00 
  800420e80e:	ff d0                	callq  *%rax
  800420e810:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420e816:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420e81c:	c9                   	leaveq 
  800420e81d:	c3                   	retq   

000000800420e81e <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420e81e:	55                   	push   %rbp
  800420e81f:	48 89 e5             	mov    %rsp,%rbp
  800420e822:	48 83 ec 20          	sub    $0x20,%rsp
  800420e826:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

	if (prompt != NULL)
  800420e82a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e82f:	74 22                	je     800420e853 <readline+0x35>
		cprintf("%s", prompt);
  800420e831:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e835:	48 89 c6             	mov    %rax,%rsi
  800420e838:	48 bf 88 83 21 04 80 	movabs $0x8004218388,%rdi
  800420e83f:	00 00 00 
  800420e842:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e847:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420e84e:	00 00 00 
  800420e851:	ff d2                	callq  *%rdx

	i = 0;
  800420e853:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420e85a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420e85f:	48 b8 e4 11 20 04 80 	movabs $0x80042011e4,%rax
  800420e866:	00 00 00 
  800420e869:	ff d0                	callq  *%rax
  800420e86b:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420e86e:	48 b8 c2 11 20 04 80 	movabs $0x80042011c2,%rax
  800420e875:	00 00 00 
  800420e878:	ff d0                	callq  *%rax
  800420e87a:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420e87d:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420e881:	79 2a                	jns    800420e8ad <readline+0x8f>
			cprintf("read error: %e\n", c);
  800420e883:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e886:	89 c6                	mov    %eax,%esi
  800420e888:	48 bf 8b 83 21 04 80 	movabs $0x800421838b,%rdi
  800420e88f:	00 00 00 
  800420e892:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e897:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800420e89e:	00 00 00 
  800420e8a1:	ff d2                	callq  *%rdx
			return NULL;
  800420e8a3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e8a8:	e9 c2 00 00 00       	jmpq   800420e96f <readline+0x151>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420e8ad:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420e8b1:	74 06                	je     800420e8b9 <readline+0x9b>
  800420e8b3:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420e8b7:	75 26                	jne    800420e8df <readline+0xc1>
  800420e8b9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e8bd:	7e 20                	jle    800420e8df <readline+0xc1>
			if (echoing)
  800420e8bf:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e8c3:	74 11                	je     800420e8d6 <readline+0xb8>
				cputchar('\b');
  800420e8c5:	bf 08 00 00 00       	mov    $0x8,%edi
  800420e8ca:	48 b8 a3 11 20 04 80 	movabs $0x80042011a3,%rax
  800420e8d1:	00 00 00 
  800420e8d4:	ff d0                	callq  *%rax
			i--;
  800420e8d6:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420e8da:	e9 8b 00 00 00       	jmpq   800420e96a <readline+0x14c>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420e8df:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420e8e3:	7e 3f                	jle    800420e924 <readline+0x106>
  800420e8e5:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420e8ec:	7f 36                	jg     800420e924 <readline+0x106>
			if (echoing)
  800420e8ee:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e8f2:	74 11                	je     800420e905 <readline+0xe7>
				cputchar(c);
  800420e8f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e8f7:	89 c7                	mov    %eax,%edi
  800420e8f9:	48 b8 a3 11 20 04 80 	movabs $0x80042011a3,%rax
  800420e900:	00 00 00 
  800420e903:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420e905:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e908:	8d 50 01             	lea    0x1(%rax),%edx
  800420e90b:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420e90e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420e911:	89 d1                	mov    %edx,%ecx
  800420e913:	48 ba a0 32 36 04 80 	movabs $0x80043632a0,%rdx
  800420e91a:	00 00 00 
  800420e91d:	48 98                	cltq   
  800420e91f:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420e922:	eb 46                	jmp    800420e96a <readline+0x14c>
		} else if (c == '\n' || c == '\r') {
  800420e924:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420e928:	74 0a                	je     800420e934 <readline+0x116>
  800420e92a:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420e92e:	0f 85 3a ff ff ff    	jne    800420e86e <readline+0x50>
			if (echoing)
  800420e934:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e938:	74 11                	je     800420e94b <readline+0x12d>
				cputchar('\n');
  800420e93a:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420e93f:	48 b8 a3 11 20 04 80 	movabs $0x80042011a3,%rax
  800420e946:	00 00 00 
  800420e949:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420e94b:	48 ba a0 32 36 04 80 	movabs $0x80043632a0,%rdx
  800420e952:	00 00 00 
  800420e955:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e958:	48 98                	cltq   
  800420e95a:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420e95e:	48 b8 a0 32 36 04 80 	movabs $0x80043632a0,%rax
  800420e965:	00 00 00 
  800420e968:	eb 05                	jmp    800420e96f <readline+0x151>
		}
	}
  800420e96a:	e9 ff fe ff ff       	jmpq   800420e86e <readline+0x50>
}
  800420e96f:	c9                   	leaveq 
  800420e970:	c3                   	retq   

000000800420e971 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420e971:	55                   	push   %rbp
  800420e972:	48 89 e5             	mov    %rsp,%rbp
  800420e975:	48 83 ec 18          	sub    $0x18,%rsp
  800420e979:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420e97d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420e984:	eb 09                	jmp    800420e98f <strlen+0x1e>
		n++;
  800420e986:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420e98a:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e98f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e993:	0f b6 00             	movzbl (%rax),%eax
  800420e996:	84 c0                	test   %al,%al
  800420e998:	75 ec                	jne    800420e986 <strlen+0x15>
		n++;
	return n;
  800420e99a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420e99d:	c9                   	leaveq 
  800420e99e:	c3                   	retq   

000000800420e99f <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420e99f:	55                   	push   %rbp
  800420e9a0:	48 89 e5             	mov    %rsp,%rbp
  800420e9a3:	48 83 ec 20          	sub    $0x20,%rsp
  800420e9a7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e9ab:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420e9af:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420e9b6:	eb 0e                	jmp    800420e9c6 <strnlen+0x27>
		n++;
  800420e9b8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420e9bc:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e9c1:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420e9c6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e9cb:	74 0b                	je     800420e9d8 <strnlen+0x39>
  800420e9cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9d1:	0f b6 00             	movzbl (%rax),%eax
  800420e9d4:	84 c0                	test   %al,%al
  800420e9d6:	75 e0                	jne    800420e9b8 <strnlen+0x19>
		n++;
	return n;
  800420e9d8:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420e9db:	c9                   	leaveq 
  800420e9dc:	c3                   	retq   

000000800420e9dd <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420e9dd:	55                   	push   %rbp
  800420e9de:	48 89 e5             	mov    %rsp,%rbp
  800420e9e1:	48 83 ec 20          	sub    $0x20,%rsp
  800420e9e5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e9e9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420e9ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9f1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420e9f5:	90                   	nop
  800420e9f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e9fa:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e9fe:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420ea02:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420ea06:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420ea0a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420ea0e:	0f b6 12             	movzbl (%rdx),%edx
  800420ea11:	88 10                	mov    %dl,(%rax)
  800420ea13:	0f b6 00             	movzbl (%rax),%eax
  800420ea16:	84 c0                	test   %al,%al
  800420ea18:	75 dc                	jne    800420e9f6 <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420ea1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ea1e:	c9                   	leaveq 
  800420ea1f:	c3                   	retq   

000000800420ea20 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420ea20:	55                   	push   %rbp
  800420ea21:	48 89 e5             	mov    %rsp,%rbp
  800420ea24:	48 83 ec 20          	sub    $0x20,%rsp
  800420ea28:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ea2c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420ea30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea34:	48 89 c7             	mov    %rax,%rdi
  800420ea37:	48 b8 71 e9 20 04 80 	movabs $0x800420e971,%rax
  800420ea3e:	00 00 00 
  800420ea41:	ff d0                	callq  *%rax
  800420ea43:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420ea46:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ea49:	48 63 d0             	movslq %eax,%rdx
  800420ea4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea50:	48 01 c2             	add    %rax,%rdx
  800420ea53:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ea57:	48 89 c6             	mov    %rax,%rsi
  800420ea5a:	48 89 d7             	mov    %rdx,%rdi
  800420ea5d:	48 b8 dd e9 20 04 80 	movabs $0x800420e9dd,%rax
  800420ea64:	00 00 00 
  800420ea67:	ff d0                	callq  *%rax
	return dst;
  800420ea69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420ea6d:	c9                   	leaveq 
  800420ea6e:	c3                   	retq   

000000800420ea6f <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420ea6f:	55                   	push   %rbp
  800420ea70:	48 89 e5             	mov    %rsp,%rbp
  800420ea73:	48 83 ec 28          	sub    $0x28,%rsp
  800420ea77:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ea7b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ea7f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420ea83:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea87:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420ea8b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ea92:	00 
  800420ea93:	eb 2a                	jmp    800420eabf <strncpy+0x50>
		*dst++ = *src;
  800420ea95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ea99:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ea9d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420eaa1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420eaa5:	0f b6 12             	movzbl (%rdx),%edx
  800420eaa8:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420eaaa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eaae:	0f b6 00             	movzbl (%rax),%eax
  800420eab1:	84 c0                	test   %al,%al
  800420eab3:	74 05                	je     800420eaba <strncpy+0x4b>
			src++;
  800420eab5:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420eaba:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420eabf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eac3:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420eac7:	72 cc                	jb     800420ea95 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420eac9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420eacd:	c9                   	leaveq 
  800420eace:	c3                   	retq   

000000800420eacf <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420eacf:	55                   	push   %rbp
  800420ead0:	48 89 e5             	mov    %rsp,%rbp
  800420ead3:	48 83 ec 28          	sub    $0x28,%rsp
  800420ead7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eadb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420eadf:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420eae3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eae7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420eaeb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420eaf0:	74 3d                	je     800420eb2f <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420eaf2:	eb 1d                	jmp    800420eb11 <strlcpy+0x42>
			*dst++ = *src++;
  800420eaf4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eaf8:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420eafc:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420eb00:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420eb04:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420eb08:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420eb0c:	0f b6 12             	movzbl (%rdx),%edx
  800420eb0f:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420eb11:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420eb16:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420eb1b:	74 0b                	je     800420eb28 <strlcpy+0x59>
  800420eb1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eb21:	0f b6 00             	movzbl (%rax),%eax
  800420eb24:	84 c0                	test   %al,%al
  800420eb26:	75 cc                	jne    800420eaf4 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420eb28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eb2c:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420eb2f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eb33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eb37:	48 29 c2             	sub    %rax,%rdx
  800420eb3a:	48 89 d0             	mov    %rdx,%rax
}
  800420eb3d:	c9                   	leaveq 
  800420eb3e:	c3                   	retq   

000000800420eb3f <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420eb3f:	55                   	push   %rbp
  800420eb40:	48 89 e5             	mov    %rsp,%rbp
  800420eb43:	48 83 ec 10          	sub    $0x10,%rsp
  800420eb47:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420eb4b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420eb4f:	eb 0a                	jmp    800420eb5b <strcmp+0x1c>
		p++, q++;
  800420eb51:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420eb56:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420eb5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eb5f:	0f b6 00             	movzbl (%rax),%eax
  800420eb62:	84 c0                	test   %al,%al
  800420eb64:	74 12                	je     800420eb78 <strcmp+0x39>
  800420eb66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eb6a:	0f b6 10             	movzbl (%rax),%edx
  800420eb6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eb71:	0f b6 00             	movzbl (%rax),%eax
  800420eb74:	38 c2                	cmp    %al,%dl
  800420eb76:	74 d9                	je     800420eb51 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420eb78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eb7c:	0f b6 00             	movzbl (%rax),%eax
  800420eb7f:	0f b6 d0             	movzbl %al,%edx
  800420eb82:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eb86:	0f b6 00             	movzbl (%rax),%eax
  800420eb89:	0f b6 c0             	movzbl %al,%eax
  800420eb8c:	29 c2                	sub    %eax,%edx
  800420eb8e:	89 d0                	mov    %edx,%eax
}
  800420eb90:	c9                   	leaveq 
  800420eb91:	c3                   	retq   

000000800420eb92 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420eb92:	55                   	push   %rbp
  800420eb93:	48 89 e5             	mov    %rsp,%rbp
  800420eb96:	48 83 ec 18          	sub    $0x18,%rsp
  800420eb9a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420eb9e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420eba2:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420eba6:	eb 0f                	jmp    800420ebb7 <strncmp+0x25>
		n--, p++, q++;
  800420eba8:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420ebad:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ebb2:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420ebb7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ebbc:	74 1d                	je     800420ebdb <strncmp+0x49>
  800420ebbe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ebc2:	0f b6 00             	movzbl (%rax),%eax
  800420ebc5:	84 c0                	test   %al,%al
  800420ebc7:	74 12                	je     800420ebdb <strncmp+0x49>
  800420ebc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ebcd:	0f b6 10             	movzbl (%rax),%edx
  800420ebd0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ebd4:	0f b6 00             	movzbl (%rax),%eax
  800420ebd7:	38 c2                	cmp    %al,%dl
  800420ebd9:	74 cd                	je     800420eba8 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420ebdb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ebe0:	75 07                	jne    800420ebe9 <strncmp+0x57>
		return 0;
  800420ebe2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ebe7:	eb 18                	jmp    800420ec01 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420ebe9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ebed:	0f b6 00             	movzbl (%rax),%eax
  800420ebf0:	0f b6 d0             	movzbl %al,%edx
  800420ebf3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ebf7:	0f b6 00             	movzbl (%rax),%eax
  800420ebfa:	0f b6 c0             	movzbl %al,%eax
  800420ebfd:	29 c2                	sub    %eax,%edx
  800420ebff:	89 d0                	mov    %edx,%eax
}
  800420ec01:	c9                   	leaveq 
  800420ec02:	c3                   	retq   

000000800420ec03 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420ec03:	55                   	push   %rbp
  800420ec04:	48 89 e5             	mov    %rsp,%rbp
  800420ec07:	48 83 ec 10          	sub    $0x10,%rsp
  800420ec0b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ec0f:	89 f0                	mov    %esi,%eax
  800420ec11:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420ec14:	eb 17                	jmp    800420ec2d <strchr+0x2a>
		if (*s == c)
  800420ec16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec1a:	0f b6 00             	movzbl (%rax),%eax
  800420ec1d:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420ec20:	75 06                	jne    800420ec28 <strchr+0x25>
			return (char *) s;
  800420ec22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec26:	eb 15                	jmp    800420ec3d <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420ec28:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ec2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec31:	0f b6 00             	movzbl (%rax),%eax
  800420ec34:	84 c0                	test   %al,%al
  800420ec36:	75 de                	jne    800420ec16 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420ec38:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ec3d:	c9                   	leaveq 
  800420ec3e:	c3                   	retq   

000000800420ec3f <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420ec3f:	55                   	push   %rbp
  800420ec40:	48 89 e5             	mov    %rsp,%rbp
  800420ec43:	48 83 ec 10          	sub    $0x10,%rsp
  800420ec47:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ec4b:	89 f0                	mov    %esi,%eax
  800420ec4d:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420ec50:	eb 11                	jmp    800420ec63 <strfind+0x24>
		if (*s == c)
  800420ec52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec56:	0f b6 00             	movzbl (%rax),%eax
  800420ec59:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420ec5c:	74 12                	je     800420ec70 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420ec5e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420ec63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec67:	0f b6 00             	movzbl (%rax),%eax
  800420ec6a:	84 c0                	test   %al,%al
  800420ec6c:	75 e4                	jne    800420ec52 <strfind+0x13>
  800420ec6e:	eb 01                	jmp    800420ec71 <strfind+0x32>
		if (*s == c)
			break;
  800420ec70:	90                   	nop
	return (char *) s;
  800420ec71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ec75:	c9                   	leaveq 
  800420ec76:	c3                   	retq   

000000800420ec77 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420ec77:	55                   	push   %rbp
  800420ec78:	48 89 e5             	mov    %rsp,%rbp
  800420ec7b:	48 83 ec 18          	sub    $0x18,%rsp
  800420ec7f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ec83:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420ec86:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420ec8a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420ec8f:	75 06                	jne    800420ec97 <memset+0x20>
		return v;
  800420ec91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec95:	eb 69                	jmp    800420ed00 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420ec97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec9b:	83 e0 03             	and    $0x3,%eax
  800420ec9e:	48 85 c0             	test   %rax,%rax
  800420eca1:	75 48                	jne    800420eceb <memset+0x74>
  800420eca3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eca7:	83 e0 03             	and    $0x3,%eax
  800420ecaa:	48 85 c0             	test   %rax,%rax
  800420ecad:	75 3c                	jne    800420eceb <memset+0x74>
		c &= 0xFF;
  800420ecaf:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420ecb6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ecb9:	c1 e0 18             	shl    $0x18,%eax
  800420ecbc:	89 c2                	mov    %eax,%edx
  800420ecbe:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ecc1:	c1 e0 10             	shl    $0x10,%eax
  800420ecc4:	09 c2                	or     %eax,%edx
  800420ecc6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ecc9:	c1 e0 08             	shl    $0x8,%eax
  800420eccc:	09 d0                	or     %edx,%eax
  800420ecce:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800420ecd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecd5:	48 c1 e8 02          	shr    $0x2,%rax
  800420ecd9:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420ecdc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ece0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ece3:	48 89 d7             	mov    %rdx,%rdi
  800420ece6:	fc                   	cld    
  800420ece7:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420ece9:	eb 11                	jmp    800420ecfc <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420eceb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ecef:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420ecf2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420ecf6:	48 89 d7             	mov    %rdx,%rdi
  800420ecf9:	fc                   	cld    
  800420ecfa:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800420ecfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ed00:	c9                   	leaveq 
  800420ed01:	c3                   	retq   

000000800420ed02 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420ed02:	55                   	push   %rbp
  800420ed03:	48 89 e5             	mov    %rsp,%rbp
  800420ed06:	48 83 ec 28          	sub    $0x28,%rsp
  800420ed0a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ed0e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ed12:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420ed16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ed1a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420ed1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed22:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420ed26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed2a:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420ed2e:	0f 83 88 00 00 00    	jae    800420edbc <memmove+0xba>
  800420ed34:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ed38:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed3c:	48 01 d0             	add    %rdx,%rax
  800420ed3f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420ed43:	76 77                	jbe    800420edbc <memmove+0xba>
		s += n;
  800420ed45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed49:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420ed4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed51:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420ed55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed59:	83 e0 03             	and    $0x3,%eax
  800420ed5c:	48 85 c0             	test   %rax,%rax
  800420ed5f:	75 3b                	jne    800420ed9c <memmove+0x9a>
  800420ed61:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed65:	83 e0 03             	and    $0x3,%eax
  800420ed68:	48 85 c0             	test   %rax,%rax
  800420ed6b:	75 2f                	jne    800420ed9c <memmove+0x9a>
  800420ed6d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ed71:	83 e0 03             	and    $0x3,%eax
  800420ed74:	48 85 c0             	test   %rax,%rax
  800420ed77:	75 23                	jne    800420ed9c <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420ed79:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed7d:	48 83 e8 04          	sub    $0x4,%rax
  800420ed81:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ed85:	48 83 ea 04          	sub    $0x4,%rdx
  800420ed89:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ed8d:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420ed91:	48 89 c7             	mov    %rax,%rdi
  800420ed94:	48 89 d6             	mov    %rdx,%rsi
  800420ed97:	fd                   	std    
  800420ed98:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420ed9a:	eb 1d                	jmp    800420edb9 <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420ed9c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eda0:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420eda4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420eda8:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420edac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420edb0:	48 89 d7             	mov    %rdx,%rdi
  800420edb3:	48 89 c1             	mov    %rax,%rcx
  800420edb6:	fd                   	std    
  800420edb7:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420edb9:	fc                   	cld    
  800420edba:	eb 57                	jmp    800420ee13 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420edbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420edc0:	83 e0 03             	and    $0x3,%eax
  800420edc3:	48 85 c0             	test   %rax,%rax
  800420edc6:	75 36                	jne    800420edfe <memmove+0xfc>
  800420edc8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edcc:	83 e0 03             	and    $0x3,%eax
  800420edcf:	48 85 c0             	test   %rax,%rax
  800420edd2:	75 2a                	jne    800420edfe <memmove+0xfc>
  800420edd4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420edd8:	83 e0 03             	and    $0x3,%eax
  800420eddb:	48 85 c0             	test   %rax,%rax
  800420edde:	75 1e                	jne    800420edfe <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420ede0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ede4:	48 c1 e8 02          	shr    $0x2,%rax
  800420ede8:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420edeb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edef:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420edf3:	48 89 c7             	mov    %rax,%rdi
  800420edf6:	48 89 d6             	mov    %rdx,%rsi
  800420edf9:	fc                   	cld    
  800420edfa:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420edfc:	eb 15                	jmp    800420ee13 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420edfe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee02:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420ee06:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420ee0a:	48 89 c7             	mov    %rax,%rdi
  800420ee0d:	48 89 d6             	mov    %rdx,%rsi
  800420ee10:	fc                   	cld    
  800420ee11:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420ee13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420ee17:	c9                   	leaveq 
  800420ee18:	c3                   	retq   

000000800420ee19 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420ee19:	55                   	push   %rbp
  800420ee1a:	48 89 e5             	mov    %rsp,%rbp
  800420ee1d:	48 83 ec 18          	sub    $0x18,%rsp
  800420ee21:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ee25:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420ee29:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420ee2d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee31:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420ee35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee39:	48 89 ce             	mov    %rcx,%rsi
  800420ee3c:	48 89 c7             	mov    %rax,%rdi
  800420ee3f:	48 b8 02 ed 20 04 80 	movabs $0x800420ed02,%rax
  800420ee46:	00 00 00 
  800420ee49:	ff d0                	callq  *%rax
}
  800420ee4b:	c9                   	leaveq 
  800420ee4c:	c3                   	retq   

000000800420ee4d <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420ee4d:	55                   	push   %rbp
  800420ee4e:	48 89 e5             	mov    %rsp,%rbp
  800420ee51:	48 83 ec 28          	sub    $0x28,%rsp
  800420ee55:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ee59:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ee5d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420ee61:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee65:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420ee69:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ee6d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420ee71:	eb 36                	jmp    800420eea9 <memcmp+0x5c>
		if (*s1 != *s2)
  800420ee73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee77:	0f b6 10             	movzbl (%rax),%edx
  800420ee7a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee7e:	0f b6 00             	movzbl (%rax),%eax
  800420ee81:	38 c2                	cmp    %al,%dl
  800420ee83:	74 1a                	je     800420ee9f <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420ee85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ee89:	0f b6 00             	movzbl (%rax),%eax
  800420ee8c:	0f b6 d0             	movzbl %al,%edx
  800420ee8f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee93:	0f b6 00             	movzbl (%rax),%eax
  800420ee96:	0f b6 c0             	movzbl %al,%eax
  800420ee99:	29 c2                	sub    %eax,%edx
  800420ee9b:	89 d0                	mov    %edx,%eax
  800420ee9d:	eb 20                	jmp    800420eebf <memcmp+0x72>
		s1++, s2++;
  800420ee9f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420eea4:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420eea9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eead:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420eeb1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420eeb5:	48 85 c0             	test   %rax,%rax
  800420eeb8:	75 b9                	jne    800420ee73 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420eeba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420eebf:	c9                   	leaveq 
  800420eec0:	c3                   	retq   

000000800420eec1 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420eec1:	55                   	push   %rbp
  800420eec2:	48 89 e5             	mov    %rsp,%rbp
  800420eec5:	48 83 ec 28          	sub    $0x28,%rsp
  800420eec9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eecd:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420eed0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420eed4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eed8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eedc:	48 01 d0             	add    %rdx,%rax
  800420eedf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420eee3:	eb 19                	jmp    800420eefe <memfind+0x3d>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420eee5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eee9:	0f b6 00             	movzbl (%rax),%eax
  800420eeec:	0f b6 d0             	movzbl %al,%edx
  800420eeef:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420eef2:	0f b6 c0             	movzbl %al,%eax
  800420eef5:	39 c2                	cmp    %eax,%edx
  800420eef7:	74 11                	je     800420ef0a <memfind+0x49>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420eef9:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420eefe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef02:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420ef06:	72 dd                	jb     800420eee5 <memfind+0x24>
  800420ef08:	eb 01                	jmp    800420ef0b <memfind+0x4a>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
  800420ef0a:	90                   	nop
	return (void *) s;
  800420ef0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420ef0f:	c9                   	leaveq 
  800420ef10:	c3                   	retq   

000000800420ef11 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420ef11:	55                   	push   %rbp
  800420ef12:	48 89 e5             	mov    %rsp,%rbp
  800420ef15:	48 83 ec 38          	sub    $0x38,%rsp
  800420ef19:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420ef1d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420ef21:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420ef24:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420ef2b:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420ef32:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420ef33:	eb 05                	jmp    800420ef3a <strtol+0x29>
		s++;
  800420ef35:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420ef3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef3e:	0f b6 00             	movzbl (%rax),%eax
  800420ef41:	3c 20                	cmp    $0x20,%al
  800420ef43:	74 f0                	je     800420ef35 <strtol+0x24>
  800420ef45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef49:	0f b6 00             	movzbl (%rax),%eax
  800420ef4c:	3c 09                	cmp    $0x9,%al
  800420ef4e:	74 e5                	je     800420ef35 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420ef50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef54:	0f b6 00             	movzbl (%rax),%eax
  800420ef57:	3c 2b                	cmp    $0x2b,%al
  800420ef59:	75 07                	jne    800420ef62 <strtol+0x51>
		s++;
  800420ef5b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ef60:	eb 17                	jmp    800420ef79 <strtol+0x68>
	else if (*s == '-')
  800420ef62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef66:	0f b6 00             	movzbl (%rax),%eax
  800420ef69:	3c 2d                	cmp    $0x2d,%al
  800420ef6b:	75 0c                	jne    800420ef79 <strtol+0x68>
		s++, neg = 1;
  800420ef6d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ef72:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420ef79:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420ef7d:	74 06                	je     800420ef85 <strtol+0x74>
  800420ef7f:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420ef83:	75 28                	jne    800420efad <strtol+0x9c>
  800420ef85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef89:	0f b6 00             	movzbl (%rax),%eax
  800420ef8c:	3c 30                	cmp    $0x30,%al
  800420ef8e:	75 1d                	jne    800420efad <strtol+0x9c>
  800420ef90:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef94:	48 83 c0 01          	add    $0x1,%rax
  800420ef98:	0f b6 00             	movzbl (%rax),%eax
  800420ef9b:	3c 78                	cmp    $0x78,%al
  800420ef9d:	75 0e                	jne    800420efad <strtol+0x9c>
		s += 2, base = 16;
  800420ef9f:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420efa4:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420efab:	eb 2c                	jmp    800420efd9 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420efad:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420efb1:	75 19                	jne    800420efcc <strtol+0xbb>
  800420efb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efb7:	0f b6 00             	movzbl (%rax),%eax
  800420efba:	3c 30                	cmp    $0x30,%al
  800420efbc:	75 0e                	jne    800420efcc <strtol+0xbb>
		s++, base = 8;
  800420efbe:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420efc3:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420efca:	eb 0d                	jmp    800420efd9 <strtol+0xc8>
	else if (base == 0)
  800420efcc:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420efd0:	75 07                	jne    800420efd9 <strtol+0xc8>
		base = 10;
  800420efd2:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420efd9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efdd:	0f b6 00             	movzbl (%rax),%eax
  800420efe0:	3c 2f                	cmp    $0x2f,%al
  800420efe2:	7e 1d                	jle    800420f001 <strtol+0xf0>
  800420efe4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efe8:	0f b6 00             	movzbl (%rax),%eax
  800420efeb:	3c 39                	cmp    $0x39,%al
  800420efed:	7f 12                	jg     800420f001 <strtol+0xf0>
			dig = *s - '0';
  800420efef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eff3:	0f b6 00             	movzbl (%rax),%eax
  800420eff6:	0f be c0             	movsbl %al,%eax
  800420eff9:	83 e8 30             	sub    $0x30,%eax
  800420effc:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420efff:	eb 4e                	jmp    800420f04f <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420f001:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f005:	0f b6 00             	movzbl (%rax),%eax
  800420f008:	3c 60                	cmp    $0x60,%al
  800420f00a:	7e 1d                	jle    800420f029 <strtol+0x118>
  800420f00c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f010:	0f b6 00             	movzbl (%rax),%eax
  800420f013:	3c 7a                	cmp    $0x7a,%al
  800420f015:	7f 12                	jg     800420f029 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420f017:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f01b:	0f b6 00             	movzbl (%rax),%eax
  800420f01e:	0f be c0             	movsbl %al,%eax
  800420f021:	83 e8 57             	sub    $0x57,%eax
  800420f024:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420f027:	eb 26                	jmp    800420f04f <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420f029:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f02d:	0f b6 00             	movzbl (%rax),%eax
  800420f030:	3c 40                	cmp    $0x40,%al
  800420f032:	7e 47                	jle    800420f07b <strtol+0x16a>
  800420f034:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f038:	0f b6 00             	movzbl (%rax),%eax
  800420f03b:	3c 5a                	cmp    $0x5a,%al
  800420f03d:	7f 3c                	jg     800420f07b <strtol+0x16a>
			dig = *s - 'A' + 10;
  800420f03f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f043:	0f b6 00             	movzbl (%rax),%eax
  800420f046:	0f be c0             	movsbl %al,%eax
  800420f049:	83 e8 37             	sub    $0x37,%eax
  800420f04c:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420f04f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f052:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420f055:	7d 23                	jge    800420f07a <strtol+0x169>
			break;
		s++, val = (val * base) + dig;
  800420f057:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420f05c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420f05f:	48 98                	cltq   
  800420f061:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420f066:	48 89 c2             	mov    %rax,%rdx
  800420f069:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f06c:	48 98                	cltq   
  800420f06e:	48 01 d0             	add    %rdx,%rax
  800420f071:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420f075:	e9 5f ff ff ff       	jmpq   800420efd9 <strtol+0xc8>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
  800420f07a:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  800420f07b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420f080:	74 0b                	je     800420f08d <strtol+0x17c>
		*endptr = (char *) s;
  800420f082:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f086:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f08a:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420f08d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f091:	74 09                	je     800420f09c <strtol+0x18b>
  800420f093:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f097:	48 f7 d8             	neg    %rax
  800420f09a:	eb 04                	jmp    800420f0a0 <strtol+0x18f>
  800420f09c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f0a0:	c9                   	leaveq 
  800420f0a1:	c3                   	retq   

000000800420f0a2 <strstr>:

char * strstr(const char *in, const char *str)
{
  800420f0a2:	55                   	push   %rbp
  800420f0a3:	48 89 e5             	mov    %rsp,%rbp
  800420f0a6:	48 83 ec 30          	sub    $0x30,%rsp
  800420f0aa:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f0ae:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800420f0b2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f0b6:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f0ba:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420f0be:	0f b6 00             	movzbl (%rax),%eax
  800420f0c1:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800420f0c4:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420f0c8:	75 06                	jne    800420f0d0 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800420f0ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f0ce:	eb 6b                	jmp    800420f13b <strstr+0x99>

	len = strlen(str);
  800420f0d0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f0d4:	48 89 c7             	mov    %rax,%rdi
  800420f0d7:	48 b8 71 e9 20 04 80 	movabs $0x800420e971,%rax
  800420f0de:	00 00 00 
  800420f0e1:	ff d0                	callq  *%rax
  800420f0e3:	48 98                	cltq   
  800420f0e5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800420f0e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f0ed:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f0f1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420f0f5:	0f b6 00             	movzbl (%rax),%eax
  800420f0f8:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800420f0fb:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420f0ff:	75 07                	jne    800420f108 <strstr+0x66>
				return (char *) 0;
  800420f101:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f106:	eb 33                	jmp    800420f13b <strstr+0x99>
		} while (sc != c);
  800420f108:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420f10c:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420f10f:	75 d8                	jne    800420f0e9 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  800420f111:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f115:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420f119:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f11d:	48 89 ce             	mov    %rcx,%rsi
  800420f120:	48 89 c7             	mov    %rax,%rdi
  800420f123:	48 b8 92 eb 20 04 80 	movabs $0x800420eb92,%rax
  800420f12a:	00 00 00 
  800420f12d:	ff d0                	callq  *%rax
  800420f12f:	85 c0                	test   %eax,%eax
  800420f131:	75 b6                	jne    800420f0e9 <strstr+0x47>

	return (char *) (in - 1);
  800420f133:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f137:	48 83 e8 01          	sub    $0x1,%rax
}
  800420f13b:	c9                   	leaveq 
  800420f13c:	c3                   	retq   

000000800420f13d <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420f13d:	55                   	push   %rbp
  800420f13e:	48 89 e5             	mov    %rsp,%rbp
  800420f141:	48 83 ec 28          	sub    $0x28,%rsp
  800420f145:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f149:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f14d:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420f150:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f154:	48 8b 10             	mov    (%rax),%rdx
  800420f157:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f15b:	48 01 d0             	add    %rdx,%rax
  800420f15e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f162:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f169:	00 
	switch (bytes_to_read) {
  800420f16a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f16d:	83 f8 02             	cmp    $0x2,%eax
  800420f170:	0f 84 ab 00 00 00    	je     800420f221 <_dwarf_read_lsb+0xe4>
  800420f176:	83 f8 02             	cmp    $0x2,%eax
  800420f179:	7f 0e                	jg     800420f189 <_dwarf_read_lsb+0x4c>
  800420f17b:	83 f8 01             	cmp    $0x1,%eax
  800420f17e:	0f 84 b3 00 00 00    	je     800420f237 <_dwarf_read_lsb+0xfa>
  800420f184:	e9 d9 00 00 00       	jmpq   800420f262 <_dwarf_read_lsb+0x125>
  800420f189:	83 f8 04             	cmp    $0x4,%eax
  800420f18c:	74 65                	je     800420f1f3 <_dwarf_read_lsb+0xb6>
  800420f18e:	83 f8 08             	cmp    $0x8,%eax
  800420f191:	0f 85 cb 00 00 00    	jne    800420f262 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420f197:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f19b:	48 83 c0 04          	add    $0x4,%rax
  800420f19f:	0f b6 00             	movzbl (%rax),%eax
  800420f1a2:	0f b6 c0             	movzbl %al,%eax
  800420f1a5:	48 c1 e0 20          	shl    $0x20,%rax
  800420f1a9:	48 89 c2             	mov    %rax,%rdx
  800420f1ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1b0:	48 83 c0 05          	add    $0x5,%rax
  800420f1b4:	0f b6 00             	movzbl (%rax),%eax
  800420f1b7:	0f b6 c0             	movzbl %al,%eax
  800420f1ba:	48 c1 e0 28          	shl    $0x28,%rax
  800420f1be:	48 09 d0             	or     %rdx,%rax
  800420f1c1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420f1c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1c9:	48 83 c0 06          	add    $0x6,%rax
  800420f1cd:	0f b6 00             	movzbl (%rax),%eax
  800420f1d0:	0f b6 c0             	movzbl %al,%eax
  800420f1d3:	48 c1 e0 30          	shl    $0x30,%rax
  800420f1d7:	48 89 c2             	mov    %rax,%rdx
  800420f1da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1de:	48 83 c0 07          	add    $0x7,%rax
  800420f1e2:	0f b6 00             	movzbl (%rax),%eax
  800420f1e5:	0f b6 c0             	movzbl %al,%eax
  800420f1e8:	48 c1 e0 38          	shl    $0x38,%rax
  800420f1ec:	48 09 d0             	or     %rdx,%rax
  800420f1ef:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420f1f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f1f7:	48 83 c0 02          	add    $0x2,%rax
  800420f1fb:	0f b6 00             	movzbl (%rax),%eax
  800420f1fe:	0f b6 c0             	movzbl %al,%eax
  800420f201:	48 c1 e0 10          	shl    $0x10,%rax
  800420f205:	48 89 c2             	mov    %rax,%rdx
  800420f208:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f20c:	48 83 c0 03          	add    $0x3,%rax
  800420f210:	0f b6 00             	movzbl (%rax),%eax
  800420f213:	0f b6 c0             	movzbl %al,%eax
  800420f216:	48 c1 e0 18          	shl    $0x18,%rax
  800420f21a:	48 09 d0             	or     %rdx,%rax
  800420f21d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420f221:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f225:	48 83 c0 01          	add    $0x1,%rax
  800420f229:	0f b6 00             	movzbl (%rax),%eax
  800420f22c:	0f b6 c0             	movzbl %al,%eax
  800420f22f:	48 c1 e0 08          	shl    $0x8,%rax
  800420f233:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420f237:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f23b:	0f b6 00             	movzbl (%rax),%eax
  800420f23e:	0f b6 c0             	movzbl %al,%eax
  800420f241:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f245:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420f246:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f24a:	48 8b 10             	mov    (%rax),%rdx
  800420f24d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f250:	48 98                	cltq   
  800420f252:	48 01 c2             	add    %rax,%rdx
  800420f255:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f259:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f25c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f260:	eb 05                	jmp    800420f267 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420f262:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800420f267:	c9                   	leaveq 
  800420f268:	c3                   	retq   

000000800420f269 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420f269:	55                   	push   %rbp
  800420f26a:	48 89 e5             	mov    %rsp,%rbp
  800420f26d:	48 83 ec 20          	sub    $0x20,%rsp
  800420f271:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f275:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420f278:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f27c:	48 8b 00             	mov    (%rax),%rax
  800420f27f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f283:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f28a:	00 
	switch (bytes_to_read) {
  800420f28b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f28e:	83 f8 02             	cmp    $0x2,%eax
  800420f291:	0f 84 ab 00 00 00    	je     800420f342 <_dwarf_decode_lsb+0xd9>
  800420f297:	83 f8 02             	cmp    $0x2,%eax
  800420f29a:	7f 0e                	jg     800420f2aa <_dwarf_decode_lsb+0x41>
  800420f29c:	83 f8 01             	cmp    $0x1,%eax
  800420f29f:	0f 84 b3 00 00 00    	je     800420f358 <_dwarf_decode_lsb+0xef>
  800420f2a5:	e9 d9 00 00 00       	jmpq   800420f383 <_dwarf_decode_lsb+0x11a>
  800420f2aa:	83 f8 04             	cmp    $0x4,%eax
  800420f2ad:	74 65                	je     800420f314 <_dwarf_decode_lsb+0xab>
  800420f2af:	83 f8 08             	cmp    $0x8,%eax
  800420f2b2:	0f 85 cb 00 00 00    	jne    800420f383 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420f2b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2bc:	48 83 c0 04          	add    $0x4,%rax
  800420f2c0:	0f b6 00             	movzbl (%rax),%eax
  800420f2c3:	0f b6 c0             	movzbl %al,%eax
  800420f2c6:	48 c1 e0 20          	shl    $0x20,%rax
  800420f2ca:	48 89 c2             	mov    %rax,%rdx
  800420f2cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2d1:	48 83 c0 05          	add    $0x5,%rax
  800420f2d5:	0f b6 00             	movzbl (%rax),%eax
  800420f2d8:	0f b6 c0             	movzbl %al,%eax
  800420f2db:	48 c1 e0 28          	shl    $0x28,%rax
  800420f2df:	48 09 d0             	or     %rdx,%rax
  800420f2e2:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420f2e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2ea:	48 83 c0 06          	add    $0x6,%rax
  800420f2ee:	0f b6 00             	movzbl (%rax),%eax
  800420f2f1:	0f b6 c0             	movzbl %al,%eax
  800420f2f4:	48 c1 e0 30          	shl    $0x30,%rax
  800420f2f8:	48 89 c2             	mov    %rax,%rdx
  800420f2fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f2ff:	48 83 c0 07          	add    $0x7,%rax
  800420f303:	0f b6 00             	movzbl (%rax),%eax
  800420f306:	0f b6 c0             	movzbl %al,%eax
  800420f309:	48 c1 e0 38          	shl    $0x38,%rax
  800420f30d:	48 09 d0             	or     %rdx,%rax
  800420f310:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420f314:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f318:	48 83 c0 02          	add    $0x2,%rax
  800420f31c:	0f b6 00             	movzbl (%rax),%eax
  800420f31f:	0f b6 c0             	movzbl %al,%eax
  800420f322:	48 c1 e0 10          	shl    $0x10,%rax
  800420f326:	48 89 c2             	mov    %rax,%rdx
  800420f329:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f32d:	48 83 c0 03          	add    $0x3,%rax
  800420f331:	0f b6 00             	movzbl (%rax),%eax
  800420f334:	0f b6 c0             	movzbl %al,%eax
  800420f337:	48 c1 e0 18          	shl    $0x18,%rax
  800420f33b:	48 09 d0             	or     %rdx,%rax
  800420f33e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420f342:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f346:	48 83 c0 01          	add    $0x1,%rax
  800420f34a:	0f b6 00             	movzbl (%rax),%eax
  800420f34d:	0f b6 c0             	movzbl %al,%eax
  800420f350:	48 c1 e0 08          	shl    $0x8,%rax
  800420f354:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420f358:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f35c:	0f b6 00             	movzbl (%rax),%eax
  800420f35f:	0f b6 c0             	movzbl %al,%eax
  800420f362:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f366:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800420f367:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f36b:	48 8b 10             	mov    (%rax),%rdx
  800420f36e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f371:	48 98                	cltq   
  800420f373:	48 01 c2             	add    %rax,%rdx
  800420f376:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f37a:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f37d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f381:	eb 05                	jmp    800420f388 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420f383:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  800420f388:	c9                   	leaveq 
  800420f389:	c3                   	retq   

000000800420f38a <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420f38a:	55                   	push   %rbp
  800420f38b:	48 89 e5             	mov    %rsp,%rbp
  800420f38e:	48 83 ec 28          	sub    $0x28,%rsp
  800420f392:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f396:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f39a:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420f39d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f3a1:	48 8b 10             	mov    (%rax),%rdx
  800420f3a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f3a8:	48 01 d0             	add    %rdx,%rax
  800420f3ab:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  800420f3af:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f3b2:	83 f8 02             	cmp    $0x2,%eax
  800420f3b5:	74 35                	je     800420f3ec <_dwarf_read_msb+0x62>
  800420f3b7:	83 f8 02             	cmp    $0x2,%eax
  800420f3ba:	7f 0a                	jg     800420f3c6 <_dwarf_read_msb+0x3c>
  800420f3bc:	83 f8 01             	cmp    $0x1,%eax
  800420f3bf:	74 18                	je     800420f3d9 <_dwarf_read_msb+0x4f>
  800420f3c1:	e9 53 01 00 00       	jmpq   800420f519 <_dwarf_read_msb+0x18f>
  800420f3c6:	83 f8 04             	cmp    $0x4,%eax
  800420f3c9:	74 49                	je     800420f414 <_dwarf_read_msb+0x8a>
  800420f3cb:	83 f8 08             	cmp    $0x8,%eax
  800420f3ce:	0f 84 96 00 00 00    	je     800420f46a <_dwarf_read_msb+0xe0>
  800420f3d4:	e9 40 01 00 00       	jmpq   800420f519 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  800420f3d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3dd:	0f b6 00             	movzbl (%rax),%eax
  800420f3e0:	0f b6 c0             	movzbl %al,%eax
  800420f3e3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f3e7:	e9 34 01 00 00       	jmpq   800420f520 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420f3ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3f0:	48 83 c0 01          	add    $0x1,%rax
  800420f3f4:	0f b6 00             	movzbl (%rax),%eax
  800420f3f7:	0f b6 d0             	movzbl %al,%edx
  800420f3fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f3fe:	0f b6 00             	movzbl (%rax),%eax
  800420f401:	0f b6 c0             	movzbl %al,%eax
  800420f404:	48 c1 e0 08          	shl    $0x8,%rax
  800420f408:	48 09 d0             	or     %rdx,%rax
  800420f40b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f40f:	e9 0c 01 00 00       	jmpq   800420f520 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420f414:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f418:	48 83 c0 03          	add    $0x3,%rax
  800420f41c:	0f b6 00             	movzbl (%rax),%eax
  800420f41f:	0f b6 c0             	movzbl %al,%eax
  800420f422:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f426:	48 83 c2 02          	add    $0x2,%rdx
  800420f42a:	0f b6 12             	movzbl (%rdx),%edx
  800420f42d:	0f b6 d2             	movzbl %dl,%edx
  800420f430:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f434:	48 09 d0             	or     %rdx,%rax
  800420f437:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420f43b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f43f:	48 83 c0 01          	add    $0x1,%rax
  800420f443:	0f b6 00             	movzbl (%rax),%eax
  800420f446:	0f b6 c0             	movzbl %al,%eax
  800420f449:	48 c1 e0 10          	shl    $0x10,%rax
  800420f44d:	48 89 c2             	mov    %rax,%rdx
  800420f450:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f454:	0f b6 00             	movzbl (%rax),%eax
  800420f457:	0f b6 c0             	movzbl %al,%eax
  800420f45a:	48 c1 e0 18          	shl    $0x18,%rax
  800420f45e:	48 09 d0             	or     %rdx,%rax
  800420f461:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f465:	e9 b6 00 00 00       	jmpq   800420f520 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420f46a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f46e:	48 83 c0 07          	add    $0x7,%rax
  800420f472:	0f b6 00             	movzbl (%rax),%eax
  800420f475:	0f b6 c0             	movzbl %al,%eax
  800420f478:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f47c:	48 83 c2 06          	add    $0x6,%rdx
  800420f480:	0f b6 12             	movzbl (%rdx),%edx
  800420f483:	0f b6 d2             	movzbl %dl,%edx
  800420f486:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f48a:	48 09 d0             	or     %rdx,%rax
  800420f48d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f491:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f495:	48 83 c0 05          	add    $0x5,%rax
  800420f499:	0f b6 00             	movzbl (%rax),%eax
  800420f49c:	0f b6 c0             	movzbl %al,%eax
  800420f49f:	48 c1 e0 10          	shl    $0x10,%rax
  800420f4a3:	48 89 c2             	mov    %rax,%rdx
  800420f4a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4aa:	48 83 c0 04          	add    $0x4,%rax
  800420f4ae:	0f b6 00             	movzbl (%rax),%eax
  800420f4b1:	0f b6 c0             	movzbl %al,%eax
  800420f4b4:	48 c1 e0 18          	shl    $0x18,%rax
  800420f4b8:	48 09 d0             	or     %rdx,%rax
  800420f4bb:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f4bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4c3:	48 83 c0 03          	add    $0x3,%rax
  800420f4c7:	0f b6 00             	movzbl (%rax),%eax
  800420f4ca:	0f b6 c0             	movzbl %al,%eax
  800420f4cd:	48 c1 e0 20          	shl    $0x20,%rax
  800420f4d1:	48 89 c2             	mov    %rax,%rdx
  800420f4d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4d8:	48 83 c0 02          	add    $0x2,%rax
  800420f4dc:	0f b6 00             	movzbl (%rax),%eax
  800420f4df:	0f b6 c0             	movzbl %al,%eax
  800420f4e2:	48 c1 e0 28          	shl    $0x28,%rax
  800420f4e6:	48 09 d0             	or     %rdx,%rax
  800420f4e9:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f4ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4f1:	48 83 c0 01          	add    $0x1,%rax
  800420f4f5:	0f b6 00             	movzbl (%rax),%eax
  800420f4f8:	0f b6 c0             	movzbl %al,%eax
  800420f4fb:	48 c1 e0 30          	shl    $0x30,%rax
  800420f4ff:	48 89 c2             	mov    %rax,%rdx
  800420f502:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f506:	0f b6 00             	movzbl (%rax),%eax
  800420f509:	0f b6 c0             	movzbl %al,%eax
  800420f50c:	48 c1 e0 38          	shl    $0x38,%rax
  800420f510:	48 09 d0             	or     %rdx,%rax
  800420f513:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f517:	eb 07                	jmp    800420f520 <_dwarf_read_msb+0x196>
	default:
		return (0);
  800420f519:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f51e:	eb 1a                	jmp    800420f53a <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  800420f520:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f524:	48 8b 10             	mov    (%rax),%rdx
  800420f527:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420f52a:	48 98                	cltq   
  800420f52c:	48 01 c2             	add    %rax,%rdx
  800420f52f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f533:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f536:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f53a:	c9                   	leaveq 
  800420f53b:	c3                   	retq   

000000800420f53c <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800420f53c:	55                   	push   %rbp
  800420f53d:	48 89 e5             	mov    %rsp,%rbp
  800420f540:	48 83 ec 20          	sub    $0x20,%rsp
  800420f544:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f548:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420f54b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f54f:	48 8b 00             	mov    (%rax),%rax
  800420f552:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420f556:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f55d:	00 
	switch (bytes_to_read) {
  800420f55e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f561:	83 f8 02             	cmp    $0x2,%eax
  800420f564:	74 35                	je     800420f59b <_dwarf_decode_msb+0x5f>
  800420f566:	83 f8 02             	cmp    $0x2,%eax
  800420f569:	7f 0a                	jg     800420f575 <_dwarf_decode_msb+0x39>
  800420f56b:	83 f8 01             	cmp    $0x1,%eax
  800420f56e:	74 18                	je     800420f588 <_dwarf_decode_msb+0x4c>
  800420f570:	e9 53 01 00 00       	jmpq   800420f6c8 <_dwarf_decode_msb+0x18c>
  800420f575:	83 f8 04             	cmp    $0x4,%eax
  800420f578:	74 49                	je     800420f5c3 <_dwarf_decode_msb+0x87>
  800420f57a:	83 f8 08             	cmp    $0x8,%eax
  800420f57d:	0f 84 96 00 00 00    	je     800420f619 <_dwarf_decode_msb+0xdd>
  800420f583:	e9 40 01 00 00       	jmpq   800420f6c8 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  800420f588:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f58c:	0f b6 00             	movzbl (%rax),%eax
  800420f58f:	0f b6 c0             	movzbl %al,%eax
  800420f592:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f596:	e9 34 01 00 00       	jmpq   800420f6cf <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420f59b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f59f:	48 83 c0 01          	add    $0x1,%rax
  800420f5a3:	0f b6 00             	movzbl (%rax),%eax
  800420f5a6:	0f b6 d0             	movzbl %al,%edx
  800420f5a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5ad:	0f b6 00             	movzbl (%rax),%eax
  800420f5b0:	0f b6 c0             	movzbl %al,%eax
  800420f5b3:	48 c1 e0 08          	shl    $0x8,%rax
  800420f5b7:	48 09 d0             	or     %rdx,%rax
  800420f5ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420f5be:	e9 0c 01 00 00       	jmpq   800420f6cf <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420f5c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5c7:	48 83 c0 03          	add    $0x3,%rax
  800420f5cb:	0f b6 00             	movzbl (%rax),%eax
  800420f5ce:	0f b6 c0             	movzbl %al,%eax
  800420f5d1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f5d5:	48 83 c2 02          	add    $0x2,%rdx
  800420f5d9:	0f b6 12             	movzbl (%rdx),%edx
  800420f5dc:	0f b6 d2             	movzbl %dl,%edx
  800420f5df:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f5e3:	48 09 d0             	or     %rdx,%rax
  800420f5e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420f5ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f5ee:	48 83 c0 01          	add    $0x1,%rax
  800420f5f2:	0f b6 00             	movzbl (%rax),%eax
  800420f5f5:	0f b6 c0             	movzbl %al,%eax
  800420f5f8:	48 c1 e0 10          	shl    $0x10,%rax
  800420f5fc:	48 89 c2             	mov    %rax,%rdx
  800420f5ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f603:	0f b6 00             	movzbl (%rax),%eax
  800420f606:	0f b6 c0             	movzbl %al,%eax
  800420f609:	48 c1 e0 18          	shl    $0x18,%rax
  800420f60d:	48 09 d0             	or     %rdx,%rax
  800420f610:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f614:	e9 b6 00 00 00       	jmpq   800420f6cf <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420f619:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f61d:	48 83 c0 07          	add    $0x7,%rax
  800420f621:	0f b6 00             	movzbl (%rax),%eax
  800420f624:	0f b6 c0             	movzbl %al,%eax
  800420f627:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f62b:	48 83 c2 06          	add    $0x6,%rdx
  800420f62f:	0f b6 12             	movzbl (%rdx),%edx
  800420f632:	0f b6 d2             	movzbl %dl,%edx
  800420f635:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f639:	48 09 d0             	or     %rdx,%rax
  800420f63c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f640:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f644:	48 83 c0 05          	add    $0x5,%rax
  800420f648:	0f b6 00             	movzbl (%rax),%eax
  800420f64b:	0f b6 c0             	movzbl %al,%eax
  800420f64e:	48 c1 e0 10          	shl    $0x10,%rax
  800420f652:	48 89 c2             	mov    %rax,%rdx
  800420f655:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f659:	48 83 c0 04          	add    $0x4,%rax
  800420f65d:	0f b6 00             	movzbl (%rax),%eax
  800420f660:	0f b6 c0             	movzbl %al,%eax
  800420f663:	48 c1 e0 18          	shl    $0x18,%rax
  800420f667:	48 09 d0             	or     %rdx,%rax
  800420f66a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f66e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f672:	48 83 c0 03          	add    $0x3,%rax
  800420f676:	0f b6 00             	movzbl (%rax),%eax
  800420f679:	0f b6 c0             	movzbl %al,%eax
  800420f67c:	48 c1 e0 20          	shl    $0x20,%rax
  800420f680:	48 89 c2             	mov    %rax,%rdx
  800420f683:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f687:	48 83 c0 02          	add    $0x2,%rax
  800420f68b:	0f b6 00             	movzbl (%rax),%eax
  800420f68e:	0f b6 c0             	movzbl %al,%eax
  800420f691:	48 c1 e0 28          	shl    $0x28,%rax
  800420f695:	48 09 d0             	or     %rdx,%rax
  800420f698:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f69c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f6a0:	48 83 c0 01          	add    $0x1,%rax
  800420f6a4:	0f b6 00             	movzbl (%rax),%eax
  800420f6a7:	0f b6 c0             	movzbl %al,%eax
  800420f6aa:	48 c1 e0 30          	shl    $0x30,%rax
  800420f6ae:	48 89 c2             	mov    %rax,%rdx
  800420f6b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f6b5:	0f b6 00             	movzbl (%rax),%eax
  800420f6b8:	0f b6 c0             	movzbl %al,%eax
  800420f6bb:	48 c1 e0 38          	shl    $0x38,%rax
  800420f6bf:	48 09 d0             	or     %rdx,%rax
  800420f6c2:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f6c6:	eb 07                	jmp    800420f6cf <_dwarf_decode_msb+0x193>
	default:
		return (0);
  800420f6c8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6cd:	eb 1a                	jmp    800420f6e9 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  800420f6cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6d3:	48 8b 10             	mov    (%rax),%rdx
  800420f6d6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f6d9:	48 98                	cltq   
  800420f6db:	48 01 c2             	add    %rax,%rdx
  800420f6de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6e2:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f6e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f6e9:	c9                   	leaveq 
  800420f6ea:	c3                   	retq   

000000800420f6eb <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f6eb:	55                   	push   %rbp
  800420f6ec:	48 89 e5             	mov    %rsp,%rbp
  800420f6ef:	48 83 ec 30          	sub    $0x30,%rsp
  800420f6f3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f6f7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  800420f6fb:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f702:	00 
	uint8_t b;
	int shift = 0;
  800420f703:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f70a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f70e:	48 8b 10             	mov    (%rax),%rdx
  800420f711:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f715:	48 01 d0             	add    %rdx,%rax
  800420f718:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f71c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f720:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f724:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f728:	0f b6 00             	movzbl (%rax),%eax
  800420f72b:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f72e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f732:	83 e0 7f             	and    $0x7f,%eax
  800420f735:	89 c2                	mov    %eax,%edx
  800420f737:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f73a:	89 c1                	mov    %eax,%ecx
  800420f73c:	d3 e2                	shl    %cl,%edx
  800420f73e:	89 d0                	mov    %edx,%eax
  800420f740:	48 98                	cltq   
  800420f742:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420f746:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f74a:	48 8b 00             	mov    (%rax),%rax
  800420f74d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f751:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f755:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f758:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f75c:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f760:	84 c0                	test   %al,%al
  800420f762:	78 b8                	js     800420f71c <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  800420f764:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f768:	7f 1f                	jg     800420f789 <_dwarf_read_sleb128+0x9e>
  800420f76a:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f76e:	83 e0 40             	and    $0x40,%eax
  800420f771:	85 c0                	test   %eax,%eax
  800420f773:	74 14                	je     800420f789 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  800420f775:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f778:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f77d:	89 c1                	mov    %eax,%ecx
  800420f77f:	d3 e2                	shl    %cl,%edx
  800420f781:	89 d0                	mov    %edx,%eax
  800420f783:	48 98                	cltq   
  800420f785:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  800420f789:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f78d:	c9                   	leaveq 
  800420f78e:	c3                   	retq   

000000800420f78f <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f78f:	55                   	push   %rbp
  800420f790:	48 89 e5             	mov    %rsp,%rbp
  800420f793:	48 83 ec 30          	sub    $0x30,%rsp
  800420f797:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f79b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  800420f79f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f7a6:	00 
	uint8_t b;
	int shift = 0;
  800420f7a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f7ae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f7b2:	48 8b 10             	mov    (%rax),%rdx
  800420f7b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f7b9:	48 01 d0             	add    %rdx,%rax
  800420f7bc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f7c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7c4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f7c8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f7cc:	0f b6 00             	movzbl (%rax),%eax
  800420f7cf:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f7d2:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f7d6:	83 e0 7f             	and    $0x7f,%eax
  800420f7d9:	89 c2                	mov    %eax,%edx
  800420f7db:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f7de:	89 c1                	mov    %eax,%ecx
  800420f7e0:	d3 e2                	shl    %cl,%edx
  800420f7e2:	89 d0                	mov    %edx,%eax
  800420f7e4:	48 98                	cltq   
  800420f7e6:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  800420f7ea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f7ee:	48 8b 00             	mov    (%rax),%rax
  800420f7f1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f7f5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f7f9:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f7fc:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f800:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f804:	84 c0                	test   %al,%al
  800420f806:	78 b8                	js     800420f7c0 <_dwarf_read_uleb128+0x31>

	return (ret);
  800420f808:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f80c:	c9                   	leaveq 
  800420f80d:	c3                   	retq   

000000800420f80e <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800420f80e:	55                   	push   %rbp
  800420f80f:	48 89 e5             	mov    %rsp,%rbp
  800420f812:	48 83 ec 28          	sub    $0x28,%rsp
  800420f816:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  800420f81a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f821:	00 
	uint8_t b;
	int shift = 0;
  800420f822:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420f829:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f82d:	48 8b 00             	mov    (%rax),%rax
  800420f830:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f834:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f838:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f83c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f840:	0f b6 00             	movzbl (%rax),%eax
  800420f843:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f846:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f84a:	83 e0 7f             	and    $0x7f,%eax
  800420f84d:	89 c2                	mov    %eax,%edx
  800420f84f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f852:	89 c1                	mov    %eax,%ecx
  800420f854:	d3 e2                	shl    %cl,%edx
  800420f856:	89 d0                	mov    %edx,%eax
  800420f858:	48 98                	cltq   
  800420f85a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420f85e:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f862:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f866:	84 c0                	test   %al,%al
  800420f868:	78 ca                	js     800420f834 <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  800420f86a:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f86e:	7f 1f                	jg     800420f88f <_dwarf_decode_sleb128+0x81>
  800420f870:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f874:	83 e0 40             	and    $0x40,%eax
  800420f877:	85 c0                	test   %eax,%eax
  800420f879:	74 14                	je     800420f88f <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  800420f87b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f87e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f883:	89 c1                	mov    %eax,%ecx
  800420f885:	d3 e2                	shl    %cl,%edx
  800420f887:	89 d0                	mov    %edx,%eax
  800420f889:	48 98                	cltq   
  800420f88b:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800420f88f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f893:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f897:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f89a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f89e:	c9                   	leaveq 
  800420f89f:	c3                   	retq   

000000800420f8a0 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  800420f8a0:	55                   	push   %rbp
  800420f8a1:	48 89 e5             	mov    %rsp,%rbp
  800420f8a4:	48 83 ec 28          	sub    $0x28,%rsp
  800420f8a8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  800420f8ac:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f8b3:	00 
	uint8_t b;
	int shift = 0;
  800420f8b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  800420f8bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f8bf:	48 8b 00             	mov    (%rax),%rax
  800420f8c2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800420f8c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8ca:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f8ce:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f8d2:	0f b6 00             	movzbl (%rax),%eax
  800420f8d5:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f8d8:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f8dc:	83 e0 7f             	and    $0x7f,%eax
  800420f8df:	89 c2                	mov    %eax,%edx
  800420f8e1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f8e4:	89 c1                	mov    %eax,%ecx
  800420f8e6:	d3 e2                	shl    %cl,%edx
  800420f8e8:	89 d0                	mov    %edx,%eax
  800420f8ea:	48 98                	cltq   
  800420f8ec:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800420f8f0:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800420f8f4:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420f8f8:	84 c0                	test   %al,%al
  800420f8fa:	78 ca                	js     800420f8c6 <_dwarf_decode_uleb128+0x26>

	*dp = src;
  800420f8fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f900:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f904:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f907:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f90b:	c9                   	leaveq 
  800420f90c:	c3                   	retq   

000000800420f90d <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800420f90d:	55                   	push   %rbp
  800420f90e:	48 89 e5             	mov    %rsp,%rbp
  800420f911:	48 83 ec 28          	sub    $0x28,%rsp
  800420f915:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f919:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f91d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800420f921:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f925:	48 8b 10             	mov    (%rax),%rdx
  800420f928:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f92c:	48 01 d0             	add    %rdx,%rax
  800420f92f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f933:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f937:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800420f93b:	eb 17                	jmp    800420f954 <_dwarf_read_string+0x47>
		src++;
  800420f93d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800420f942:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f946:	48 8b 00             	mov    (%rax),%rax
  800420f949:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f94d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f951:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800420f954:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f958:	0f b6 00             	movzbl (%rax),%eax
  800420f95b:	84 c0                	test   %al,%al
  800420f95d:	74 0d                	je     800420f96c <_dwarf_read_string+0x5f>
  800420f95f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f963:	48 8b 00             	mov    (%rax),%rax
  800420f966:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420f96a:	72 d1                	jb     800420f93d <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800420f96c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f970:	0f b6 00             	movzbl (%rax),%eax
  800420f973:	84 c0                	test   %al,%al
  800420f975:	75 1f                	jne    800420f996 <_dwarf_read_string+0x89>
  800420f977:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f97b:	48 8b 00             	mov    (%rax),%rax
  800420f97e:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420f982:	73 12                	jae    800420f996 <_dwarf_read_string+0x89>
		(*offsetp)++;
  800420f984:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f988:	48 8b 00             	mov    (%rax),%rax
  800420f98b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f98f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f993:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f996:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f99a:	c9                   	leaveq 
  800420f99b:	c3                   	retq   

000000800420f99c <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800420f99c:	55                   	push   %rbp
  800420f99d:	48 89 e5             	mov    %rsp,%rbp
  800420f9a0:	48 83 ec 28          	sub    $0x28,%rsp
  800420f9a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f9a8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f9ac:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  800420f9b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f9b4:	48 8b 10             	mov    (%rax),%rdx
  800420f9b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9bb:	48 01 d0             	add    %rdx,%rax
  800420f9be:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f9c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9c6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  800420f9ca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f9ce:	48 8b 10             	mov    (%rax),%rdx
  800420f9d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f9d5:	48 01 c2             	add    %rax,%rdx
  800420f9d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f9dc:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f9df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f9e3:	c9                   	leaveq 
  800420f9e4:	c3                   	retq   

000000800420f9e5 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800420f9e5:	55                   	push   %rbp
  800420f9e6:	48 89 e5             	mov    %rsp,%rbp
  800420f9e9:	48 83 ec 20          	sub    $0x20,%rsp
  800420f9ed:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  800420f9f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f9f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420f9f9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420f9fe:	75 35                	jne    800420fa35 <_dwarf_elf_get_byte_order+0x50>
  800420fa00:	48 b9 a0 83 21 04 80 	movabs $0x80042183a0,%rcx
  800420fa07:	00 00 00 
  800420fa0a:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  800420fa11:	00 00 00 
  800420fa14:	be 29 01 00 00       	mov    $0x129,%esi
  800420fa19:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  800420fa20:	00 00 00 
  800420fa23:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa28:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420fa2f:	00 00 00 
  800420fa32:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  800420fa35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa39:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800420fa3d:	0f b6 c0             	movzbl %al,%eax
  800420fa40:	83 f8 02             	cmp    $0x2,%eax
  800420fa43:	75 07                	jne    800420fa4c <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  800420fa45:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa4a:	eb 05                	jmp    800420fa51 <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  800420fa4c:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  800420fa51:	c9                   	leaveq 
  800420fa52:	c3                   	retq   

000000800420fa53 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800420fa53:	55                   	push   %rbp
  800420fa54:	48 89 e5             	mov    %rsp,%rbp
  800420fa57:	48 83 ec 20          	sub    $0x20,%rsp
  800420fa5b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800420fa5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fa63:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  800420fa67:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420fa6c:	75 35                	jne    800420faa3 <_dwarf_elf_get_pointer_size+0x50>
  800420fa6e:	48 b9 a0 83 21 04 80 	movabs $0x80042183a0,%rcx
  800420fa75:	00 00 00 
  800420fa78:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  800420fa7f:	00 00 00 
  800420fa82:	be 3f 01 00 00       	mov    $0x13f,%esi
  800420fa87:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  800420fa8e:	00 00 00 
  800420fa91:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa96:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420fa9d:	00 00 00 
  800420faa0:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  800420faa3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420faa7:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  800420faab:	3c 01                	cmp    $0x1,%al
  800420faad:	75 07                	jne    800420fab6 <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  800420faaf:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fab4:	eb 05                	jmp    800420fabb <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  800420fab6:	b8 08 00 00 00       	mov    $0x8,%eax
}
  800420fabb:	c9                   	leaveq 
  800420fabc:	c3                   	retq   

000000800420fabd <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  800420fabd:	55                   	push   %rbp
  800420fabe:	48 89 e5             	mov    %rsp,%rbp
  800420fac1:	48 83 ec 10          	sub    $0x10,%rsp
  800420fac5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fac9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800420facd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fad1:	ba 60 00 00 00       	mov    $0x60,%edx
  800420fad6:	be 00 00 00 00       	mov    $0x0,%esi
  800420fadb:	48 89 c7             	mov    %rax,%rdi
  800420fade:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  800420fae5:	00 00 00 
  800420fae8:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  800420faea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420faee:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  800420faf5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420faf9:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800420fb00:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800420fb01:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb05:	48 89 c7             	mov    %rax,%rdi
  800420fb08:	48 b8 53 fa 20 04 80 	movabs $0x800420fa53,%rax
  800420fb0f:	00 00 00 
  800420fb12:	ff d0                	callq  *%rax
  800420fb14:	0f b6 d0             	movzbl %al,%edx
  800420fb17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb1b:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800420fb1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb22:	48 89 c7             	mov    %rax,%rdi
  800420fb25:	48 b8 e5 f9 20 04 80 	movabs $0x800420f9e5,%rax
  800420fb2c:	00 00 00 
  800420fb2f:	ff d0                	callq  *%rax
  800420fb31:	85 c0                	test   %eax,%eax
  800420fb33:	75 26                	jne    800420fb5b <_dwarf_init+0x9e>
		dbg->read = _dwarf_read_msb;
  800420fb35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb39:	48 b9 8a f3 20 04 80 	movabs $0x800420f38a,%rcx
  800420fb40:	00 00 00 
  800420fb43:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  800420fb47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb4b:	48 b9 3c f5 20 04 80 	movabs $0x800420f53c,%rcx
  800420fb52:	00 00 00 
  800420fb55:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420fb59:	eb 24                	jmp    800420fb7f <_dwarf_init+0xc2>
	} else {
		dbg->read = _dwarf_read_lsb;
  800420fb5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb5f:	48 be 3d f1 20 04 80 	movabs $0x800420f13d,%rsi
  800420fb66:	00 00 00 
  800420fb69:	48 89 70 18          	mov    %rsi,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  800420fb6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb71:	48 ba 69 f2 20 04 80 	movabs $0x800420f269,%rdx
  800420fb78:	00 00 00 
  800420fb7b:	48 89 50 20          	mov    %rdx,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  800420fb7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb83:	48 89 c7             	mov    %rax,%rdi
  800420fb86:	48 b8 c7 0f 21 04 80 	movabs $0x8004210fc7,%rax
  800420fb8d:	00 00 00 
  800420fb90:	ff d0                	callq  *%rax
	return 0;
  800420fb92:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fb97:	c9                   	leaveq 
  800420fb98:	c3                   	retq   

000000800420fb99 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  800420fb99:	55                   	push   %rbp
  800420fb9a:	48 89 e5             	mov    %rsp,%rbp
  800420fb9d:	48 83 ec 20          	sub    $0x20,%rsp
  800420fba1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fba5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  800420fba9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbad:	48 8b 10             	mov    (%rax),%rdx
  800420fbb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbb4:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420fbb8:	48 39 c2             	cmp    %rax,%rdx
  800420fbbb:	76 0a                	jbe    800420fbc7 <_get_next_cu+0x2e>
		return -1;
  800420fbbd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fbc2:	e9 71 01 00 00       	jmpq   800420fd38 <_get_next_cu+0x19f>

	offset = dbg->curr_off_dbginfo;
  800420fbc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbcb:	48 8b 00             	mov    (%rax),%rax
  800420fbce:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800420fbd2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fbd6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fbda:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800420fbde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fbe2:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fbe6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fbea:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fbee:	48 89 d7             	mov    %rdx,%rdi
  800420fbf1:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420fbf5:	ba 04 00 00 00       	mov    $0x4,%edx
  800420fbfa:	48 89 ce             	mov    %rcx,%rsi
  800420fbfd:	ff d0                	callq  *%rax
  800420fbff:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  800420fc02:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420fc06:	75 2a                	jne    800420fc32 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  800420fc08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc0c:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fc10:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fc14:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fc18:	48 89 d7             	mov    %rdx,%rdi
  800420fc1b:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420fc1f:	ba 08 00 00 00       	mov    $0x8,%edx
  800420fc24:	48 89 ce             	mov    %rcx,%rsi
  800420fc27:	ff d0                	callq  *%rax
  800420fc29:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  800420fc2c:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800420fc30:	eb 04                	jmp    800420fc36 <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  800420fc32:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  800420fc36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc3a:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420fc3e:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  800420fc41:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420fc44:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fc48:	48 01 c2             	add    %rax,%rdx
  800420fc4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc4f:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  800420fc52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc56:	48 8b 10             	mov    (%rax),%rdx
  800420fc59:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc5d:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  800420fc61:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420fc64:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc68:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800420fc6b:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800420fc6f:	75 07                	jne    800420fc78 <_get_next_cu+0xdf>
  800420fc71:	ba 04 00 00 00       	mov    $0x4,%edx
  800420fc76:	eb 05                	jmp    800420fc7d <_get_next_cu+0xe4>
  800420fc78:	ba 0c 00 00 00       	mov    $0xc,%edx
  800420fc7d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc81:	88 50 18             	mov    %dl,0x18(%rax)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  800420fc84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc88:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fc8c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fc90:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fc94:	48 89 d7             	mov    %rdx,%rdi
  800420fc97:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420fc9b:	ba 02 00 00 00       	mov    $0x2,%edx
  800420fca0:	48 89 ce             	mov    %rcx,%rsi
  800420fca3:	ff d0                	callq  *%rax
  800420fca5:	89 c2                	mov    %eax,%edx
  800420fca7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fcab:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800420fcaf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcb3:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fcb7:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420fcbb:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fcbf:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  800420fcc3:	48 89 cf             	mov    %rcx,%rdi
  800420fcc6:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420fcca:	48 89 ce             	mov    %rcx,%rsi
  800420fccd:	ff d0                	callq  *%rax
  800420fccf:	48 89 c2             	mov    %rax,%rdx
  800420fcd2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fcd6:	48 89 50 10          	mov    %rdx,0x10(%rax)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  800420fcda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcde:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fce2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fce6:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fcea:	48 89 d7             	mov    %rdx,%rdi
  800420fced:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420fcf1:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fcf6:	48 89 ce             	mov    %rcx,%rsi
  800420fcf9:	ff d0                	callq  *%rax
  800420fcfb:	89 c2                	mov    %eax,%edx
  800420fcfd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fd01:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800420fd04:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fd08:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420fd0c:	66 83 f8 01          	cmp    $0x1,%ax
  800420fd10:	76 0e                	jbe    800420fd20 <_get_next_cu+0x187>
  800420fd12:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fd16:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420fd1a:	66 83 f8 04          	cmp    $0x4,%ax
  800420fd1e:	76 07                	jbe    800420fd27 <_get_next_cu+0x18e>
		return -1;
  800420fd20:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fd25:	eb 11                	jmp    800420fd38 <_get_next_cu+0x19f>
	}

	cu->cu_die_offset = offset;
  800420fd27:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420fd2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fd2f:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800420fd33:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fd38:	c9                   	leaveq 
  800420fd39:	c3                   	retq   

000000800420fd3a <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800420fd3a:	55                   	push   %rbp
  800420fd3b:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  800420fd3e:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  800420fd42:	0f b6 c8             	movzbl %al,%ecx
  800420fd45:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800420fd49:	0f b7 d0             	movzwl %ax,%edx
  800420fd4c:	48 8b 45 10          	mov    0x10(%rbp),%rax
  800420fd50:	48 89 c6             	mov    %rax,%rsi
  800420fd53:	48 bf d2 83 21 04 80 	movabs $0x80042183d2,%rdi
  800420fd5a:	00 00 00 
  800420fd5d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fd62:	49 b8 0a 8e 20 04 80 	movabs $0x8004208e0a,%r8
  800420fd69:	00 00 00 
  800420fd6c:	41 ff d0             	callq  *%r8
}
  800420fd6f:	90                   	nop
  800420fd70:	5d                   	pop    %rbp
  800420fd71:	c3                   	retq   

000000800420fd72 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  800420fd72:	55                   	push   %rbp
  800420fd73:	48 89 e5             	mov    %rsp,%rbp
  800420fd76:	48 83 ec 60          	sub    $0x60,%rsp
  800420fd7a:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420fd7e:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420fd82:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420fd86:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  800420fd8a:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420fd8f:	75 35                	jne    800420fdc6 <_dwarf_abbrev_parse+0x54>
  800420fd91:	48 b9 e1 83 21 04 80 	movabs $0x80042183e1,%rcx
  800420fd98:	00 00 00 
  800420fd9b:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  800420fda2:	00 00 00 
  800420fda5:	be a4 01 00 00       	mov    $0x1a4,%esi
  800420fdaa:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  800420fdb1:	00 00 00 
  800420fdb4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fdb9:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420fdc0:	00 00 00 
  800420fdc3:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  800420fdc6:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  800420fdcb:	75 35                	jne    800420fe02 <_dwarf_abbrev_parse+0x90>
  800420fdcd:	48 b9 ed 83 21 04 80 	movabs $0x80042183ed,%rcx
  800420fdd4:	00 00 00 
  800420fdd7:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  800420fdde:	00 00 00 
  800420fde1:	be a5 01 00 00       	mov    $0x1a5,%esi
  800420fde6:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  800420fded:	00 00 00 
  800420fdf0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fdf5:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800420fdfc:	00 00 00 
  800420fdff:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  800420fe02:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fe06:	48 8b 10             	mov    (%rax),%rdx
  800420fe09:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fe0d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fe11:	48 39 c2             	cmp    %rax,%rdx
  800420fe14:	72 0a                	jb     800420fe20 <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800420fe16:	b8 04 00 00 00       	mov    $0x4,%eax
  800420fe1b:	e9 d3 01 00 00       	jmpq   800420fff3 <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  800420fe20:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fe24:	48 8b 00             	mov    (%rax),%rax
  800420fe27:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800420fe2b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420fe2f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fe33:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420fe37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe3b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fe3f:	48 89 d6             	mov    %rdx,%rsi
  800420fe42:	48 89 c7             	mov    %rax,%rdi
  800420fe45:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  800420fe4c:	00 00 00 
  800420fe4f:	ff d0                	callq  *%rax
  800420fe51:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  800420fe55:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fe5a:	75 15                	jne    800420fe71 <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  800420fe5c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fe60:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  800420fe67:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fe6c:	e9 82 01 00 00       	jmpq   800420fff3 <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420fe71:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe75:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420fe79:	48 89 d6             	mov    %rdx,%rsi
  800420fe7c:	48 89 c7             	mov    %rax,%rdi
  800420fe7f:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  800420fe86:	00 00 00 
  800420fe89:	ff d0                	callq  *%rax
  800420fe8b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  800420fe8f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420fe93:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420fe97:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420fe9b:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800420fe9f:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fea4:	48 89 cf             	mov    %rcx,%rdi
  800420fea7:	ff d0                	callq  *%rax
  800420fea9:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  800420feac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420feb0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420feb4:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  800420feb7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420febb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420febf:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  800420fec3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fec7:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800420fecb:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  800420fece:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fed2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fed6:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  800420feda:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420fede:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  800420fee5:	00 
	abp->ab_atnum    = 0;
  800420fee6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420feea:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  800420fef1:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  800420fef2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420fef6:	48 8b 00             	mov    (%rax),%rax
  800420fef9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420fefd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff01:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ff05:	48 89 d6             	mov    %rdx,%rsi
  800420ff08:	48 89 c7             	mov    %rax,%rdi
  800420ff0b:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  800420ff12:	00 00 00 
  800420ff15:	ff d0                	callq  *%rax
  800420ff17:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420ff1b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff1f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420ff23:	48 89 d6             	mov    %rdx,%rsi
  800420ff26:	48 89 c7             	mov    %rax,%rdi
  800420ff29:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  800420ff30:	00 00 00 
  800420ff33:	ff d0                	callq  *%rax
  800420ff35:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  800420ff39:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420ff3e:	0f 84 89 00 00 00    	je     800420ffcd <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  800420ff44:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ff48:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420ff4c:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420ff50:	48 89 d0             	mov    %rdx,%rax
  800420ff53:	48 01 c0             	add    %rax,%rax
  800420ff56:	48 01 d0             	add    %rdx,%rax
  800420ff59:	48 c1 e0 03          	shl    $0x3,%rax
  800420ff5d:	48 01 c8             	add    %rcx,%rax
  800420ff60:	48 8d 50 30          	lea    0x30(%rax),%rdx
  800420ff64:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ff68:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  800420ff6b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ff6f:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420ff73:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420ff77:	48 89 d0             	mov    %rdx,%rax
  800420ff7a:	48 01 c0             	add    %rax,%rax
  800420ff7d:	48 01 d0             	add    %rdx,%rax
  800420ff80:	48 c1 e0 03          	shl    $0x3,%rax
  800420ff84:	48 01 c8             	add    %rcx,%rax
  800420ff87:	48 8d 50 38          	lea    0x38(%rax),%rdx
  800420ff8b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420ff8f:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  800420ff92:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ff96:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420ff9a:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420ff9e:	48 89 d0             	mov    %rdx,%rax
  800420ffa1:	48 01 c0             	add    %rax,%rax
  800420ffa4:	48 01 d0             	add    %rdx,%rax
  800420ffa7:	48 c1 e0 03          	shl    $0x3,%rax
  800420ffab:	48 01 c8             	add    %rcx,%rax
  800420ffae:	48 8d 50 40          	lea    0x40(%rax),%rdx
  800420ffb2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ffb6:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  800420ffb9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ffbd:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420ffc1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ffc5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ffc9:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  800420ffcd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420ffd2:	0f 85 1a ff ff ff    	jne    800420fef2 <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  800420ffd8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420ffdc:	48 8b 00             	mov    (%rax),%rax
  800420ffdf:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  800420ffe3:	48 89 c2             	mov    %rax,%rdx
  800420ffe6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ffea:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  800420ffee:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fff3:	c9                   	leaveq 
  800420fff4:	c3                   	retq   

000000800420fff5 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  800420fff5:	55                   	push   %rbp
  800420fff6:	48 89 e5             	mov    %rsp,%rbp
  800420fff9:	48 83 ec 40          	sub    $0x40,%rsp
  800420fffd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210001:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210005:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  8004210009:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421000e:	75 0a                	jne    800421001a <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  8004210010:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210015:	e9 e3 00 00 00       	jmpq   80042100fd <_dwarf_abbrev_find+0x108>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  800421001a:	48 bf f8 83 21 04 80 	movabs $0x80042183f8,%rdi
  8004210021:	00 00 00 
  8004210024:	48 b8 88 42 21 04 80 	movabs $0x8004214288,%rax
  800421002b:	00 00 00 
  800421002e:	ff d0                	callq  *%rax
  8004210030:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004210034:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210039:	75 35                	jne    8004210070 <_dwarf_abbrev_find+0x7b>
  800421003b:	48 b9 ed 83 21 04 80 	movabs $0x80042183ed,%rcx
  8004210042:	00 00 00 
  8004210045:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  800421004c:	00 00 00 
  800421004f:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004210054:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  800421005b:	00 00 00 
  800421005e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210063:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800421006a:	00 00 00 
  800421006d:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  8004210070:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210074:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  8004210078:	eb 6a                	jmp    80042100e4 <_dwarf_abbrev_find+0xef>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  800421007a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800421007e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210082:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  8004210086:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421008a:	48 83 ec 08          	sub    $0x8,%rsp
  800421008e:	ff 75 40             	pushq  0x40(%rbp)
  8004210091:	ff 75 38             	pushq  0x38(%rbp)
  8004210094:	ff 75 30             	pushq  0x30(%rbp)
  8004210097:	ff 75 28             	pushq  0x28(%rbp)
  800421009a:	ff 75 20             	pushq  0x20(%rbp)
  800421009d:	ff 75 18             	pushq  0x18(%rbp)
  80042100a0:	ff 75 10             	pushq  0x10(%rbp)
  80042100a3:	48 89 c7             	mov    %rax,%rdi
  80042100a6:	48 b8 72 fd 20 04 80 	movabs $0x800420fd72,%rax
  80042100ad:	00 00 00 
  80042100b0:	ff d0                	callq  *%rax
  80042100b2:	48 83 c4 40          	add    $0x40,%rsp
  80042100b6:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  80042100b9:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  80042100bd:	74 05                	je     80042100c4 <_dwarf_abbrev_find+0xcf>
			return (ret);
  80042100bf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042100c2:	eb 39                	jmp    80042100fd <_dwarf_abbrev_find+0x108>
		if (abp->ab_entry == entry) {
  80042100c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042100c8:	48 8b 00             	mov    (%rax),%rax
  80042100cb:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042100cf:	75 07                	jne    80042100d8 <_dwarf_abbrev_find+0xe3>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  80042100d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042100d6:	eb 25                	jmp    80042100fd <_dwarf_abbrev_find+0x108>
		}
		if (abp->ab_entry == 0) {
  80042100d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042100dc:	48 8b 00             	mov    (%rax),%rax
  80042100df:	48 85 c0             	test   %rax,%rax
  80042100e2:	74 13                	je     80042100f7 <_dwarf_abbrev_find+0x102>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  80042100e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042100e8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042100ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042100f0:	48 39 c2             	cmp    %rax,%rdx
  80042100f3:	77 85                	ja     800421007a <_dwarf_abbrev_find+0x85>
  80042100f5:	eb 01                	jmp    80042100f8 <_dwarf_abbrev_find+0x103>
			return DW_DLE_NONE;
		}
		if (abp->ab_entry == 0) {
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  80042100f7:	90                   	nop
		}
	}

	return DW_DLE_NO_ENTRY;
  80042100f8:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042100fd:	c9                   	leaveq 
  80042100fe:	c3                   	retq   

00000080042100ff <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  80042100ff:	55                   	push   %rbp
  8004210100:	48 89 e5             	mov    %rsp,%rbp
  8004210103:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
  800421010a:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004210111:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004210118:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  800421011f:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  8004210126:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  800421012d:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  8004210134:	48 bf 06 84 21 04 80 	movabs $0x8004218406,%rdi
  800421013b:	00 00 00 
  800421013e:	48 b8 88 42 21 04 80 	movabs $0x8004214288,%rax
  8004210145:	00 00 00 
  8004210148:	ff d0                	callq  *%rax
  800421014a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  800421014e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210152:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210156:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  800421015a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004210161:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004210165:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  8004210168:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  800421016f:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004210176:	ba 60 00 00 00       	mov    $0x60,%edx
  800421017b:	be 00 00 00 00       	mov    $0x0,%esi
  8004210180:	48 89 c7             	mov    %rax,%rdi
  8004210183:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  800421018a:	00 00 00 
  800421018d:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  800421018f:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210196:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  800421019d:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042101a4:	48 8b 00             	mov    (%rax),%rax
  80042101a7:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  80042101ab:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042101b2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042101b6:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  80042101ba:	8b 45 10             	mov    0x10(%rbp),%eax
  80042101bd:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  80042101c0:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80042101c7:	00 

	switch (form) {
  80042101c8:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  80042101cf:	20 
  80042101d0:	0f 87 87 04 00 00    	ja     800421065d <_dwarf_attr_init+0x55e>
  80042101d6:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042101dd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042101e4:	00 
  80042101e5:	48 b8 30 84 21 04 80 	movabs $0x8004218430,%rax
  80042101ec:	00 00 00 
  80042101ef:	48 01 d0             	add    %rdx,%rax
  80042101f2:	48 8b 00             	mov    (%rax),%rax
  80042101f5:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  80042101f7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042101fe:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210202:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004210209:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800421020d:	0f b6 d2             	movzbl %dl,%edx
  8004210210:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210217:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421021b:	48 89 cf             	mov    %rcx,%rdi
  800421021e:	ff d0                	callq  *%rax
  8004210220:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210224:	e9 3e 04 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004210229:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210230:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210234:	48 89 d6             	mov    %rdx,%rsi
  8004210237:	48 89 c7             	mov    %rax,%rdi
  800421023a:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  8004210241:	00 00 00 
  8004210244:	ff d0                	callq  *%rax
  8004210246:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421024a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421024e:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210255:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210259:	48 89 ce             	mov    %rcx,%rsi
  800421025c:	48 89 c7             	mov    %rax,%rdi
  800421025f:	48 b8 9c f9 20 04 80 	movabs $0x800420f99c,%rax
  8004210266:	00 00 00 
  8004210269:	ff d0                	callq  *%rax
  800421026b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421026f:	e9 f3 03 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004210274:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421027b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421027f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210286:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421028a:	ba 01 00 00 00       	mov    $0x1,%edx
  800421028f:	48 89 cf             	mov    %rcx,%rdi
  8004210292:	ff d0                	callq  *%rax
  8004210294:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210298:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421029c:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042102a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102a7:	48 89 ce             	mov    %rcx,%rsi
  80042102aa:	48 89 c7             	mov    %rax,%rdi
  80042102ad:	48 b8 9c f9 20 04 80 	movabs $0x800420f99c,%rax
  80042102b4:	00 00 00 
  80042102b7:	ff d0                	callq  *%rax
  80042102b9:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042102bd:	e9 a5 03 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042102c2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042102c9:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042102cd:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042102d4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042102d8:	ba 02 00 00 00       	mov    $0x2,%edx
  80042102dd:	48 89 cf             	mov    %rcx,%rdi
  80042102e0:	ff d0                	callq  *%rax
  80042102e2:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042102e6:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042102ea:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042102f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042102f5:	48 89 ce             	mov    %rcx,%rsi
  80042102f8:	48 89 c7             	mov    %rax,%rdi
  80042102fb:	48 b8 9c f9 20 04 80 	movabs $0x800420f99c,%rax
  8004210302:	00 00 00 
  8004210305:	ff d0                	callq  *%rax
  8004210307:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421030b:	e9 57 03 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004210310:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210317:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421031b:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210322:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210326:	ba 04 00 00 00       	mov    $0x4,%edx
  800421032b:	48 89 cf             	mov    %rcx,%rdi
  800421032e:	ff d0                	callq  *%rax
  8004210330:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004210334:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210338:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421033f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210343:	48 89 ce             	mov    %rcx,%rsi
  8004210346:	48 89 c7             	mov    %rax,%rdi
  8004210349:	48 b8 9c f9 20 04 80 	movabs $0x800420f99c,%rax
  8004210350:	00 00 00 
  8004210353:	ff d0                	callq  *%rax
  8004210355:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210359:	e9 09 03 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800421035e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210365:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210369:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210370:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210374:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210379:	48 89 cf             	mov    %rcx,%rdi
  800421037c:	ff d0                	callq  *%rax
  800421037e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210382:	e9 e0 02 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  8004210387:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421038e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210392:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210399:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421039d:	ba 02 00 00 00       	mov    $0x2,%edx
  80042103a2:	48 89 cf             	mov    %rcx,%rdi
  80042103a5:	ff d0                	callq  *%rax
  80042103a7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042103ab:	e9 b7 02 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  80042103b0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042103b7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042103bb:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042103c2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042103c6:	ba 04 00 00 00       	mov    $0x4,%edx
  80042103cb:	48 89 cf             	mov    %rcx,%rdi
  80042103ce:	ff d0                	callq  *%rax
  80042103d0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042103d4:	e9 8e 02 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  80042103d9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042103e0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042103e4:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042103eb:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042103ef:	ba 08 00 00 00       	mov    $0x8,%edx
  80042103f4:	48 89 cf             	mov    %rcx,%rdi
  80042103f7:	ff d0                	callq  *%rax
  80042103f9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042103fd:	e9 65 02 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  8004210402:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210409:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421040d:	48 89 d6             	mov    %rdx,%rsi
  8004210410:	48 89 c7             	mov    %rax,%rdi
  8004210413:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  800421041a:	00 00 00 
  800421041d:	ff d0                	callq  *%rax
  800421041f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  8004210426:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  800421042d:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004210434:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800421043b:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004210442:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210449:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210450:	48 83 ec 08          	sub    $0x8,%rsp
  8004210454:	6a 01                	pushq  $0x1
  8004210456:	4d 89 c1             	mov    %r8,%r9
  8004210459:	49 89 f8             	mov    %rdi,%r8
  800421045c:	48 89 c7             	mov    %rax,%rdi
  800421045f:	48 b8 ff 00 21 04 80 	movabs $0x80042100ff,%rax
  8004210466:	00 00 00 
  8004210469:	ff d0                	callq  *%rax
  800421046b:	48 83 c4 10          	add    $0x10,%rsp
  800421046f:	e9 21 03 00 00       	jmpq   8004210795 <_dwarf_attr_init+0x696>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  8004210474:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800421047b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421047f:	66 83 f8 02          	cmp    $0x2,%ax
  8004210483:	75 32                	jne    80042104b7 <_dwarf_attr_init+0x3b8>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  8004210485:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421048c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210490:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004210497:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  800421049b:	0f b6 d2             	movzbl %dl,%edx
  800421049e:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042104a5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042104a9:	48 89 cf             	mov    %rcx,%rdi
  80042104ac:	ff d0                	callq  *%rax
  80042104ae:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		else if (cu->version == 3)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
		break;
  80042104b2:	e9 af 01 00 00       	jmpq   8004210666 <_dwarf_attr_init+0x567>
		form = _dwarf_read_uleb128(ds_data, offsetp);
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
	case DW_FORM_ref_addr:
		if (cu->version == 2)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
		else if (cu->version == 3)
  80042104b7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042104be:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042104c2:	66 83 f8 03          	cmp    $0x3,%ax
  80042104c6:	0f 85 9a 01 00 00    	jne    8004210666 <_dwarf_attr_init+0x567>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042104cc:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042104d3:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042104d7:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042104db:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042104e2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042104e6:	48 89 cf             	mov    %rcx,%rdi
  80042104e9:	ff d0                	callq  *%rax
  80042104eb:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042104ef:	e9 72 01 00 00       	jmpq   8004210666 <_dwarf_attr_init+0x567>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  80042104f4:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042104fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104ff:	48 89 d6             	mov    %rdx,%rsi
  8004210502:	48 89 c7             	mov    %rax,%rdi
  8004210505:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  800421050c:	00 00 00 
  800421050f:	ff d0                	callq  *%rax
  8004210511:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210515:	e9 4d 01 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  800421051a:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210521:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210525:	48 89 d6             	mov    %rdx,%rsi
  8004210528:	48 89 c7             	mov    %rax,%rdi
  800421052b:	48 b8 eb f6 20 04 80 	movabs $0x800420f6eb,%rax
  8004210532:	00 00 00 
  8004210535:	ff d0                	callq  *%rax
  8004210537:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421053b:	e9 27 01 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004210540:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004210547:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421054b:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800421054f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004210556:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421055a:	48 89 cf             	mov    %rcx,%rdi
  800421055d:	ff d0                	callq  *%rax
  800421055f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210563:	e9 ff 00 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  8004210568:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421056c:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004210570:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004210577:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421057b:	48 89 ce             	mov    %rcx,%rsi
  800421057e:	48 89 c7             	mov    %rax,%rdi
  8004210581:	48 b8 0d f9 20 04 80 	movabs $0x800420f90d,%rax
  8004210588:	00 00 00 
  800421058b:	ff d0                	callq  *%rax
  800421058d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004210591:	e9 d1 00 00 00       	jmpq   8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004210596:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421059d:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042105a1:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042105a5:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042105ac:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042105b0:	48 89 cf             	mov    %rcx,%rdi
  80042105b3:	ff d0                	callq  *%rax
  80042105b5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  80042105b9:	48 bf 12 84 21 04 80 	movabs $0x8004218412,%rdi
  80042105c0:	00 00 00 
  80042105c3:	48 b8 88 42 21 04 80 	movabs $0x8004214288,%rax
  80042105ca:	00 00 00 
  80042105cd:	ff d0                	callq  *%rax
  80042105cf:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  80042105d3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042105d8:	75 35                	jne    800421060f <_dwarf_attr_init+0x510>
  80042105da:	48 b9 1d 84 21 04 80 	movabs $0x800421841d,%rcx
  80042105e1:	00 00 00 
  80042105e4:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  80042105eb:	00 00 00 
  80042105ee:	be 51 02 00 00       	mov    $0x251,%esi
  80042105f3:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  80042105fa:	00 00 00 
  80042105fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210602:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210609:	00 00 00 
  800421060c:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  800421060f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210613:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004210617:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421061b:	48 01 d0             	add    %rdx,%rax
  800421061e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210622:	eb 43                	jmp    8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  8004210624:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  800421062b:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  800421062c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210630:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004210637:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421063b:	48 89 ce             	mov    %rcx,%rsi
  800421063e:	48 89 c7             	mov    %rax,%rdi
  8004210641:	48 b8 9c f9 20 04 80 	movabs $0x800420f99c,%rax
  8004210648:	00 00 00 
  800421064b:	ff d0                	callq  *%rax
  800421064d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004210651:	eb 14                	jmp    8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  8004210653:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  800421065a:	00 
		break;
  800421065b:	eb 0a                	jmp    8004210667 <_dwarf_attr_init+0x568>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  800421065d:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  8004210664:	eb 01                	jmp    8004210667 <_dwarf_attr_init+0x568>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
		else if (cu->version == 3)
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
		break;
  8004210666:	90                   	nop
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
		break;
	}

	if (ret == DW_DLE_NONE) {
  8004210667:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421066b:	0f 85 21 01 00 00    	jne    8004210792 <_dwarf_attr_init+0x693>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  8004210671:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  8004210678:	09 
  8004210679:	74 1e                	je     8004210699 <_dwarf_attr_init+0x59a>
  800421067b:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  8004210682:	0a 
  8004210683:	74 14                	je     8004210699 <_dwarf_attr_init+0x59a>
  8004210685:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  800421068c:	03 
  800421068d:	74 0a                	je     8004210699 <_dwarf_attr_init+0x59a>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  800421068f:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  8004210696:	04 
  8004210697:	75 10                	jne    80042106a9 <_dwarf_attr_init+0x5aa>
			atref.at_block.bl_len = atref.u[0].u64;
  8004210699:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421069d:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  80042106a1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042106a5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  80042106a9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042106ad:	48 83 f8 03          	cmp    $0x3,%rax
  80042106b1:	75 39                	jne    80042106ec <_dwarf_attr_init+0x5ed>
			switch (atref.at_form) {
  80042106b3:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042106b7:	48 83 f8 08          	cmp    $0x8,%rax
  80042106bb:	74 1c                	je     80042106d9 <_dwarf_attr_init+0x5da>
  80042106bd:	48 83 f8 0e          	cmp    $0xe,%rax
  80042106c1:	74 02                	je     80042106c5 <_dwarf_attr_init+0x5c6>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  80042106c3:	eb 27                	jmp    80042106ec <_dwarf_attr_init+0x5ed>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  80042106c5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042106c9:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042106d0:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042106d7:	eb 13                	jmp    80042106ec <_dwarf_attr_init+0x5ed>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  80042106d9:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042106dd:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042106e4:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042106eb:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  80042106ec:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042106f3:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  80042106fa:	8d 48 01             	lea    0x1(%rax),%ecx
  80042106fd:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  8004210704:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  800421070a:	0f b6 c0             	movzbl %al,%eax
  800421070d:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004210714:	48 63 d0             	movslq %eax,%rdx
  8004210717:	48 89 d0             	mov    %rdx,%rax
  800421071a:	48 01 c0             	add    %rax,%rax
  800421071d:	48 01 d0             	add    %rdx,%rax
  8004210720:	48 c1 e0 05          	shl    $0x5,%rax
  8004210724:	48 01 c8             	add    %rcx,%rax
  8004210727:	48 05 70 03 00 00    	add    $0x370,%rax
  800421072d:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004210734:	48 89 10             	mov    %rdx,(%rax)
  8004210737:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800421073e:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004210742:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004210746:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421074a:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800421074e:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004210752:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004210756:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421075a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421075e:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004210762:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004210766:	48 89 50 30          	mov    %rdx,0x30(%rax)
  800421076a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800421076e:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004210772:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210776:	48 89 50 40          	mov    %rdx,0x40(%rax)
  800421077a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800421077e:	48 89 50 48          	mov    %rdx,0x48(%rax)
  8004210782:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004210786:	48 89 50 50          	mov    %rdx,0x50(%rax)
  800421078a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421078e:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  8004210792:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004210795:	c9                   	leaveq 
  8004210796:	c3                   	retq   

0000008004210797 <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  8004210797:	55                   	push   %rbp
  8004210798:	48 89 e5             	mov    %rsp,%rbp
  800421079b:	48 81 ec 90 03 00 00 	sub    $0x390,%rsp
  80042107a2:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  80042107a9:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  80042107b0:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  80042107b7:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  80042107bd:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  80042107c4:	00 
  80042107c5:	75 35                	jne    80042107fc <dwarf_search_die_within_cu+0x65>
  80042107c7:	48 b9 38 85 21 04 80 	movabs $0x8004218538,%rcx
  80042107ce:	00 00 00 
  80042107d1:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  80042107d8:	00 00 00 
  80042107db:	be 86 02 00 00       	mov    $0x286,%esi
  80042107e0:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  80042107e7:	00 00 00 
  80042107ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042107ef:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042107f6:	00 00 00 
  80042107f9:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  80042107fc:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004210803:	00 
  8004210804:	75 35                	jne    800421083b <dwarf_search_die_within_cu+0xa4>
  8004210806:	48 b9 3c 85 21 04 80 	movabs $0x800421853c,%rcx
  800421080d:	00 00 00 
  8004210810:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  8004210817:	00 00 00 
  800421081a:	be 88 02 00 00       	mov    $0x288,%esi
  800421081f:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  8004210826:	00 00 00 
  8004210829:	b8 00 00 00 00       	mov    $0x0,%eax
  800421082e:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210835:	00 00 00 
  8004210838:	41 ff d0             	callq  *%r8

	level = 1;
  800421083b:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004210842:	e9 fa 01 00 00       	jmpq   8004210a41 <dwarf_search_die_within_cu+0x2aa>

		die_offset = offset;
  8004210847:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800421084e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  8004210852:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210859:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421085d:	48 89 c2             	mov    %rax,%rdx
  8004210860:	48 8d 85 80 fc ff ff 	lea    -0x380(%rbp),%rax
  8004210867:	48 89 c6             	mov    %rax,%rsi
  800421086a:	48 89 d7             	mov    %rdx,%rdi
  800421086d:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  8004210874:	00 00 00 
  8004210877:	ff d0                	callq  *%rax
  8004210879:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  800421087d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210882:	75 22                	jne    80042108a6 <dwarf_search_die_within_cu+0x10f>
			if (level == 0 || !search_sibling) {
  8004210884:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210888:	74 09                	je     8004210893 <dwarf_search_die_within_cu+0xfc>
  800421088a:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004210891:	75 0a                	jne    800421089d <dwarf_search_die_within_cu+0x106>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  8004210893:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210898:	e9 d4 01 00 00       	jmpq   8004210a71 <dwarf_search_die_within_cu+0x2da>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  800421089d:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  80042108a1:	e9 9b 01 00 00       	jmpq   8004210a41 <dwarf_search_die_within_cu+0x2aa>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  80042108a6:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042108ad:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042108b1:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042108b8:	48 83 ec 08          	sub    $0x8,%rsp
  80042108bc:	ff 75 40             	pushq  0x40(%rbp)
  80042108bf:	ff 75 38             	pushq  0x38(%rbp)
  80042108c2:	ff 75 30             	pushq  0x30(%rbp)
  80042108c5:	ff 75 28             	pushq  0x28(%rbp)
  80042108c8:	ff 75 20             	pushq  0x20(%rbp)
  80042108cb:	ff 75 18             	pushq  0x18(%rbp)
  80042108ce:	ff 75 10             	pushq  0x10(%rbp)
  80042108d1:	48 89 ce             	mov    %rcx,%rsi
  80042108d4:	48 89 c7             	mov    %rax,%rdi
  80042108d7:	48 b8 f5 ff 20 04 80 	movabs $0x800420fff5,%rax
  80042108de:	00 00 00 
  80042108e1:	ff d0                	callq  *%rax
  80042108e3:	48 83 c4 40          	add    $0x40,%rsp
  80042108e7:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042108ea:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042108ee:	74 08                	je     80042108f8 <dwarf_search_die_within_cu+0x161>
			return (ret);
  80042108f0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042108f3:	e9 79 01 00 00       	jmpq   8004210a71 <dwarf_search_die_within_cu+0x2da>
		ret_die->die_offset = die_offset;
  80042108f8:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042108ff:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210903:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  8004210906:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421090d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210911:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  8004210915:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421091c:	48 8d 50 20          	lea    0x20(%rax),%rdx
  8004210920:	48 8d 85 b0 fc ff ff 	lea    -0x350(%rbp),%rax
  8004210927:	b9 66 00 00 00       	mov    $0x66,%ecx
  800421092c:	48 89 d7             	mov    %rdx,%rdi
  800421092f:	48 89 c6             	mov    %rax,%rsi
  8004210932:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  8004210935:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421093c:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  8004210943:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  800421094a:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210951:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004210955:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800421095c:	e9 91 00 00 00       	jmpq   80042109f2 <dwarf_search_die_within_cu+0x25b>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  8004210961:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004210964:	48 63 d0             	movslq %eax,%rdx
  8004210967:	48 89 d0             	mov    %rdx,%rax
  800421096a:	48 01 c0             	add    %rax,%rax
  800421096d:	48 01 d0             	add    %rdx,%rax
  8004210970:	48 c1 e0 03          	shl    $0x3,%rax
  8004210974:	48 01 e8             	add    %rbp,%rax
  8004210977:	48 2d 18 03 00 00    	sub    $0x318,%rax
  800421097d:	48 8b 08             	mov    (%rax),%rcx
  8004210980:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  8004210987:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421098a:	48 63 d0             	movslq %eax,%rdx
  800421098d:	48 89 d0             	mov    %rdx,%rax
  8004210990:	48 01 c0             	add    %rax,%rax
  8004210993:	48 01 d0             	add    %rdx,%rax
  8004210996:	48 c1 e0 03          	shl    $0x3,%rax
  800421099a:	48 83 c0 30          	add    $0x30,%rax
  800421099e:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  80042109a2:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  80042109a9:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  80042109b0:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042109b7:	48 83 ec 08          	sub    $0x8,%rsp
  80042109bb:	6a 00                	pushq  $0x0
  80042109bd:	49 89 c9             	mov    %rcx,%r9
  80042109c0:	49 89 f8             	mov    %rdi,%r8
  80042109c3:	48 89 d1             	mov    %rdx,%rcx
  80042109c6:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  80042109ca:	48 89 c7             	mov    %rax,%rdi
  80042109cd:	48 b8 ff 00 21 04 80 	movabs $0x80042100ff,%rax
  80042109d4:	00 00 00 
  80042109d7:	ff d0                	callq  *%rax
  80042109d9:	48 83 c4 10          	add    $0x10,%rsp
  80042109dd:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042109e0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042109e4:	74 08                	je     80042109ee <dwarf_search_die_within_cu+0x257>
				return (ret);
  80042109e6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042109e9:	e9 83 00 00 00       	jmpq   8004210a71 <dwarf_search_die_within_cu+0x2da>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  80042109ee:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  80042109f2:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042109f5:	48 63 d0             	movslq %eax,%rdx
  80042109f8:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  80042109ff:	48 39 c2             	cmp    %rax,%rdx
  8004210a02:	0f 82 59 ff ff ff    	jb     8004210961 <dwarf_search_die_within_cu+0x1ca>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  8004210a08:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004210a0f:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210a16:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  8004210a1a:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  8004210a21:	74 17                	je     8004210a3a <dwarf_search_die_within_cu+0x2a3>
  8004210a23:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210a27:	7e 11                	jle    8004210a3a <dwarf_search_die_within_cu+0x2a3>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004210a29:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004210a30:	3c 01                	cmp    $0x1,%al
  8004210a32:	75 0d                	jne    8004210a41 <dwarf_search_die_within_cu+0x2aa>
				/* Advance to next DIE level. */
				level++;
  8004210a34:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004210a38:	eb 07                	jmp    8004210a41 <dwarf_search_die_within_cu+0x2aa>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  8004210a3a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210a3f:	eb 30                	jmp    8004210a71 <dwarf_search_die_within_cu+0x2da>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004210a41:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004210a45:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004210a4c:	48 39 c2             	cmp    %rax,%rdx
  8004210a4f:	76 1b                	jbe    8004210a6c <dwarf_search_die_within_cu+0x2d5>
  8004210a51:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210a58:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210a5c:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004210a63:	48 39 c2             	cmp    %rax,%rdx
  8004210a66:	0f 87 db fd ff ff    	ja     8004210847 <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  8004210a6c:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004210a71:	c9                   	leaveq 
  8004210a72:	c3                   	retq   

0000008004210a73 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  8004210a73:	55                   	push   %rbp
  8004210a74:	48 89 e5             	mov    %rsp,%rbp
  8004210a77:	48 83 ec 30          	sub    $0x30,%rsp
  8004210a7b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210a7f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210a83:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  8004210a87:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210a8c:	75 35                	jne    8004210ac3 <dwarf_offdie+0x50>
  8004210a8e:	48 b9 38 85 21 04 80 	movabs $0x8004218538,%rcx
  8004210a95:	00 00 00 
  8004210a98:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  8004210a9f:	00 00 00 
  8004210aa2:	be c4 02 00 00       	mov    $0x2c4,%esi
  8004210aa7:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  8004210aae:	00 00 00 
  8004210ab1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ab6:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210abd:	00 00 00 
  8004210ac0:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004210ac3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210ac8:	75 35                	jne    8004210aff <dwarf_offdie+0x8c>
  8004210aca:	48 b9 3c 85 21 04 80 	movabs $0x800421853c,%rcx
  8004210ad1:	00 00 00 
  8004210ad4:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  8004210adb:	00 00 00 
  8004210ade:	be c5 02 00 00       	mov    $0x2c5,%esi
  8004210ae3:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  8004210aea:	00 00 00 
  8004210aed:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210af2:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210af9:	00 00 00 
  8004210afc:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004210aff:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004210b03:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210b07:	76 45                	jbe    8004210b4e <dwarf_offdie+0xdb>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  8004210b09:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004210b0d:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004210b11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210b15:	48 83 ec 08          	sub    $0x8,%rsp
  8004210b19:	ff 75 40             	pushq  0x40(%rbp)
  8004210b1c:	ff 75 38             	pushq  0x38(%rbp)
  8004210b1f:	ff 75 30             	pushq  0x30(%rbp)
  8004210b22:	ff 75 28             	pushq  0x28(%rbp)
  8004210b25:	ff 75 20             	pushq  0x20(%rbp)
  8004210b28:	ff 75 18             	pushq  0x18(%rbp)
  8004210b2b:	ff 75 10             	pushq  0x10(%rbp)
  8004210b2e:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004210b33:	48 89 c7             	mov    %rax,%rdi
  8004210b36:	48 b8 97 07 21 04 80 	movabs $0x8004210797,%rax
  8004210b3d:	00 00 00 
  8004210b40:	ff d0                	callq  *%rax
  8004210b42:	48 83 c4 40          	add    $0x40,%rsp
  8004210b46:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  8004210b49:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210b4c:	eb 05                	jmp    8004210b53 <dwarf_offdie+0xe0>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  8004210b4e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210b53:	c9                   	leaveq 
  8004210b54:	c3                   	retq   

0000008004210b55 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  8004210b55:	55                   	push   %rbp
  8004210b56:	48 89 e5             	mov    %rsp,%rbp
  8004210b59:	48 83 ec 20          	sub    $0x20,%rsp
  8004210b5d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210b61:	89 f0                	mov    %esi,%eax
  8004210b63:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  8004210b67:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210b6e:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004210b6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004210b76:	eb 57                	jmp    8004210bcf <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  8004210b78:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210b7c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210b7f:	48 63 d0             	movslq %eax,%rdx
  8004210b82:	48 89 d0             	mov    %rdx,%rax
  8004210b85:	48 01 c0             	add    %rax,%rax
  8004210b88:	48 01 d0             	add    %rdx,%rax
  8004210b8b:	48 c1 e0 05          	shl    $0x5,%rax
  8004210b8f:	48 01 c8             	add    %rcx,%rax
  8004210b92:	48 05 80 03 00 00    	add    $0x380,%rax
  8004210b98:	48 8b 10             	mov    (%rax),%rdx
  8004210b9b:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004210b9f:	48 39 c2             	cmp    %rax,%rdx
  8004210ba2:	75 27                	jne    8004210bcb <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  8004210ba4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210ba7:	48 63 d0             	movslq %eax,%rdx
  8004210baa:	48 89 d0             	mov    %rdx,%rax
  8004210bad:	48 01 c0             	add    %rax,%rax
  8004210bb0:	48 01 d0             	add    %rdx,%rax
  8004210bb3:	48 c1 e0 05          	shl    $0x5,%rax
  8004210bb7:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004210bbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210bc2:	48 01 d0             	add    %rdx,%rax
  8004210bc5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004210bc9:	eb 17                	jmp    8004210be2 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004210bcb:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004210bcf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210bd3:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004210bda:	0f b6 c0             	movzbl %al,%eax
  8004210bdd:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004210be0:	7f 96                	jg     8004210b78 <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004210be2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210be6:	c9                   	leaveq 
  8004210be7:	c3                   	retq   

0000008004210be8 <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  8004210be8:	55                   	push   %rbp
  8004210be9:	48 89 e5             	mov    %rsp,%rbp
  8004210bec:	48 83 ec 40          	sub    $0x40,%rsp
  8004210bf0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210bf4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210bf8:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004210bfc:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004210c00:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210c05:	75 35                	jne    8004210c3c <dwarf_siblingof+0x54>
  8004210c07:	48 b9 38 85 21 04 80 	movabs $0x8004218538,%rcx
  8004210c0e:	00 00 00 
  8004210c11:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  8004210c18:	00 00 00 
  8004210c1b:	be ec 02 00 00       	mov    $0x2ec,%esi
  8004210c20:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  8004210c27:	00 00 00 
  8004210c2a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c2f:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210c36:	00 00 00 
  8004210c39:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004210c3c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210c41:	75 35                	jne    8004210c78 <dwarf_siblingof+0x90>
  8004210c43:	48 b9 3c 85 21 04 80 	movabs $0x800421853c,%rcx
  8004210c4a:	00 00 00 
  8004210c4d:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  8004210c54:	00 00 00 
  8004210c57:	be ed 02 00 00       	mov    $0x2ed,%esi
  8004210c5c:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  8004210c63:	00 00 00 
  8004210c66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c6b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210c72:	00 00 00 
  8004210c75:	41 ff d0             	callq  *%r8
	assert(cu);
  8004210c78:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004210c7d:	75 35                	jne    8004210cb4 <dwarf_siblingof+0xcc>
  8004210c7f:	48 b9 44 85 21 04 80 	movabs $0x8004218544,%rcx
  8004210c86:	00 00 00 
  8004210c89:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  8004210c90:	00 00 00 
  8004210c93:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004210c98:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  8004210c9f:	00 00 00 
  8004210ca2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ca7:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210cae:	00 00 00 
  8004210cb1:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004210cb4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210cb9:	75 44                	jne    8004210cff <dwarf_siblingof+0x117>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004210cbb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210cbf:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004210cc3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210cc7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004210ccb:	48 83 ec 08          	sub    $0x8,%rsp
  8004210ccf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210cd3:	ff 70 30             	pushq  0x30(%rax)
  8004210cd6:	ff 70 28             	pushq  0x28(%rax)
  8004210cd9:	ff 70 20             	pushq  0x20(%rax)
  8004210cdc:	ff 70 18             	pushq  0x18(%rax)
  8004210cdf:	ff 70 10             	pushq  0x10(%rax)
  8004210ce2:	ff 70 08             	pushq  0x8(%rax)
  8004210ce5:	ff 30                	pushq  (%rax)
  8004210ce7:	48 89 cf             	mov    %rcx,%rdi
  8004210cea:	48 b8 73 0a 21 04 80 	movabs $0x8004210a73,%rax
  8004210cf1:	00 00 00 
  8004210cf4:	ff d0                	callq  *%rax
  8004210cf6:	48 83 c4 40          	add    $0x40,%rsp
  8004210cfa:	e9 e9 00 00 00       	jmpq   8004210de8 <dwarf_siblingof+0x200>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004210cff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004210d06:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210d0a:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004210d0e:	84 c0                	test   %al,%al
  8004210d10:	75 0e                	jne    8004210d20 <dwarf_siblingof+0x138>
		offset = die->die_next_off;
  8004210d12:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210d16:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210d1a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210d1e:	eb 6b                	jmp    8004210d8b <dwarf_siblingof+0x1a3>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004210d20:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210d24:	be 01 00 00 00       	mov    $0x1,%esi
  8004210d29:	48 89 c7             	mov    %rax,%rdi
  8004210d2c:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  8004210d33:	00 00 00 
  8004210d36:	ff d0                	callq  *%rax
  8004210d38:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004210d3c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210d41:	74 35                	je     8004210d78 <dwarf_siblingof+0x190>
			if (at->at_form != DW_FORM_ref_addr)
  8004210d43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d47:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210d4b:	48 83 f8 10          	cmp    $0x10,%rax
  8004210d4f:	74 19                	je     8004210d6a <dwarf_siblingof+0x182>
				offset = at->u[0].u64 + cu->cu_offset;
  8004210d51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d55:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210d59:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210d5d:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210d61:	48 01 d0             	add    %rdx,%rax
  8004210d64:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210d68:	eb 21                	jmp    8004210d8b <dwarf_siblingof+0x1a3>
			else
				offset = at->u[0].u64;
  8004210d6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d6e:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210d72:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210d76:	eb 13                	jmp    8004210d8b <dwarf_siblingof+0x1a3>
		} else {
			offset = die->die_next_off;
  8004210d78:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210d7c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210d80:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004210d84:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004210d8b:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004210d8e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210d92:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004210d96:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004210d9a:	48 83 ec 08          	sub    $0x8,%rsp
  8004210d9e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210da2:	ff 70 30             	pushq  0x30(%rax)
  8004210da5:	ff 70 28             	pushq  0x28(%rax)
  8004210da8:	ff 70 20             	pushq  0x20(%rax)
  8004210dab:	ff 70 18             	pushq  0x18(%rax)
  8004210dae:	ff 70 10             	pushq  0x10(%rax)
  8004210db1:	ff 70 08             	pushq  0x8(%rax)
  8004210db4:	ff 30                	pushq  (%rax)
  8004210db6:	48 b8 97 07 21 04 80 	movabs $0x8004210797,%rax
  8004210dbd:	00 00 00 
  8004210dc0:	ff d0                	callq  *%rax
  8004210dc2:	48 83 c4 40          	add    $0x40,%rsp
  8004210dc6:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  8004210dc9:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004210dcd:	75 07                	jne    8004210dd6 <dwarf_siblingof+0x1ee>
		return (DW_DLV_NO_ENTRY);
  8004210dcf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210dd4:	eb 12                	jmp    8004210de8 <dwarf_siblingof+0x200>
	} else if (ret != DW_DLE_NONE)
  8004210dd6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210dda:	74 07                	je     8004210de3 <dwarf_siblingof+0x1fb>
		return (DW_DLV_ERROR);
  8004210ddc:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210de1:	eb 05                	jmp    8004210de8 <dwarf_siblingof+0x200>


	return (DW_DLV_OK);
  8004210de3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210de8:	c9                   	leaveq 
  8004210de9:	c3                   	retq   

0000008004210dea <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  8004210dea:	55                   	push   %rbp
  8004210deb:	48 89 e5             	mov    %rsp,%rbp
  8004210dee:	48 83 ec 30          	sub    $0x30,%rsp
  8004210df2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210df6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210dfa:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004210dfe:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  8004210e02:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210e07:	75 35                	jne    8004210e3e <dwarf_child+0x54>
  8004210e09:	48 b9 47 85 21 04 80 	movabs $0x8004218547,%rcx
  8004210e10:	00 00 00 
  8004210e13:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  8004210e1a:	00 00 00 
  8004210e1d:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004210e22:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  8004210e29:	00 00 00 
  8004210e2c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e31:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210e38:	00 00 00 
  8004210e3b:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004210e3e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210e43:	75 35                	jne    8004210e7a <dwarf_child+0x90>
  8004210e45:	48 b9 3c 85 21 04 80 	movabs $0x800421853c,%rcx
  8004210e4c:	00 00 00 
  8004210e4f:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  8004210e56:	00 00 00 
  8004210e59:	be 1d 03 00 00       	mov    $0x31d,%esi
  8004210e5e:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  8004210e65:	00 00 00 
  8004210e68:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e6d:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210e74:	00 00 00 
  8004210e77:	41 ff d0             	callq  *%r8
	assert(dbg);
  8004210e7a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210e7f:	75 35                	jne    8004210eb6 <dwarf_child+0xcc>
  8004210e81:	48 b9 38 85 21 04 80 	movabs $0x8004218538,%rcx
  8004210e88:	00 00 00 
  8004210e8b:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  8004210e92:	00 00 00 
  8004210e95:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004210e9a:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  8004210ea1:	00 00 00 
  8004210ea4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ea9:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210eb0:	00 00 00 
  8004210eb3:	41 ff d0             	callq  *%r8
	assert(cu);
  8004210eb6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004210ebb:	75 35                	jne    8004210ef2 <dwarf_child+0x108>
  8004210ebd:	48 b9 44 85 21 04 80 	movabs $0x8004218544,%rcx
  8004210ec4:	00 00 00 
  8004210ec7:	48 ba aa 83 21 04 80 	movabs $0x80042183aa,%rdx
  8004210ece:	00 00 00 
  8004210ed1:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004210ed6:	48 bf bf 83 21 04 80 	movabs $0x80042183bf,%rdi
  8004210edd:	00 00 00 
  8004210ee0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ee5:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004210eec:	00 00 00 
  8004210eef:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004210ef2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210ef6:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004210efa:	84 c0                	test   %al,%al
  8004210efc:	75 07                	jne    8004210f05 <dwarf_child+0x11b>
		return (DW_DLE_NO_ENTRY);
  8004210efe:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210f03:	eb 63                	jmp    8004210f68 <dwarf_child+0x17e>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004210f05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f09:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004210f0d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004210f11:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004210f15:	48 83 ec 08          	sub    $0x8,%rsp
  8004210f19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210f1d:	ff 70 30             	pushq  0x30(%rax)
  8004210f20:	ff 70 28             	pushq  0x28(%rax)
  8004210f23:	ff 70 20             	pushq  0x20(%rax)
  8004210f26:	ff 70 18             	pushq  0x18(%rax)
  8004210f29:	ff 70 10             	pushq  0x10(%rax)
  8004210f2c:	ff 70 08             	pushq  0x8(%rax)
  8004210f2f:	ff 30                	pushq  (%rax)
  8004210f31:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004210f36:	48 b8 97 07 21 04 80 	movabs $0x8004210797,%rax
  8004210f3d:	00 00 00 
  8004210f40:	ff d0                	callq  *%rax
  8004210f42:	48 83 c4 40          	add    $0x40,%rsp
  8004210f46:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  8004210f49:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004210f4d:	75 07                	jne    8004210f56 <dwarf_child+0x16c>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004210f4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210f54:	eb 12                	jmp    8004210f68 <dwarf_child+0x17e>
	} else if (ret != DW_DLE_NONE)
  8004210f56:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210f5a:	74 07                	je     8004210f63 <dwarf_child+0x179>
		return (DW_DLV_ERROR);
  8004210f5c:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210f61:	eb 05                	jmp    8004210f68 <dwarf_child+0x17e>

	return (DW_DLV_OK);
  8004210f63:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210f68:	c9                   	leaveq 
  8004210f69:	c3                   	retq   

0000008004210f6a <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004210f6a:	55                   	push   %rbp
  8004210f6b:	48 89 e5             	mov    %rsp,%rbp
  8004210f6e:	48 83 ec 20          	sub    $0x20,%rsp
  8004210f72:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004210f76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f7a:	48 8b 00             	mov    (%rax),%rax
  8004210f7d:	48 89 c7             	mov    %rax,%rdi
  8004210f80:	48 b8 88 42 21 04 80 	movabs $0x8004214288,%rax
  8004210f87:	00 00 00 
  8004210f8a:	ff d0                	callq  *%rax
  8004210f8c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004210f90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210f94:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004210f98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f9c:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  8004210fa0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210fa4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210fa8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210fac:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  8004210fb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210fb4:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210fb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210fbc:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  8004210fc0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210fc5:	c9                   	leaveq 
  8004210fc6:	c3                   	retq   

0000008004210fc7 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004210fc7:	55                   	push   %rbp
  8004210fc8:	48 89 e5             	mov    %rsp,%rbp
  8004210fcb:	48 83 ec 08          	sub    $0x8,%rsp
  8004210fcf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	/* Initialise call frame related parameters. */
	dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004210fd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210fd7:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
	dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004210fdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210fe1:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
	dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004210fe7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210feb:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
	dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004210ff1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ff5:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
	dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004210ffb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210fff:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004211005:	90                   	nop
  8004211006:	c9                   	leaveq 
  8004211007:	c3                   	retq   

0000008004211008 <dwarf_get_fde_at_pc>:

int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie,
		    Dwarf_Error *error)
{
  8004211008:	55                   	push   %rbp
  8004211009:	48 89 e5             	mov    %rsp,%rbp
  800421100c:	48 83 ec 40          	sub    $0x40,%rsp
  8004211010:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211014:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211018:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421101c:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004211020:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	Dwarf_Fde fde = ret_fde;
  8004211024:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211028:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  800421102c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211030:	ba 80 00 00 00       	mov    $0x80,%edx
  8004211035:	be 00 00 00 00       	mov    $0x0,%esi
  800421103a:	48 89 c7             	mov    %rax,%rdi
  800421103d:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004211044:	00 00 00 
  8004211047:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  8004211049:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421104d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211051:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
	if (ret_fde == NULL)
  8004211055:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421105a:	75 60                	jne    80042110bc <dwarf_get_fde_at_pc+0xb4>
		return (DW_DLV_ERROR);
  800421105c:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211061:	eb 73                	jmp    80042110d6 <dwarf_get_fde_at_pc+0xce>

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  8004211063:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004211067:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421106b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421106f:	be 01 00 00 00       	mov    $0x1,%esi
  8004211074:	48 89 c7             	mov    %rax,%rdi
  8004211077:	48 b8 78 32 21 04 80 	movabs $0x8004213278,%rax
  800421107e:	00 00 00 
  8004211081:	ff d0                	callq  *%rax
  8004211083:	85 c0                	test   %eax,%eax
  8004211085:	79 07                	jns    800421108e <dwarf_get_fde_at_pc+0x86>
		{
			return DW_DLV_NO_ENTRY;
  8004211087:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421108c:	eb 48                	jmp    80042110d6 <dwarf_get_fde_at_pc+0xce>
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  800421108e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211092:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211096:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421109a:	77 20                	ja     80042110bc <dwarf_get_fde_at_pc+0xb4>
  800421109c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110a0:	48 8b 50 30          	mov    0x30(%rax),%rdx
		    fde->fde_adrange)
  80042110a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042110a8:	48 8b 40 38          	mov    0x38(%rax),%rax
	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
		if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
		if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  80042110ac:	48 01 d0             	add    %rdx,%rax
  80042110af:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042110b3:	76 07                	jbe    80042110bc <dwarf_get_fde_at_pc+0xb4>
		    fde->fde_adrange)
			return (DW_DLV_OK);
  80042110b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042110ba:	eb 1a                	jmp    80042110d6 <dwarf_get_fde_at_pc+0xce>
	fde->fde_cie = cie;
	
	if (ret_fde == NULL)
		return (DW_DLV_ERROR);

	while(dbg->curr_off_eh < dbg->dbg_eh_size) {
  80042110bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042110c0:	48 8b 50 30          	mov    0x30(%rax),%rdx
  80042110c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042110c8:	48 8b 40 40          	mov    0x40(%rax),%rax
  80042110cc:	48 39 c2             	cmp    %rax,%rdx
  80042110cf:	72 92                	jb     8004211063 <dwarf_get_fde_at_pc+0x5b>
		    fde->fde_adrange)
			return (DW_DLV_OK);
	}

	DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
	return (DW_DLV_NO_ENTRY);
  80042110d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80042110d6:	c9                   	leaveq 
  80042110d7:	c3                   	retq   

00000080042110d8 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  80042110d8:	55                   	push   %rbp
  80042110d9:	48 89 e5             	mov    %rsp,%rbp
  80042110dc:	48 83 ec 30          	sub    $0x30,%rsp
  80042110e0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042110e4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042110e8:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042110ec:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int i;

	assert(dest != NULL);
  80042110f0:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042110f5:	75 35                	jne    800421112c <_dwarf_frame_regtable_copy+0x54>
  80042110f7:	48 b9 5a 85 21 04 80 	movabs $0x800421855a,%rcx
  80042110fe:	00 00 00 
  8004211101:	48 ba 67 85 21 04 80 	movabs $0x8004218567,%rdx
  8004211108:	00 00 00 
  800421110b:	be 57 00 00 00       	mov    $0x57,%esi
  8004211110:	48 bf 7c 85 21 04 80 	movabs $0x800421857c,%rdi
  8004211117:	00 00 00 
  800421111a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421111f:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004211126:	00 00 00 
  8004211129:	41 ff d0             	callq  *%r8
	assert(src != NULL);
  800421112c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211131:	75 35                	jne    8004211168 <_dwarf_frame_regtable_copy+0x90>
  8004211133:	48 b9 92 85 21 04 80 	movabs $0x8004218592,%rcx
  800421113a:	00 00 00 
  800421113d:	48 ba 67 85 21 04 80 	movabs $0x8004218567,%rdx
  8004211144:	00 00 00 
  8004211147:	be 58 00 00 00       	mov    $0x58,%esi
  800421114c:	48 bf 7c 85 21 04 80 	movabs $0x800421857c,%rdi
  8004211153:	00 00 00 
  8004211156:	b8 00 00 00 00       	mov    $0x0,%eax
  800421115b:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004211162:	00 00 00 
  8004211165:	41 ff d0             	callq  *%r8

	if (*dest == NULL) {
  8004211168:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421116c:	48 8b 00             	mov    (%rax),%rax
  800421116f:	48 85 c0             	test   %rax,%rax
  8004211172:	75 39                	jne    80042111ad <_dwarf_frame_regtable_copy+0xd5>
		*dest = &global_rt_table_shadow;
  8004211174:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211178:	48 bf e0 36 36 04 80 	movabs $0x80043636e0,%rdi
  800421117f:	00 00 00 
  8004211182:	48 89 38             	mov    %rdi,(%rax)
		(*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  8004211185:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211189:	48 8b 00             	mov    (%rax),%rax
  800421118c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211190:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  8004211194:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  8004211198:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421119c:	48 8b 00             	mov    (%rax),%rax
  800421119f:	48 be 20 39 36 04 80 	movabs $0x8004363920,%rsi
  80042111a6:	00 00 00 
  80042111a9:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  80042111ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042111b1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042111b5:	48 8b 12             	mov    (%rdx),%rdx
  80042111b8:	48 89 d1             	mov    %rdx,%rcx
  80042111bb:	ba 18 00 00 00       	mov    $0x18,%edx
  80042111c0:	48 89 c6             	mov    %rax,%rsi
  80042111c3:	48 89 cf             	mov    %rcx,%rdi
  80042111c6:	48 b8 19 ee 20 04 80 	movabs $0x800420ee19,%rax
  80042111cd:	00 00 00 
  80042111d0:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042111d2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042111d9:	eb 5a                	jmp    8004211235 <_dwarf_frame_regtable_copy+0x15d>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  80042111db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042111df:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042111e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042111e6:	48 63 d0             	movslq %eax,%rdx
  80042111e9:	48 89 d0             	mov    %rdx,%rax
  80042111ec:	48 01 c0             	add    %rax,%rax
  80042111ef:	48 01 d0             	add    %rdx,%rax
  80042111f2:	48 c1 e0 03          	shl    $0x3,%rax
  80042111f6:	48 01 c1             	add    %rax,%rcx
  80042111f9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042111fd:	48 8b 00             	mov    (%rax),%rax
  8004211200:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211204:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004211207:	48 63 d0             	movslq %eax,%rdx
  800421120a:	48 89 d0             	mov    %rdx,%rax
  800421120d:	48 01 c0             	add    %rax,%rax
  8004211210:	48 01 d0             	add    %rdx,%rax
  8004211213:	48 c1 e0 03          	shl    $0x3,%rax
  8004211217:	48 01 f0             	add    %rsi,%rax
  800421121a:	ba 18 00 00 00       	mov    $0x18,%edx
  800421121f:	48 89 ce             	mov    %rcx,%rsi
  8004211222:	48 89 c7             	mov    %rax,%rdi
  8004211225:	48 b8 19 ee 20 04 80 	movabs $0x800420ee19,%rax
  800421122c:	00 00 00 
  800421122f:	ff d0                	callq  *%rax

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  8004211231:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004211235:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211239:	48 8b 00             	mov    (%rax),%rax
  800421123c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211240:	0f b7 c0             	movzwl %ax,%eax
  8004211243:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004211246:	7e 44                	jle    800421128c <_dwarf_frame_regtable_copy+0x1b4>
		     i < src->rt3_reg_table_size; i++)
  8004211248:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421124c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211250:	0f b7 c0             	movzwl %ax,%eax
	}

	memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

	for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004211253:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004211256:	7f 83                	jg     80042111db <_dwarf_frame_regtable_copy+0x103>
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  8004211258:	eb 32                	jmp    800421128c <_dwarf_frame_regtable_copy+0x1b4>
		(*dest)->rt3_rules[i].dw_regnum =
  800421125a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421125e:	48 8b 00             	mov    (%rax),%rax
  8004211261:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211265:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004211268:	48 63 d0             	movslq %eax,%rdx
  800421126b:	48 89 d0             	mov    %rdx,%rax
  800421126e:	48 01 c0             	add    %rax,%rax
  8004211271:	48 01 d0             	add    %rdx,%rax
  8004211274:	48 c1 e0 03          	shl    $0x3,%rax
  8004211278:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  800421127c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211280:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
		(*dest)->rt3_rules[i].dw_regnum =
  8004211284:	66 89 42 02          	mov    %ax,0x2(%rdx)
	for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
		memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

	for (; i < (*dest)->rt3_reg_table_size; i++)
  8004211288:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421128c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211290:	48 8b 00             	mov    (%rax),%rax
  8004211293:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211297:	0f b7 c0             	movzwl %ax,%eax
  800421129a:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421129d:	7f bb                	jg     800421125a <_dwarf_frame_regtable_copy+0x182>
		(*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

	return (DW_DLE_NONE);
  800421129f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042112a4:	c9                   	leaveq 
  80042112a5:	c3                   	retq   

00000080042112a6 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  80042112a6:	55                   	push   %rbp
  80042112a7:	48 89 e5             	mov    %rsp,%rbp
  80042112aa:	53                   	push   %rbx
  80042112ab:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  80042112b2:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042112b6:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042112ba:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  80042112be:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  80042112c2:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  80042112c9:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
			ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
			goto program_done;                              \
		}                                                       \
	} while(0)

	ret = DW_DLE_NONE;
  80042112d0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	init_rt = saved_rt = NULL;
  80042112d7:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80042112de:	00 
  80042112df:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042112e3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	*row_pc = pc;
  80042112e7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042112eb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042112ef:	48 89 10             	mov    %rdx,(%rax)

	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  80042112f2:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042112f6:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042112fa:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  80042112fe:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211302:	48 89 c7             	mov    %rax,%rdi
  8004211305:	48 b8 d8 10 21 04 80 	movabs $0x80042110d8,%rax
  800421130c:	00 00 00 
  800421130f:	ff d0                	callq  *%rax
	p = insts;
  8004211311:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004211315:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	pe = p + len;
  8004211319:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421131d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004211321:	48 01 d0             	add    %rdx,%rax
  8004211324:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	while (p < pe) {
  8004211328:	e9 38 0d 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		if (*p == DW_CFA_nop) {
  800421132d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211331:	0f b6 00             	movzbl (%rax),%eax
  8004211334:	84 c0                	test   %al,%al
  8004211336:	75 11                	jne    8004211349 <_dwarf_frame_run_inst+0xa3>
			p++;
  8004211338:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421133c:	48 83 c0 01          	add    $0x1,%rax
  8004211340:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			continue;
  8004211344:	e9 1c 0d 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		}

		high2 = *p & 0xc0;
  8004211349:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421134d:	0f b6 00             	movzbl (%rax),%eax
  8004211350:	83 e0 c0             	and    $0xffffffc0,%eax
  8004211353:	88 45 df             	mov    %al,-0x21(%rbp)
		low6 = *p & 0x3f;
  8004211356:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421135a:	0f b6 00             	movzbl (%rax),%eax
  800421135d:	83 e0 3f             	and    $0x3f,%eax
  8004211360:	88 45 de             	mov    %al,-0x22(%rbp)
		p++;
  8004211363:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211367:	48 83 c0 01          	add    $0x1,%rax
  800421136b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

		if (high2 > 0) {
  800421136f:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004211373:	0f 84 a4 01 00 00    	je     800421151d <_dwarf_frame_run_inst+0x277>
			switch (high2) {
  8004211379:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800421137d:	3d 80 00 00 00       	cmp    $0x80,%eax
  8004211382:	74 37                	je     80042113bb <_dwarf_frame_run_inst+0x115>
  8004211384:	3d c0 00 00 00       	cmp    $0xc0,%eax
  8004211389:	0f 84 03 01 00 00    	je     8004211492 <_dwarf_frame_run_inst+0x1ec>
  800421138f:	83 f8 40             	cmp    $0x40,%eax
  8004211392:	0f 85 73 01 00 00    	jne    800421150b <_dwarf_frame_run_inst+0x265>
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
  8004211398:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800421139c:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042113a3:	ff 
  80042113a4:	48 01 45 10          	add    %rax,0x10(%rbp)
			        if (pc_req < pc)
  80042113a8:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042113ac:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042113b0:	0f 83 61 01 00 00    	jae    8004211517 <_dwarf_frame_run_inst+0x271>
			                goto program_done;
  80042113b6:	e9 c4 0c 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			        break;
			case DW_CFA_offset:
			        *row_pc = pc;
  80042113bb:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042113bf:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042113c3:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  80042113c6:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042113ca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042113ce:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042113d2:	66 39 c2             	cmp    %ax,%dx
  80042113d5:	72 0c                	jb     80042113e3 <_dwarf_frame_run_inst+0x13d>
  80042113d7:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042113de:	e9 9c 0c 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			        RL[low6].dw_offset_relevant = 1;
  80042113e3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042113e7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042113eb:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042113ef:	48 89 d0             	mov    %rdx,%rax
  80042113f2:	48 01 c0             	add    %rax,%rax
  80042113f5:	48 01 d0             	add    %rdx,%rax
  80042113f8:	48 c1 e0 03          	shl    $0x3,%rax
  80042113fc:	48 01 c8             	add    %rcx,%rax
  80042113ff:	c6 00 01             	movb   $0x1,(%rax)
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
  8004211402:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211406:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421140a:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421140e:	48 89 d0             	mov    %rdx,%rax
  8004211411:	48 01 c0             	add    %rax,%rax
  8004211414:	48 01 d0             	add    %rdx,%rax
  8004211417:	48 c1 e0 03          	shl    $0x3,%rax
  800421141b:	48 01 c8             	add    %rcx,%rax
  800421141e:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211422:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211426:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421142a:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421142e:	48 89 d0             	mov    %rdx,%rax
  8004211431:	48 01 c0             	add    %rax,%rax
  8004211434:	48 01 d0             	add    %rdx,%rax
  8004211437:	48 c1 e0 03          	shl    $0x3,%rax
  800421143b:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421143f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211443:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211447:	66 89 42 02          	mov    %ax,0x2(%rdx)
			        RL[low6].dw_offset_or_block_len =
  800421144b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421144f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211453:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211457:	48 89 d0             	mov    %rdx,%rax
  800421145a:	48 01 c0             	add    %rax,%rax
  800421145d:	48 01 d0             	add    %rdx,%rax
  8004211460:	48 c1 e0 03          	shl    $0x3,%rax
  8004211464:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  8004211468:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421146c:	48 89 c7             	mov    %rax,%rdi
  800421146f:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211476:	00 00 00 
  8004211479:	ff d0                	callq  *%rax
  800421147b:	48 89 c2             	mov    %rax,%rdx
  800421147e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211485:	48 0f af c2          	imul   %rdx,%rax
			        *row_pc = pc;
			        CHECK_TABLE_SIZE(low6);
			        RL[low6].dw_offset_relevant = 1;
			        RL[low6].dw_value_type = DW_EXPR_OFFSET;
			        RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
			        RL[low6].dw_offset_or_block_len =
  8004211489:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
			        break;
  800421148d:	e9 86 00 00 00       	jmpq   8004211518 <_dwarf_frame_run_inst+0x272>
			case DW_CFA_restore:
			        *row_pc = pc;
  8004211492:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211496:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421149a:	48 89 10             	mov    %rdx,(%rax)
			        CHECK_TABLE_SIZE(low6);
  800421149d:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042114a1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042114a5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042114a9:	66 39 c2             	cmp    %ax,%dx
  80042114ac:	72 0c                	jb     80042114ba <_dwarf_frame_run_inst+0x214>
  80042114ae:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042114b5:	e9 c5 0b 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			        memcpy(&RL[low6], &INITRL[low6],
  80042114ba:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042114be:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042114c2:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042114c6:	48 89 d0             	mov    %rdx,%rax
  80042114c9:	48 01 c0             	add    %rax,%rax
  80042114cc:	48 01 d0             	add    %rdx,%rax
  80042114cf:	48 c1 e0 03          	shl    $0x3,%rax
  80042114d3:	48 01 c1             	add    %rax,%rcx
  80042114d6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042114da:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042114de:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042114e2:	48 89 d0             	mov    %rdx,%rax
  80042114e5:	48 01 c0             	add    %rax,%rax
  80042114e8:	48 01 d0             	add    %rdx,%rax
  80042114eb:	48 c1 e0 03          	shl    $0x3,%rax
  80042114ef:	48 01 f0             	add    %rsi,%rax
  80042114f2:	ba 18 00 00 00       	mov    $0x18,%edx
  80042114f7:	48 89 ce             	mov    %rcx,%rsi
  80042114fa:	48 89 c7             	mov    %rax,%rdi
  80042114fd:	48 b8 19 ee 20 04 80 	movabs $0x800420ee19,%rax
  8004211504:	00 00 00 
  8004211507:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
			        break;
  8004211509:	eb 0d                	jmp    8004211518 <_dwarf_frame_run_inst+0x272>
			default:
			        DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800421150b:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			        goto program_done;
  8004211512:	e9 68 0b 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			switch (high2) {
			case DW_CFA_advance_loc:
			        pc += low6 * caf;
			        if (pc_req < pc)
			                goto program_done;
			        break;
  8004211517:	90                   	nop
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
			        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
			        goto program_done;
			}

			continue;
  8004211518:	e9 48 0b 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		}

		switch (low6) {
  800421151d:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004211521:	83 f8 16             	cmp    $0x16,%eax
  8004211524:	0f 87 32 0b 00 00    	ja     800421205c <_dwarf_frame_run_inst+0xdb6>
  800421152a:	89 c0                	mov    %eax,%eax
  800421152c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004211533:	00 
  8004211534:	48 b8 a0 85 21 04 80 	movabs $0x80042185a0,%rax
  800421153b:	00 00 00 
  800421153e:	48 01 d0             	add    %rdx,%rax
  8004211541:	48 8b 00             	mov    (%rax),%rax
  8004211544:	ff e0                	jmpq   *%rax
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
  8004211546:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421154a:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421154e:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211552:	8b 4a 28             	mov    0x28(%rdx),%ecx
  8004211555:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004211559:	89 ce                	mov    %ecx,%esi
  800421155b:	48 89 d7             	mov    %rdx,%rdi
  800421155e:	ff d0                	callq  *%rax
  8004211560:	48 89 45 10          	mov    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004211564:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004211568:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421156c:	0f 82 03 0b 00 00    	jb     8004212075 <_dwarf_frame_run_inst+0xdcf>
			        goto program_done;
			break;
  8004211572:	e9 ee 0a 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
  8004211577:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421157b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421157f:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004211583:	be 01 00 00 00       	mov    $0x1,%esi
  8004211588:	48 89 d7             	mov    %rdx,%rdi
  800421158b:	ff d0                	callq  *%rax
  800421158d:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211594:	ff 
  8004211595:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004211599:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421159d:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042115a1:	0f 82 d1 0a 00 00    	jb     8004212078 <_dwarf_frame_run_inst+0xdd2>
			        goto program_done;
			break;
  80042115a7:	e9 b9 0a 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
  80042115ac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042115b0:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042115b4:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042115b8:	be 02 00 00 00       	mov    $0x2,%esi
  80042115bd:	48 89 d7             	mov    %rdx,%rdi
  80042115c0:	ff d0                	callq  *%rax
  80042115c2:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042115c9:	ff 
  80042115ca:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  80042115ce:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042115d2:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042115d6:	0f 82 9f 0a 00 00    	jb     800421207b <_dwarf_frame_run_inst+0xdd5>
			        goto program_done;
			break;
  80042115dc:	e9 84 0a 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
  80042115e1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042115e5:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042115e9:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042115ed:	be 04 00 00 00       	mov    $0x4,%esi
  80042115f2:	48 89 d7             	mov    %rdx,%rdi
  80042115f5:	ff d0                	callq  *%rax
  80042115f7:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042115fe:	ff 
  80042115ff:	48 01 45 10          	add    %rax,0x10(%rbp)
			if (pc_req < pc)
  8004211603:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004211607:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421160b:	0f 82 6d 0a 00 00    	jb     800421207e <_dwarf_frame_run_inst+0xdd8>
			        goto program_done;
			break;
  8004211611:	e9 4f 0a 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_offset_extended:
			*row_pc = pc;
  8004211616:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421161a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421161e:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211621:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211625:	48 89 c7             	mov    %rax,%rdi
  8004211628:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  800421162f:	00 00 00 
  8004211632:	ff d0                	callq  *%rax
  8004211634:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004211638:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421163c:	48 89 c7             	mov    %rax,%rdi
  800421163f:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211646:	00 00 00 
  8004211649:	ff d0                	callq  *%rax
  800421164b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421164f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211653:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211657:	0f b7 c0             	movzwl %ax,%eax
  800421165a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421165e:	77 0c                	ja     800421166c <_dwarf_frame_run_inst+0x3c6>
  8004211660:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211667:	e9 13 0a 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  800421166c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211670:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211674:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211678:	48 89 d0             	mov    %rdx,%rax
  800421167b:	48 01 c0             	add    %rax,%rax
  800421167e:	48 01 d0             	add    %rdx,%rax
  8004211681:	48 c1 e0 03          	shl    $0x3,%rax
  8004211685:	48 01 c8             	add    %rcx,%rax
  8004211688:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  800421168b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421168f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211693:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211697:	48 89 d0             	mov    %rdx,%rax
  800421169a:	48 01 c0             	add    %rax,%rax
  800421169d:	48 01 d0             	add    %rdx,%rax
  80042116a0:	48 c1 e0 03          	shl    $0x3,%rax
  80042116a4:	48 01 c8             	add    %rcx,%rax
  80042116a7:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  80042116ab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116af:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042116b3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042116b7:	48 89 d0             	mov    %rdx,%rax
  80042116ba:	48 01 c0             	add    %rax,%rax
  80042116bd:	48 01 d0             	add    %rdx,%rax
  80042116c0:	48 c1 e0 03          	shl    $0x3,%rax
  80042116c4:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042116c8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042116cc:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042116d0:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  80042116d4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116d8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042116dc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042116e0:	48 89 d0             	mov    %rdx,%rax
  80042116e3:	48 01 c0             	add    %rax,%rax
  80042116e6:	48 01 d0             	add    %rdx,%rax
  80042116e9:	48 c1 e0 03          	shl    $0x3,%rax
  80042116ed:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042116f1:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042116f8:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  80042116fd:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004211701:	e9 5f 09 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_restore_extended:
			*row_pc = pc;
  8004211706:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421170a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421170e:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211711:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211715:	48 89 c7             	mov    %rax,%rdi
  8004211718:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  800421171f:	00 00 00 
  8004211722:	ff d0                	callq  *%rax
  8004211724:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211728:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421172c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211730:	0f b7 c0             	movzwl %ax,%eax
  8004211733:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211737:	77 0c                	ja     8004211745 <_dwarf_frame_run_inst+0x49f>
  8004211739:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211740:	e9 3a 09 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			memcpy(&RL[reg], &INITRL[reg],
  8004211745:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211749:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421174d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211751:	48 89 d0             	mov    %rdx,%rax
  8004211754:	48 01 c0             	add    %rax,%rax
  8004211757:	48 01 d0             	add    %rdx,%rax
  800421175a:	48 c1 e0 03          	shl    $0x3,%rax
  800421175e:	48 01 c1             	add    %rax,%rcx
  8004211761:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211765:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211769:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421176d:	48 89 d0             	mov    %rdx,%rax
  8004211770:	48 01 c0             	add    %rax,%rax
  8004211773:	48 01 d0             	add    %rdx,%rax
  8004211776:	48 c1 e0 03          	shl    $0x3,%rax
  800421177a:	48 01 f0             	add    %rsi,%rax
  800421177d:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211782:	48 89 ce             	mov    %rcx,%rsi
  8004211785:	48 89 c7             	mov    %rax,%rdi
  8004211788:	48 b8 19 ee 20 04 80 	movabs $0x800420ee19,%rax
  800421178f:	00 00 00 
  8004211792:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
			break;
  8004211794:	e9 cc 08 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_undefined:
			*row_pc = pc;
  8004211799:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421179d:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042117a1:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042117a4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042117a8:	48 89 c7             	mov    %rax,%rdi
  80042117ab:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  80042117b2:	00 00 00 
  80042117b5:	ff d0                	callq  *%rax
  80042117b7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042117bb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117bf:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042117c3:	0f b7 c0             	movzwl %ax,%eax
  80042117c6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042117ca:	77 0c                	ja     80042117d8 <_dwarf_frame_run_inst+0x532>
  80042117cc:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042117d3:	e9 a7 08 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  80042117d8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117dc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042117e0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042117e4:	48 89 d0             	mov    %rdx,%rax
  80042117e7:	48 01 c0             	add    %rax,%rax
  80042117ea:	48 01 d0             	add    %rdx,%rax
  80042117ed:	48 c1 e0 03          	shl    $0x3,%rax
  80042117f1:	48 01 c8             	add    %rcx,%rax
  80042117f4:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  80042117f7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117fb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042117ff:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211803:	48 89 d0             	mov    %rdx,%rax
  8004211806:	48 01 c0             	add    %rax,%rax
  8004211809:	48 01 d0             	add    %rdx,%rax
  800421180c:	48 c1 e0 03          	shl    $0x3,%rax
  8004211810:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211814:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211818:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  800421181c:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  8004211820:	e9 40 08 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_same_value:
			reg = _dwarf_decode_uleb128(&p);
  8004211825:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211829:	48 89 c7             	mov    %rax,%rdi
  800421182c:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211833:	00 00 00 
  8004211836:	ff d0                	callq  *%rax
  8004211838:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  800421183c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211840:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211844:	0f b7 c0             	movzwl %ax,%eax
  8004211847:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421184b:	77 0c                	ja     8004211859 <_dwarf_frame_run_inst+0x5b3>
  800421184d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211854:	e9 26 08 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  8004211859:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421185d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211861:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211865:	48 89 d0             	mov    %rdx,%rax
  8004211868:	48 01 c0             	add    %rax,%rax
  800421186b:	48 01 d0             	add    %rdx,%rax
  800421186e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211872:	48 01 c8             	add    %rcx,%rax
  8004211875:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004211878:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421187c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211880:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211884:	48 89 d0             	mov    %rdx,%rax
  8004211887:	48 01 c0             	add    %rax,%rax
  800421188a:	48 01 d0             	add    %rdx,%rax
  800421188d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211891:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211895:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211899:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  800421189d:	66 89 42 02          	mov    %ax,0x2(%rdx)
			break;
  80042118a1:	e9 bf 07 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_register:
			*row_pc = pc;
  80042118a6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042118aa:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042118ae:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042118b1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042118b5:	48 89 c7             	mov    %rax,%rdi
  80042118b8:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  80042118bf:	00 00 00 
  80042118c2:	ff d0                	callq  *%rax
  80042118c4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			reg2 = _dwarf_decode_uleb128(&p);
  80042118c8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042118cc:	48 89 c7             	mov    %rax,%rdi
  80042118cf:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  80042118d6:	00 00 00 
  80042118d9:	ff d0                	callq  *%rax
  80042118db:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
			CHECK_TABLE_SIZE(reg);
  80042118df:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042118e3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042118e7:	0f b7 c0             	movzwl %ax,%eax
  80042118ea:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042118ee:	77 0c                	ja     80042118fc <_dwarf_frame_run_inst+0x656>
  80042118f0:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042118f7:	e9 83 07 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  80042118fc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211900:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211904:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211908:	48 89 d0             	mov    %rdx,%rax
  800421190b:	48 01 c0             	add    %rax,%rax
  800421190e:	48 01 d0             	add    %rdx,%rax
  8004211911:	48 c1 e0 03          	shl    $0x3,%rax
  8004211915:	48 01 c8             	add    %rcx,%rax
  8004211918:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_regnum = reg2;
  800421191b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421191f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211923:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211927:	48 89 d0             	mov    %rdx,%rax
  800421192a:	48 01 c0             	add    %rax,%rax
  800421192d:	48 01 d0             	add    %rdx,%rax
  8004211930:	48 c1 e0 03          	shl    $0x3,%rax
  8004211934:	48 01 c8             	add    %rcx,%rax
  8004211937:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421193b:	66 89 50 02          	mov    %dx,0x2(%rax)
			break;
  800421193f:	e9 21 07 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_remember_state:
			_dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004211944:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004211948:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421194c:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  8004211950:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211954:	48 89 c7             	mov    %rax,%rdi
  8004211957:	48 b8 d8 10 21 04 80 	movabs $0x80042110d8,%rax
  800421195e:	00 00 00 
  8004211961:	ff d0                	callq  *%rax
			break;
  8004211963:	e9 fd 06 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_restore_state:
			*row_pc = pc;
  8004211968:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421196c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211970:	48 89 10             	mov    %rdx,(%rax)
			_dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004211973:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004211977:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421197b:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800421197f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211983:	48 89 c7             	mov    %rax,%rdi
  8004211986:	48 b8 d8 10 21 04 80 	movabs $0x80042110d8,%rax
  800421198d:	00 00 00 
  8004211990:	ff d0                	callq  *%rax
			break;
  8004211992:	e9 ce 06 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa:
			*row_pc = pc;
  8004211997:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421199b:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421199f:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  80042119a2:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042119a6:	48 89 c7             	mov    %rax,%rdi
  80042119a9:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  80042119b0:	00 00 00 
  80042119b3:	ff d0                	callq  *%rax
  80042119b5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  80042119b9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042119bd:	48 89 c7             	mov    %rax,%rdi
  80042119c0:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  80042119c7:	00 00 00 
  80042119ca:	ff d0                	callq  *%rax
  80042119cc:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  80042119d0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042119d4:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  80042119d7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042119db:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  80042119df:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042119e3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042119e7:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = uoff;
  80042119eb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042119ef:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042119f3:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  80042119f7:	e9 69 06 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_register:
			*row_pc = pc;
  80042119fc:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211a00:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211a04:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211a07:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211a0b:	48 89 c7             	mov    %rax,%rdi
  8004211a0e:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211a15:	00 00 00 
  8004211a18:	ff d0                	callq  *%rax
  8004211a1a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CFA.dw_regnum = reg;
  8004211a1e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a22:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a26:	66 89 50 02          	mov    %dx,0x2(%rax)
			 * Note that DW_CFA_def_cfa_register change the CFA
			 * rule register while keep the old offset. So we
			 * should not touch the CFA.dw_offset_relevant flag
			 * here.
			 */
			break;
  8004211a2a:	e9 36 06 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_offset:
			*row_pc = pc;
  8004211a2f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211a33:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211a37:	48 89 10             	mov    %rdx,(%rax)
			uoff = _dwarf_decode_uleb128(&p);
  8004211a3a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211a3e:	48 89 c7             	mov    %rax,%rdi
  8004211a41:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211a48:	00 00 00 
  8004211a4b:	ff d0                	callq  *%rax
  8004211a4d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211a51:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a55:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211a58:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a5c:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = uoff;
  8004211a60:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a64:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211a68:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211a6c:	e9 f4 05 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_expression:
			*row_pc = pc;
  8004211a71:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211a75:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211a79:	48 89 10             	mov    %rdx,(%rax)
			CFA.dw_offset_relevant = 0;
  8004211a7c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a80:	c6 00 00             	movb   $0x0,(%rax)
			CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004211a83:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a87:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  8004211a8b:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004211a8f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211a93:	48 89 c7             	mov    %rax,%rdi
  8004211a96:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211a9d:	00 00 00 
  8004211aa0:	ff d0                	callq  *%rax
  8004211aa2:	48 89 43 08          	mov    %rax,0x8(%rbx)
			CFA.dw_block_ptr = p;
  8004211aa6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211aaa:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211aae:	48 89 50 10          	mov    %rdx,0x10(%rax)
			p += CFA.dw_offset_or_block_len;
  8004211ab2:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211ab6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211aba:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211abe:	48 01 d0             	add    %rdx,%rax
  8004211ac1:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004211ac5:	e9 9b 05 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_expression:
			*row_pc = pc;
  8004211aca:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211ace:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211ad2:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211ad5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211ad9:	48 89 c7             	mov    %rax,%rdi
  8004211adc:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211ae3:	00 00 00 
  8004211ae6:	ff d0                	callq  *%rax
  8004211ae8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211aec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211af0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211af4:	0f b7 c0             	movzwl %ax,%eax
  8004211af7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211afb:	77 0c                	ja     8004211b09 <_dwarf_frame_run_inst+0x863>
  8004211afd:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211b04:	e9 76 05 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  8004211b09:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b0d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b11:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b15:	48 89 d0             	mov    %rdx,%rax
  8004211b18:	48 01 c0             	add    %rax,%rax
  8004211b1b:	48 01 d0             	add    %rdx,%rax
  8004211b1e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b22:	48 01 c8             	add    %rcx,%rax
  8004211b25:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  8004211b28:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b2c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b30:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b34:	48 89 d0             	mov    %rdx,%rax
  8004211b37:	48 01 c0             	add    %rax,%rax
  8004211b3a:	48 01 d0             	add    %rdx,%rax
  8004211b3d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b41:	48 01 c8             	add    %rcx,%rax
  8004211b44:	c6 40 01 02          	movb   $0x2,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004211b48:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b4c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b50:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b54:	48 89 d0             	mov    %rdx,%rax
  8004211b57:	48 01 c0             	add    %rax,%rax
  8004211b5a:	48 01 d0             	add    %rdx,%rax
  8004211b5d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b61:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004211b65:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211b69:	48 89 c7             	mov    %rax,%rdi
  8004211b6c:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211b73:	00 00 00 
  8004211b76:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004211b78:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  8004211b7c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b80:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b84:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b88:	48 89 d0             	mov    %rdx,%rax
  8004211b8b:	48 01 c0             	add    %rax,%rax
  8004211b8e:	48 01 d0             	add    %rdx,%rax
  8004211b91:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b95:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211b99:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211b9d:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  8004211ba1:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004211ba5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ba9:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211bad:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211bb1:	48 89 d0             	mov    %rdx,%rax
  8004211bb4:	48 01 c0             	add    %rax,%rax
  8004211bb7:	48 01 d0             	add    %rdx,%rax
  8004211bba:	48 c1 e0 03          	shl    $0x3,%rax
  8004211bbe:	48 01 f0             	add    %rsi,%rax
  8004211bc1:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211bc5:	48 01 c8             	add    %rcx,%rax
  8004211bc8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  8004211bcc:	e9 94 04 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_offset_extended_sf:
			*row_pc = pc;
  8004211bd1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211bd5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211bd9:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211bdc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211be0:	48 89 c7             	mov    %rax,%rdi
  8004211be3:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211bea:	00 00 00 
  8004211bed:	ff d0                	callq  *%rax
  8004211bef:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004211bf3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211bf7:	48 89 c7             	mov    %rax,%rdi
  8004211bfa:	48 b8 0e f8 20 04 80 	movabs $0x800420f80e,%rax
  8004211c01:	00 00 00 
  8004211c04:	ff d0                	callq  *%rax
  8004211c06:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211c0a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c0e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211c12:	0f b7 c0             	movzwl %ax,%eax
  8004211c15:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211c19:	77 0c                	ja     8004211c27 <_dwarf_frame_run_inst+0x981>
  8004211c1b:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211c22:	e9 58 04 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  8004211c27:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c2b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211c2f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c33:	48 89 d0             	mov    %rdx,%rax
  8004211c36:	48 01 c0             	add    %rax,%rax
  8004211c39:	48 01 d0             	add    %rdx,%rax
  8004211c3c:	48 c1 e0 03          	shl    $0x3,%rax
  8004211c40:	48 01 c8             	add    %rcx,%rax
  8004211c43:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004211c46:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c4a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211c4e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c52:	48 89 d0             	mov    %rdx,%rax
  8004211c55:	48 01 c0             	add    %rax,%rax
  8004211c58:	48 01 d0             	add    %rdx,%rax
  8004211c5b:	48 c1 e0 03          	shl    $0x3,%rax
  8004211c5f:	48 01 c8             	add    %rcx,%rax
  8004211c62:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211c66:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c6a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211c6e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c72:	48 89 d0             	mov    %rdx,%rax
  8004211c75:	48 01 c0             	add    %rax,%rax
  8004211c78:	48 01 d0             	add    %rdx,%rax
  8004211c7b:	48 c1 e0 03          	shl    $0x3,%rax
  8004211c7f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211c83:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211c87:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211c8b:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004211c8f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211c93:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211c97:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211c9b:	48 89 d0             	mov    %rdx,%rax
  8004211c9e:	48 01 c0             	add    %rax,%rax
  8004211ca1:	48 01 d0             	add    %rdx,%rax
  8004211ca4:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ca8:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211cac:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211cb3:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004211cb8:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004211cbc:	e9 a4 03 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_sf:
			*row_pc = pc;
  8004211cc1:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211cc5:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211cc9:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211ccc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211cd0:	48 89 c7             	mov    %rax,%rdi
  8004211cd3:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211cda:	00 00 00 
  8004211cdd:	ff d0                	callq  *%rax
  8004211cdf:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004211ce3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211ce7:	48 89 c7             	mov    %rax,%rdi
  8004211cea:	48 b8 0e f8 20 04 80 	movabs $0x800420f80e,%rax
  8004211cf1:	00 00 00 
  8004211cf4:	ff d0                	callq  *%rax
  8004211cf6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211cfa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211cfe:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211d01:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d05:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_regnum = reg;
  8004211d09:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d0d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211d11:	66 89 50 02          	mov    %dx,0x2(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004211d15:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d19:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211d20:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004211d25:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211d29:	e9 37 03 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_def_cfa_offset_sf:
			*row_pc = pc;
  8004211d2e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211d32:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211d36:	48 89 10             	mov    %rdx,(%rax)
			soff = _dwarf_decode_sleb128(&p);
  8004211d39:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211d3d:	48 89 c7             	mov    %rax,%rdi
  8004211d40:	48 b8 0e f8 20 04 80 	movabs $0x800420f80e,%rax
  8004211d47:	00 00 00 
  8004211d4a:	ff d0                	callq  *%rax
  8004211d4c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CFA.dw_offset_relevant = 1;
  8004211d50:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d54:	c6 00 01             	movb   $0x1,(%rax)
			CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211d57:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d5b:	c6 40 01 00          	movb   $0x0,0x1(%rax)
			CFA.dw_offset_or_block_len = soff * daf;
  8004211d5f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211d63:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211d6a:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004211d6f:	48 89 50 08          	mov    %rdx,0x8(%rax)
			break;
  8004211d73:	e9 ed 02 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_val_offset:
			*row_pc = pc;
  8004211d78:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211d7c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211d80:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211d83:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211d87:	48 89 c7             	mov    %rax,%rdi
  8004211d8a:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211d91:	00 00 00 
  8004211d94:	ff d0                	callq  *%rax
  8004211d96:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			uoff = _dwarf_decode_uleb128(&p);
  8004211d9a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211d9e:	48 89 c7             	mov    %rax,%rdi
  8004211da1:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211da8:	00 00 00 
  8004211dab:	ff d0                	callq  *%rax
  8004211dad:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211db1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211db5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211db9:	0f b7 c0             	movzwl %ax,%eax
  8004211dbc:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211dc0:	77 0c                	ja     8004211dce <_dwarf_frame_run_inst+0xb28>
  8004211dc2:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211dc9:	e9 b1 02 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  8004211dce:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211dd2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211dd6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211dda:	48 89 d0             	mov    %rdx,%rax
  8004211ddd:	48 01 c0             	add    %rax,%rax
  8004211de0:	48 01 d0             	add    %rdx,%rax
  8004211de3:	48 c1 e0 03          	shl    $0x3,%rax
  8004211de7:	48 01 c8             	add    %rcx,%rax
  8004211dea:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004211ded:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211df1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211df5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211df9:	48 89 d0             	mov    %rdx,%rax
  8004211dfc:	48 01 c0             	add    %rax,%rax
  8004211dff:	48 01 d0             	add    %rdx,%rax
  8004211e02:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e06:	48 01 c8             	add    %rcx,%rax
  8004211e09:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211e0d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e11:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211e15:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e19:	48 89 d0             	mov    %rdx,%rax
  8004211e1c:	48 01 c0             	add    %rax,%rax
  8004211e1f:	48 01 d0             	add    %rdx,%rax
  8004211e22:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e26:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211e2a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211e2e:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211e32:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = uoff * daf;
  8004211e36:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211e3a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211e3e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211e42:	48 89 d0             	mov    %rdx,%rax
  8004211e45:	48 01 c0             	add    %rax,%rax
  8004211e48:	48 01 d0             	add    %rdx,%rax
  8004211e4b:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e4f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211e53:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211e5a:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004211e5f:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004211e63:	e9 fd 01 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_val_offset_sf:
			*row_pc = pc;
  8004211e68:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211e6c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211e70:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211e73:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211e77:	48 89 c7             	mov    %rax,%rdi
  8004211e7a:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211e81:	00 00 00 
  8004211e84:	ff d0                	callq  *%rax
  8004211e86:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			soff = _dwarf_decode_sleb128(&p);
  8004211e8a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211e8e:	48 89 c7             	mov    %rax,%rdi
  8004211e91:	48 b8 0e f8 20 04 80 	movabs $0x800420f80e,%rax
  8004211e98:	00 00 00 
  8004211e9b:	ff d0                	callq  *%rax
  8004211e9d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211ea1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ea5:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211ea9:	0f b7 c0             	movzwl %ax,%eax
  8004211eac:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211eb0:	77 0c                	ja     8004211ebe <_dwarf_frame_run_inst+0xc18>
  8004211eb2:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211eb9:	e9 c1 01 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 1;
  8004211ebe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ec2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211ec6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211eca:	48 89 d0             	mov    %rdx,%rax
  8004211ecd:	48 01 c0             	add    %rax,%rax
  8004211ed0:	48 01 d0             	add    %rdx,%rax
  8004211ed3:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ed7:	48 01 c8             	add    %rcx,%rax
  8004211eda:	c6 00 01             	movb   $0x1,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004211edd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211ee1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211ee5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211ee9:	48 89 d0             	mov    %rdx,%rax
  8004211eec:	48 01 c0             	add    %rax,%rax
  8004211eef:	48 01 d0             	add    %rdx,%rax
  8004211ef2:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ef6:	48 01 c8             	add    %rcx,%rax
  8004211ef9:	c6 40 01 01          	movb   $0x1,0x1(%rax)
			RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211efd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f01:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211f05:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211f09:	48 89 d0             	mov    %rdx,%rax
  8004211f0c:	48 01 c0             	add    %rax,%rax
  8004211f0f:	48 01 d0             	add    %rdx,%rax
  8004211f12:	48 c1 e0 03          	shl    $0x3,%rax
  8004211f16:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211f1a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211f1e:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004211f22:	66 89 42 02          	mov    %ax,0x2(%rdx)
			RL[reg].dw_offset_or_block_len = soff * daf;
  8004211f26:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f2a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211f2e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211f32:	48 89 d0             	mov    %rdx,%rax
  8004211f35:	48 01 c0             	add    %rax,%rax
  8004211f38:	48 01 d0             	add    %rdx,%rax
  8004211f3b:	48 c1 e0 03          	shl    $0x3,%rax
  8004211f3f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211f43:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211f4a:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004211f4f:	48 89 42 08          	mov    %rax,0x8(%rdx)
			break;
  8004211f53:	e9 0d 01 00 00       	jmpq   8004212065 <_dwarf_frame_run_inst+0xdbf>
		case DW_CFA_val_expression:
			*row_pc = pc;
  8004211f58:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211f5c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211f60:	48 89 10             	mov    %rdx,(%rax)
			reg = _dwarf_decode_uleb128(&p);
  8004211f63:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211f67:	48 89 c7             	mov    %rax,%rdi
  8004211f6a:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004211f71:	00 00 00 
  8004211f74:	ff d0                	callq  *%rax
  8004211f76:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			CHECK_TABLE_SIZE(reg);
  8004211f7a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f7e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211f82:	0f b7 c0             	movzwl %ax,%eax
  8004211f85:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211f89:	77 0c                	ja     8004211f97 <_dwarf_frame_run_inst+0xcf1>
  8004211f8b:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211f92:	e9 e8 00 00 00       	jmpq   800421207f <_dwarf_frame_run_inst+0xdd9>
			RL[reg].dw_offset_relevant = 0;
  8004211f97:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211f9b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211f9f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211fa3:	48 89 d0             	mov    %rdx,%rax
  8004211fa6:	48 01 c0             	add    %rax,%rax
  8004211fa9:	48 01 d0             	add    %rdx,%rax
  8004211fac:	48 c1 e0 03          	shl    $0x3,%rax
  8004211fb0:	48 01 c8             	add    %rcx,%rax
  8004211fb3:	c6 00 00             	movb   $0x0,(%rax)
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004211fb6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211fba:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211fbe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211fc2:	48 89 d0             	mov    %rdx,%rax
  8004211fc5:	48 01 c0             	add    %rax,%rax
  8004211fc8:	48 01 d0             	add    %rdx,%rax
  8004211fcb:	48 c1 e0 03          	shl    $0x3,%rax
  8004211fcf:	48 01 c8             	add    %rcx,%rax
  8004211fd2:	c6 40 01 03          	movb   $0x3,0x1(%rax)
			RL[reg].dw_offset_or_block_len =
  8004211fd6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211fda:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211fde:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211fe2:	48 89 d0             	mov    %rdx,%rax
  8004211fe5:	48 01 c0             	add    %rax,%rax
  8004211fe8:	48 01 d0             	add    %rdx,%rax
  8004211feb:	48 c1 e0 03          	shl    $0x3,%rax
  8004211fef:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004211ff3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211ff7:	48 89 c7             	mov    %rax,%rdi
  8004211ffa:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004212001:	00 00 00 
  8004212004:	ff d0                	callq  *%rax
			*row_pc = pc;
			reg = _dwarf_decode_uleb128(&p);
			CHECK_TABLE_SIZE(reg);
			RL[reg].dw_offset_relevant = 0;
			RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
			RL[reg].dw_offset_or_block_len =
  8004212006:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
			RL[reg].dw_block_ptr = p;
  800421200a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421200e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212012:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212016:	48 89 d0             	mov    %rdx,%rax
  8004212019:	48 01 c0             	add    %rax,%rax
  800421201c:	48 01 d0             	add    %rdx,%rax
  800421201f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212023:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212027:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421202b:	48 89 42 10          	mov    %rax,0x10(%rdx)
			p += RL[reg].dw_offset_or_block_len;
  800421202f:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004212033:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212037:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421203b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421203f:	48 89 d0             	mov    %rdx,%rax
  8004212042:	48 01 c0             	add    %rax,%rax
  8004212045:	48 01 d0             	add    %rdx,%rax
  8004212048:	48 c1 e0 03          	shl    $0x3,%rax
  800421204c:	48 01 f0             	add    %rsi,%rax
  800421204f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212053:	48 01 c8             	add    %rcx,%rax
  8004212056:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			break;
  800421205a:	eb 09                	jmp    8004212065 <_dwarf_frame_run_inst+0xdbf>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
			ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  800421205c:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
			goto program_done;
  8004212063:	eb 1a                	jmp    800421207f <_dwarf_frame_run_inst+0xdd9>
	/* Save a copy of the table as initial state. */
	_dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
	p = insts;
	pe = p + len;

	while (p < pe) {
  8004212065:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212069:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421206d:	0f 82 ba f2 ff ff    	jb     800421132d <_dwarf_frame_run_inst+0x87>
  8004212073:	eb 0a                	jmp    800421207f <_dwarf_frame_run_inst+0xdd9>

		switch (low6) {
		case DW_CFA_set_loc:
			pc = dbg->decode(&p, dbg->dbg_pointer_size);
			if (pc_req < pc)
			        goto program_done;
  8004212075:	90                   	nop
  8004212076:	eb 07                	jmp    800421207f <_dwarf_frame_run_inst+0xdd9>
			break;
		case DW_CFA_advance_loc1:
			pc += dbg->decode(&p, 1) * caf;
			if (pc_req < pc)
			        goto program_done;
  8004212078:	90                   	nop
  8004212079:	eb 04                	jmp    800421207f <_dwarf_frame_run_inst+0xdd9>
			break;
		case DW_CFA_advance_loc2:
			pc += dbg->decode(&p, 2) * caf;
			if (pc_req < pc)
			        goto program_done;
  800421207b:	90                   	nop
  800421207c:	eb 01                	jmp    800421207f <_dwarf_frame_run_inst+0xdd9>
			break;
		case DW_CFA_advance_loc4:
			pc += dbg->decode(&p, 4) * caf;
			if (pc_req < pc)
			        goto program_done;
  800421207e:	90                   	nop
			goto program_done;
		}
	}

program_done:
	return (ret);
  800421207f:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004212082:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8004212089:	5b                   	pop    %rbx
  800421208a:	5d                   	pop    %rbp
  800421208b:	c3                   	retq   

000000800421208c <_dwarf_frame_get_internal_table>:
int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt,
				Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  800421208c:	55                   	push   %rbp
  800421208d:	48 89 e5             	mov    %rsp,%rbp
  8004212090:	48 83 ec 60          	sub    $0x60,%rsp
  8004212094:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212098:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421209c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042120a0:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042120a4:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  80042120a8:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Cie cie;
	Dwarf_Regtable3 *rt;
	Dwarf_Addr row_pc;
	int i, ret;

	assert(ret_rt != NULL);
  80042120ac:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042120b1:	75 35                	jne    80042120e8 <_dwarf_frame_get_internal_table+0x5c>
  80042120b3:	48 b9 58 86 21 04 80 	movabs $0x8004218658,%rcx
  80042120ba:	00 00 00 
  80042120bd:	48 ba 67 85 21 04 80 	movabs $0x8004218567,%rdx
  80042120c4:	00 00 00 
  80042120c7:	be 83 01 00 00       	mov    $0x183,%esi
  80042120cc:	48 bf 7c 85 21 04 80 	movabs $0x800421857c,%rdi
  80042120d3:	00 00 00 
  80042120d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042120db:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042120e2:	00 00 00 
  80042120e5:	41 ff d0             	callq  *%r8

	//dbg = fde->fde_dbg;
	assert(dbg != NULL);
  80042120e8:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042120ed:	75 35                	jne    8004212124 <_dwarf_frame_get_internal_table+0x98>
  80042120ef:	48 b9 67 86 21 04 80 	movabs $0x8004218667,%rcx
  80042120f6:	00 00 00 
  80042120f9:	48 ba 67 85 21 04 80 	movabs $0x8004218567,%rdx
  8004212100:	00 00 00 
  8004212103:	be 86 01 00 00       	mov    $0x186,%esi
  8004212108:	48 bf 7c 85 21 04 80 	movabs $0x800421857c,%rdi
  800421210f:	00 00 00 
  8004212112:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212117:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800421211e:	00 00 00 
  8004212121:	41 ff d0             	callq  *%r8

	rt = dbg->dbg_internal_reg_table;
  8004212124:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212128:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421212c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	/* Clear the content of regtable from previous run. */
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004212130:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212134:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212139:	be 00 00 00 00       	mov    $0x0,%esi
  800421213e:	48 89 c7             	mov    %rax,%rdi
  8004212141:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  8004212148:	00 00 00 
  800421214b:	ff d0                	callq  *%rax
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  800421214d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212151:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212155:	0f b7 d0             	movzwl %ax,%edx
  8004212158:	48 89 d0             	mov    %rdx,%rax
  800421215b:	48 01 c0             	add    %rax,%rax
  800421215e:	48 01 d0             	add    %rdx,%rax
  8004212161:	48 c1 e0 03          	shl    $0x3,%rax
  8004212165:	48 89 c2             	mov    %rax,%rdx
  8004212168:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421216c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212170:	be 00 00 00 00       	mov    $0x0,%esi
  8004212175:	48 89 c7             	mov    %rax,%rdi
  8004212178:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  800421217f:	00 00 00 
  8004212182:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004212184:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421218b:	eb 2f                	jmp    80042121bc <_dwarf_frame_get_internal_table+0x130>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  800421218d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212191:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212195:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212198:	48 63 d0             	movslq %eax,%rdx
  800421219b:	48 89 d0             	mov    %rdx,%rax
  800421219e:	48 01 c0             	add    %rax,%rax
  80042121a1:	48 01 d0             	add    %rdx,%rax
  80042121a4:	48 c1 e0 03          	shl    $0x3,%rax
  80042121a8:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042121ac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042121b0:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  80042121b4:	66 89 42 02          	mov    %ax,0x2(%rdx)
	memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
	memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

	/* Set rules to initial values. */
	for (i = 0; i < rt->rt3_reg_table_size; i++)
  80042121b8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042121bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042121c0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042121c4:	0f b7 c0             	movzwl %ax,%eax
  80042121c7:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042121ca:	7f c1                	jg     800421218d <_dwarf_frame_get_internal_table+0x101>
		rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

	/* Run initial instructions in CIE. */
	cie = fde->fde_cie;
  80042121cc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042121d0:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042121d4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	assert(cie != NULL);
  80042121d8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042121dd:	75 35                	jne    8004212214 <_dwarf_frame_get_internal_table+0x188>
  80042121df:	48 b9 73 86 21 04 80 	movabs $0x8004218673,%rcx
  80042121e6:	00 00 00 
  80042121e9:	48 ba 67 85 21 04 80 	movabs $0x8004218567,%rdx
  80042121f0:	00 00 00 
  80042121f3:	be 95 01 00 00       	mov    $0x195,%esi
  80042121f8:	48 bf 7c 85 21 04 80 	movabs $0x800421857c,%rdi
  80042121ff:	00 00 00 
  8004212202:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212207:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800421220e:	00 00 00 
  8004212211:	41 ff d0             	callq  *%r8
	ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004212214:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212218:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800421221c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212220:	4c 8b 40 38          	mov    0x38(%rax),%r8
  8004212224:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212228:	48 8b 48 70          	mov    0x70(%rax),%rcx
  800421222c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212230:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004212234:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004212238:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421223c:	ff 75 a0             	pushq  -0x60(%rbp)
  800421223f:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8004212243:	57                   	push   %rdi
  8004212244:	6a ff                	pushq  $0xffffffffffffffff
  8004212246:	6a 00                	pushq  $0x0
  8004212248:	48 89 c7             	mov    %rax,%rdi
  800421224b:	48 b8 a6 12 21 04 80 	movabs $0x80042112a6,%rax
  8004212252:	00 00 00 
  8004212255:	ff d0                	callq  *%rax
  8004212257:	48 83 c4 20          	add    $0x20,%rsp
  800421225b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf,
				    cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
	if (ret != DW_DLE_NONE)
  800421225e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212262:	74 08                	je     800421226c <_dwarf_frame_get_internal_table+0x1e0>
		return (ret);
  8004212264:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212267:	e9 8a 00 00 00       	jmpq   80042122f6 <_dwarf_frame_get_internal_table+0x26a>
	/* Run instructions in FDE. */
	if (pc_req >= fde->fde_initloc) {
  800421226c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212270:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212274:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004212278:	77 61                	ja     80042122db <_dwarf_frame_get_internal_table+0x24f>
		ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  800421227a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421227e:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8004212282:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212286:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800421228a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421228e:	4c 8b 50 38          	mov    0x38(%rax),%r10
  8004212292:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212296:	48 8b 48 58          	mov    0x58(%rax),%rcx
  800421229a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421229e:	48 8b 50 50          	mov    0x50(%rax),%rdx
  80042122a2:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80042122a6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042122aa:	ff 75 a0             	pushq  -0x60(%rbp)
  80042122ad:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  80042122b1:	41 50                	push   %r8
  80042122b3:	ff 75 b8             	pushq  -0x48(%rbp)
  80042122b6:	57                   	push   %rdi
  80042122b7:	4d 89 d0             	mov    %r10,%r8
  80042122ba:	48 89 c7             	mov    %rax,%rdi
  80042122bd:	48 b8 a6 12 21 04 80 	movabs $0x80042112a6,%rax
  80042122c4:	00 00 00 
  80042122c7:	ff d0                	callq  *%rax
  80042122c9:	48 83 c4 20          	add    $0x20,%rsp
  80042122cd:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf,
					    cie->cie_daf,
					    fde->fde_initloc, pc_req,
					    &row_pc, error);
		if (ret != DW_DLE_NONE)
  80042122d0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042122d4:	74 05                	je     80042122db <_dwarf_frame_get_internal_table+0x24f>
			return (ret);
  80042122d6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042122d9:	eb 1b                	jmp    80042122f6 <_dwarf_frame_get_internal_table+0x26a>
	}

	*ret_rt = rt;
  80042122db:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042122df:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042122e3:	48 89 10             	mov    %rdx,(%rax)
	*ret_row_pc = row_pc;
  80042122e6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042122ea:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042122ee:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  80042122f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042122f6:	c9                   	leaveq 
  80042122f7:	c3                   	retq   

00000080042122f8 <dwarf_get_fde_info_for_all_regs>:
int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested,
				Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  80042122f8:	55                   	push   %rbp
  80042122f9:	48 89 e5             	mov    %rsp,%rbp
  80042122fc:	48 83 ec 50          	sub    $0x50,%rsp
  8004212300:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004212304:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004212308:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421230c:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004212310:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8004212314:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
	Dwarf_Regtable3 *rt;
	Dwarf_Addr pc;
	Dwarf_Half cfa;
	int i, ret;

	if (fde == NULL || reg_table == NULL) {
  8004212318:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421231d:	74 07                	je     8004212326 <dwarf_get_fde_info_for_all_regs+0x2e>
  800421231f:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004212324:	75 0a                	jne    8004212330 <dwarf_get_fde_info_for_all_regs+0x38>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004212326:	b8 01 00 00 00       	mov    $0x1,%eax
  800421232b:	e9 f9 02 00 00       	jmpq   8004212629 <dwarf_get_fde_info_for_all_regs+0x331>
	}

	assert(dbg != NULL);
  8004212330:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212335:	75 35                	jne    800421236c <dwarf_get_fde_info_for_all_regs+0x74>
  8004212337:	48 b9 67 86 21 04 80 	movabs $0x8004218667,%rcx
  800421233e:	00 00 00 
  8004212341:	48 ba 67 85 21 04 80 	movabs $0x8004218567,%rdx
  8004212348:	00 00 00 
  800421234b:	be bf 01 00 00       	mov    $0x1bf,%esi
  8004212350:	48 bf 7c 85 21 04 80 	movabs $0x800421857c,%rdi
  8004212357:	00 00 00 
  800421235a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421235f:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004212366:	00 00 00 
  8004212369:	41 ff d0             	callq  *%r8

	if (pc_requested < fde->fde_initloc ||
  800421236c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212370:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212374:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004212378:	77 19                	ja     8004212393 <dwarf_get_fde_info_for_all_regs+0x9b>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  800421237a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421237e:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004212382:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212386:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421238a:	48 01 d0             	add    %rdx,%rax
		return (DW_DLV_ERROR);
	}

	assert(dbg != NULL);

	if (pc_requested < fde->fde_initloc ||
  800421238d:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004212391:	77 0a                	ja     800421239d <dwarf_get_fde_info_for_all_regs+0xa5>
	    pc_requested >= fde->fde_initloc + fde->fde_adrange) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
		return (DW_DLV_ERROR);
  8004212393:	b8 01 00 00 00       	mov    $0x1,%eax
  8004212398:	e9 8c 02 00 00       	jmpq   8004212629 <dwarf_get_fde_info_for_all_regs+0x331>
	}

	ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  800421239d:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  80042123a1:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  80042123a5:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  80042123a9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042123ad:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042123b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042123b5:	4d 89 c1             	mov    %r8,%r9
  80042123b8:	49 89 f8             	mov    %rdi,%r8
  80042123bb:	48 89 c7             	mov    %rax,%rdi
  80042123be:	48 b8 8c 20 21 04 80 	movabs $0x800421208c,%rax
  80042123c5:	00 00 00 
  80042123c8:	ff d0                	callq  *%rax
  80042123ca:	89 45 f8             	mov    %eax,-0x8(%rbp)
					      error);
	if (ret != DW_DLE_NONE)
  80042123cd:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042123d1:	74 0a                	je     80042123dd <dwarf_get_fde_info_for_all_regs+0xe5>
		return (DW_DLV_ERROR);
  80042123d3:	b8 01 00 00 00       	mov    $0x1,%eax
  80042123d8:	e9 4c 02 00 00       	jmpq   8004212629 <dwarf_get_fde_info_for_all_regs+0x331>
	/*
	 * Copy the CFA rule to the column intended for holding the CFA,
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
  80042123dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042123e1:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042123e5:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	if (cfa < DW_REG_TABLE_SIZE) {
  80042123e9:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  80042123ee:	0f 87 b7 00 00 00    	ja     80042124ab <dwarf_get_fde_info_for_all_regs+0x1b3>
		reg_table->rules[cfa].dw_offset_relevant =
  80042123f4:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  80042123f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042123fc:	0f b6 00             	movzbl (%rax),%eax
	 * if it's within the range of regtable.
	 */
#define CFA rt->rt3_cfa_rule
	cfa = dbg->dbg_frame_cfa_value;
	if (cfa < DW_REG_TABLE_SIZE) {
		reg_table->rules[cfa].dw_offset_relevant =
  80042123ff:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212403:	48 63 c9             	movslq %ecx,%rcx
  8004212406:	48 83 c1 01          	add    $0x1,%rcx
  800421240a:	48 c1 e1 04          	shl    $0x4,%rcx
  800421240e:	48 01 ca             	add    %rcx,%rdx
  8004212411:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  8004212413:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212417:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421241b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  800421241f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212423:	48 63 c9             	movslq %ecx,%rcx
  8004212426:	48 83 c1 01          	add    $0x1,%rcx
  800421242a:	48 c1 e1 04          	shl    $0x4,%rcx
  800421242e:	48 01 ca             	add    %rcx,%rdx
  8004212431:	48 83 c2 01          	add    $0x1,%rdx
  8004212435:	88 02                	mov    %al,(%rdx)
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  8004212437:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421243b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421243f:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004212443:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212447:	48 63 c9             	movslq %ecx,%rcx
  800421244a:	48 83 c1 01          	add    $0x1,%rcx
  800421244e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212452:	48 01 ca             	add    %rcx,%rdx
  8004212455:	48 83 c2 02          	add    $0x2,%rdx
  8004212459:	66 89 02             	mov    %ax,(%rdx)
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  800421245c:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212460:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212464:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212468:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421246c:	48 63 c9             	movslq %ecx,%rcx
  800421246f:	48 83 c1 01          	add    $0x1,%rcx
  8004212473:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212477:	48 01 ca             	add    %rcx,%rdx
  800421247a:	48 83 c2 08          	add    $0x8,%rdx
  800421247e:	48 89 02             	mov    %rax,(%rdx)
		reg_table->cfa_rule = reg_table->rules[cfa];
  8004212481:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004212485:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004212489:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421248d:	48 63 d2             	movslq %edx,%rdx
  8004212490:	48 83 c2 01          	add    $0x1,%rdx
  8004212494:	48 c1 e2 04          	shl    $0x4,%rdx
  8004212498:	48 01 d0             	add    %rdx,%rax
  800421249b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421249f:	48 8b 00             	mov    (%rax),%rax
  80042124a2:	48 89 01             	mov    %rax,(%rcx)
  80042124a5:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  80042124a9:	eb 3c                	jmp    80042124e7 <dwarf_get_fde_info_for_all_regs+0x1ef>
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
		    CFA.dw_offset_relevant;
  80042124ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124af:	0f b6 10             	movzbl (%rax),%edx
		reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
		reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
		reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
		reg_table->cfa_rule = reg_table->rules[cfa];
	} else {
		reg_table->cfa_rule.dw_offset_relevant =
  80042124b2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042124b6:	88 10                	mov    %dl,(%rax)
		    CFA.dw_offset_relevant;
		reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  80042124b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124bc:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  80042124c0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042124c4:	88 50 01             	mov    %dl,0x1(%rax)
		reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  80042124c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124cb:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  80042124cf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042124d3:	66 89 50 02          	mov    %dx,0x2(%rax)
		reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  80042124d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124db:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042124df:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042124e3:	48 89 50 08          	mov    %rdx,0x8(%rax)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042124e7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042124ee:	e9 05 01 00 00       	jmpq   80042125f8 <dwarf_get_fde_info_for_all_regs+0x300>
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
  80042124f3:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80042124f7:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042124fa:	0f 84 f3 00 00 00    	je     80042125f3 <dwarf_get_fde_info_for_all_regs+0x2fb>
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  8004212500:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212504:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212508:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421250b:	48 63 d0             	movslq %eax,%rdx
  800421250e:	48 89 d0             	mov    %rdx,%rax
  8004212511:	48 01 c0             	add    %rax,%rax
  8004212514:	48 01 d0             	add    %rdx,%rax
  8004212517:	48 c1 e0 03          	shl    $0x3,%rax
  800421251b:	48 01 c8             	add    %rcx,%rax
  800421251e:	0f b6 00             	movzbl (%rax),%eax

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
  8004212521:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004212525:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004212528:	48 63 c9             	movslq %ecx,%rcx
  800421252b:	48 83 c1 01          	add    $0x1,%rcx
  800421252f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212533:	48 01 ca             	add    %rcx,%rdx
  8004212536:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  8004212538:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421253c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212540:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212543:	48 63 d0             	movslq %eax,%rdx
  8004212546:	48 89 d0             	mov    %rdx,%rax
  8004212549:	48 01 c0             	add    %rax,%rax
  800421254c:	48 01 d0             	add    %rdx,%rax
  800421254f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212553:	48 01 c8             	add    %rcx,%rax
  8004212556:	0f b6 40 01          	movzbl 0x1(%rax),%eax
		if (i == cfa)
			continue;

		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
  800421255a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421255e:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004212561:	48 63 c9             	movslq %ecx,%rcx
  8004212564:	48 83 c1 01          	add    $0x1,%rcx
  8004212568:	48 c1 e1 04          	shl    $0x4,%rcx
  800421256c:	48 01 ca             	add    %rcx,%rdx
  800421256f:	48 83 c2 01          	add    $0x1,%rdx
  8004212573:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004212575:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212579:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421257d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212580:	48 63 d0             	movslq %eax,%rdx
  8004212583:	48 89 d0             	mov    %rdx,%rax
  8004212586:	48 01 c0             	add    %rax,%rax
  8004212589:	48 01 d0             	add    %rdx,%rax
  800421258c:	48 c1 e0 03          	shl    $0x3,%rax
  8004212590:	48 01 c8             	add    %rcx,%rax
  8004212593:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004212597:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421259b:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421259e:	48 63 c9             	movslq %ecx,%rcx
  80042125a1:	48 83 c1 01          	add    $0x1,%rcx
  80042125a5:	48 c1 e1 04          	shl    $0x4,%rcx
  80042125a9:	48 01 ca             	add    %rcx,%rdx
  80042125ac:	48 83 c2 02          	add    $0x2,%rdx
  80042125b0:	66 89 02             	mov    %ax,(%rdx)
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  80042125b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042125b7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042125bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042125be:	48 63 d0             	movslq %eax,%rdx
  80042125c1:	48 89 d0             	mov    %rdx,%rax
  80042125c4:	48 01 c0             	add    %rax,%rax
  80042125c7:	48 01 d0             	add    %rdx,%rax
  80042125ca:	48 c1 e0 03          	shl    $0x3,%rax
  80042125ce:	48 01 c8             	add    %rcx,%rax
  80042125d1:	48 8b 40 08          	mov    0x8(%rax),%rax
		reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
		reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
  80042125d5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042125d9:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042125dc:	48 63 c9             	movslq %ecx,%rcx
  80042125df:	48 83 c1 01          	add    $0x1,%rcx
  80042125e3:	48 c1 e1 04          	shl    $0x4,%rcx
  80042125e7:	48 01 ca             	add    %rcx,%rdx
  80042125ea:	48 83 c2 08          	add    $0x8,%rdx
  80042125ee:	48 89 02             	mov    %rax,(%rdx)
  80042125f1:	eb 01                	jmp    80042125f4 <dwarf_get_fde_info_for_all_regs+0x2fc>
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {

		/* Do not overwrite CFA column */
		if (i == cfa)
			continue;
  80042125f3:	90                   	nop

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
	     i++) {
  80042125f4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
	}

	/*
	 * Copy other columns.
	 */
	for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042125f8:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  80042125fc:	7f 14                	jg     8004212612 <dwarf_get_fde_info_for_all_regs+0x31a>
  80042125fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212602:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8004212606:	0f b7 c0             	movzwl %ax,%eax
  8004212609:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421260c:	0f 8f e1 fe ff ff    	jg     80042124f3 <dwarf_get_fde_info_for_all_regs+0x1fb>
		reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
		reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
	}

	if (row_pc) *row_pc = pc;
  8004212612:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004212617:	74 0b                	je     8004212624 <dwarf_get_fde_info_for_all_regs+0x32c>
  8004212619:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421261d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212621:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLV_OK);
  8004212624:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212629:	c9                   	leaveq 
  800421262a:	c3                   	retq   

000000800421262b <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  800421262b:	55                   	push   %rbp
  800421262c:	48 89 e5             	mov    %rsp,%rbp
  800421262f:	48 83 ec 40          	sub    $0x40,%rsp
  8004212633:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212637:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421263b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421263f:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004212643:	44 89 c0             	mov    %r8d,%eax
  8004212646:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  800421264a:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  800421264d:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004212651:	75 0a                	jne    800421265d <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004212653:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212658:	e9 f8 01 00 00       	jmpq   8004212855 <_dwarf_frame_read_lsb_encoded+0x22a>

	application = encode & 0xf0;
  800421265d:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004212661:	83 e0 f0             	and    $0xfffffff0,%eax
  8004212664:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  8004212667:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  800421266b:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421266f:	83 f8 0c             	cmp    $0xc,%eax
  8004212672:	0f 87 84 01 00 00    	ja     80042127fc <_dwarf_frame_read_lsb_encoded+0x1d1>
  8004212678:	89 c0                	mov    %eax,%eax
  800421267a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004212681:	00 
  8004212682:	48 b8 80 86 21 04 80 	movabs $0x8004218680,%rax
  8004212689:	00 00 00 
  800421268c:	48 01 d0             	add    %rdx,%rax
  800421268f:	48 8b 00             	mov    (%rax),%rax
  8004212692:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  8004212694:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212698:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421269c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042126a0:	8b 52 28             	mov    0x28(%rdx),%edx
  80042126a3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042126a7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042126ab:	48 89 cf             	mov    %rcx,%rdi
  80042126ae:	ff d0                	callq  *%rax
  80042126b0:	48 89 c2             	mov    %rax,%rdx
  80042126b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042126b7:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042126ba:	e9 44 01 00 00       	jmpq   8004212803 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  80042126bf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042126c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042126c7:	48 89 d6             	mov    %rdx,%rsi
  80042126ca:	48 89 c7             	mov    %rax,%rdi
  80042126cd:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  80042126d4:	00 00 00 
  80042126d7:	ff d0                	callq  *%rax
  80042126d9:	48 89 c2             	mov    %rax,%rdx
  80042126dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042126e0:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042126e3:	e9 1b 01 00 00       	jmpq   8004212803 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  80042126e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042126ec:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042126f0:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042126f4:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042126f8:	ba 02 00 00 00       	mov    $0x2,%edx
  80042126fd:	48 89 cf             	mov    %rcx,%rdi
  8004212700:	ff d0                	callq  *%rax
  8004212702:	48 89 c2             	mov    %rax,%rdx
  8004212705:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212709:	48 89 10             	mov    %rdx,(%rax)
		break;
  800421270c:	e9 f2 00 00 00       	jmpq   8004212803 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  8004212711:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212715:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212719:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421271d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212721:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212726:	48 89 cf             	mov    %rcx,%rdi
  8004212729:	ff d0                	callq  *%rax
  800421272b:	48 89 c2             	mov    %rax,%rdx
  800421272e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212732:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004212735:	e9 c9 00 00 00       	jmpq   8004212803 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  800421273a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421273e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212742:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212746:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421274a:	ba 08 00 00 00       	mov    $0x8,%edx
  800421274f:	48 89 cf             	mov    %rcx,%rdi
  8004212752:	ff d0                	callq  *%rax
  8004212754:	48 89 c2             	mov    %rax,%rdx
  8004212757:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421275b:	48 89 10             	mov    %rdx,(%rax)
		break;
  800421275e:	e9 a0 00 00 00       	jmpq   8004212803 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004212763:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212767:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421276b:	48 89 d6             	mov    %rdx,%rsi
  800421276e:	48 89 c7             	mov    %rax,%rdi
  8004212771:	48 b8 eb f6 20 04 80 	movabs $0x800420f6eb,%rax
  8004212778:	00 00 00 
  800421277b:	ff d0                	callq  *%rax
  800421277d:	48 89 c2             	mov    %rax,%rdx
  8004212780:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212784:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004212787:	eb 7a                	jmp    8004212803 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  8004212789:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421278d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212791:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004212795:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212799:	ba 02 00 00 00       	mov    $0x2,%edx
  800421279e:	48 89 cf             	mov    %rcx,%rdi
  80042127a1:	ff d0                	callq  *%rax
  80042127a3:	48 0f bf d0          	movswq %ax,%rdx
  80042127a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042127ab:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042127ae:	eb 53                	jmp    8004212803 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  80042127b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127b4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042127b8:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042127bc:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042127c0:	ba 04 00 00 00       	mov    $0x4,%edx
  80042127c5:	48 89 cf             	mov    %rcx,%rdi
  80042127c8:	ff d0                	callq  *%rax
  80042127ca:	48 63 d0             	movslq %eax,%rdx
  80042127cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042127d1:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042127d4:	eb 2d                	jmp    8004212803 <_dwarf_frame_read_lsb_encoded+0x1d8>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  80042127d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127da:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042127de:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042127e2:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042127e6:	ba 08 00 00 00       	mov    $0x8,%edx
  80042127eb:	48 89 cf             	mov    %rcx,%rdi
  80042127ee:	ff d0                	callq  *%rax
  80042127f0:	48 89 c2             	mov    %rax,%rdx
  80042127f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042127f7:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042127fa:	eb 07                	jmp    8004212803 <_dwarf_frame_read_lsb_encoded+0x1d8>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  80042127fc:	b8 14 00 00 00       	mov    $0x14,%eax
  8004212801:	eb 52                	jmp    8004212855 <_dwarf_frame_read_lsb_encoded+0x22a>
	}

	if (application == DW_EH_PE_pcrel) {
  8004212803:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  8004212807:	75 47                	jne    8004212850 <_dwarf_frame_read_lsb_encoded+0x225>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  8004212809:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421280d:	83 f8 01             	cmp    $0x1,%eax
  8004212810:	7c 3d                	jl     800421284f <_dwarf_frame_read_lsb_encoded+0x224>
  8004212812:	83 f8 04             	cmp    $0x4,%eax
  8004212815:	7e 0a                	jle    8004212821 <_dwarf_frame_read_lsb_encoded+0x1f6>
  8004212817:	83 e8 09             	sub    $0x9,%eax
  800421281a:	83 f8 03             	cmp    $0x3,%eax
  800421281d:	77 30                	ja     800421284f <_dwarf_frame_read_lsb_encoded+0x224>
  800421281f:	eb 17                	jmp    8004212838 <_dwarf_frame_read_lsb_encoded+0x20d>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004212821:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212825:	48 8b 10             	mov    (%rax),%rdx
  8004212828:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421282c:	48 01 c2             	add    %rax,%rdx
  800421282f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212833:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004212836:	eb 18                	jmp    8004212850 <_dwarf_frame_read_lsb_encoded+0x225>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  8004212838:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421283c:	48 8b 10             	mov    (%rax),%rdx
  800421283f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212843:	48 01 c2             	add    %rax,%rdx
  8004212846:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421284a:	48 89 10             	mov    %rdx,(%rax)
			break;
  800421284d:	eb 01                	jmp    8004212850 <_dwarf_frame_read_lsb_encoded+0x225>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  800421284f:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004212850:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212855:	c9                   	leaveq 
  8004212856:	c3                   	retq   

0000008004212857 <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  8004212857:	55                   	push   %rbp
  8004212858:	48 89 e5             	mov    %rsp,%rbp
  800421285b:	48 83 ec 50          	sub    $0x50,%rsp
  800421285f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212863:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212867:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  800421286b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421286f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212873:	48 85 c0             	test   %rax,%rax
  8004212876:	74 0f                	je     8004212887 <_dwarf_frame_parse_lsb_cie_augment+0x30>
  8004212878:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421287c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212880:	0f b6 00             	movzbl (%rax),%eax
  8004212883:	3c 7a                	cmp    $0x7a,%al
  8004212885:	74 35                	je     80042128bc <_dwarf_frame_parse_lsb_cie_augment+0x65>
  8004212887:	48 b9 e8 86 21 04 80 	movabs $0x80042186e8,%rcx
  800421288e:	00 00 00 
  8004212891:	48 ba 67 85 21 04 80 	movabs $0x8004218567,%rdx
  8004212898:	00 00 00 
  800421289b:	be 4a 02 00 00       	mov    $0x24a,%esi
  80042128a0:	48 bf 7c 85 21 04 80 	movabs $0x800421857c,%rdi
  80042128a7:	00 00 00 
  80042128aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042128af:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042128b6:	00 00 00 
  80042128b9:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  80042128bc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042128c0:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042128c4:	48 83 c0 01          	add    $0x1,%rax
  80042128c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  80042128cc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042128d0:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042128d4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  80042128d8:	e9 b4 00 00 00       	jmpq   8004212991 <_dwarf_frame_parse_lsb_cie_augment+0x13a>
		switch (*aug_p) {
  80042128dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042128e1:	0f b6 00             	movzbl (%rax),%eax
  80042128e4:	0f b6 c0             	movzbl %al,%eax
  80042128e7:	83 f8 50             	cmp    $0x50,%eax
  80042128ea:	74 18                	je     8004212904 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  80042128ec:	83 f8 52             	cmp    $0x52,%eax
  80042128ef:	74 7c                	je     800421296d <_dwarf_frame_parse_lsb_cie_augment+0x116>
  80042128f1:	83 f8 4c             	cmp    $0x4c,%eax
  80042128f4:	0f 85 8b 00 00 00    	jne    8004212985 <_dwarf_frame_parse_lsb_cie_augment+0x12e>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  80042128fa:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  80042128ff:	e9 88 00 00 00       	jmpq   800421298c <_dwarf_frame_parse_lsb_cie_augment+0x135>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  8004212904:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212908:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421290c:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004212910:	0f b6 00             	movzbl (%rax),%eax
  8004212913:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  8004212916:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800421291d:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  800421291e:	0f b6 7d ef          	movzbl -0x11(%rbp),%edi
  8004212922:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004212926:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421292a:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  800421292e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212932:	48 83 ec 08          	sub    $0x8,%rsp
  8004212936:	ff 75 b8             	pushq  -0x48(%rbp)
  8004212939:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421293f:	41 89 f8             	mov    %edi,%r8d
  8004212942:	48 89 c7             	mov    %rax,%rdi
  8004212945:	48 b8 2b 26 21 04 80 	movabs $0x800421262b,%rax
  800421294c:	00 00 00 
  800421294f:	ff d0                	callq  *%rax
  8004212951:	48 83 c4 10          	add    $0x10,%rsp
  8004212955:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  8004212958:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800421295c:	74 05                	je     8004212963 <_dwarf_frame_parse_lsb_cie_augment+0x10c>
				return (ret);
  800421295e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004212961:	eb 42                	jmp    80042129a5 <_dwarf_frame_parse_lsb_cie_augment+0x14e>
			augdata_p += offset;
  8004212963:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212967:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  800421296b:	eb 1f                	jmp    800421298c <_dwarf_frame_parse_lsb_cie_augment+0x135>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  800421296d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212971:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004212975:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004212979:	0f b6 10             	movzbl (%rax),%edx
  800421297c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212980:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004212983:	eb 07                	jmp    800421298c <_dwarf_frame_parse_lsb_cie_augment+0x135>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004212985:	b8 14 00 00 00       	mov    $0x14,%eax
  800421298a:	eb 19                	jmp    80042129a5 <_dwarf_frame_parse_lsb_cie_augment+0x14e>
		}
		aug_p++;
  800421298c:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  8004212991:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212995:	0f b6 00             	movzbl (%rax),%eax
  8004212998:	84 c0                	test   %al,%al
  800421299a:	0f 85 3d ff ff ff    	jne    80042128dd <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  80042129a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042129a5:	c9                   	leaveq 
  80042129a6:	c3                   	retq   

00000080042129a7 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  80042129a7:	55                   	push   %rbp
  80042129a8:	48 89 e5             	mov    %rsp,%rbp
  80042129ab:	48 83 ec 60          	sub    $0x60,%rsp
  80042129af:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042129b3:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042129b7:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042129bb:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042129bf:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  80042129c3:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042129c8:	75 35                	jne    80042129ff <_dwarf_frame_set_cie+0x58>
  80042129ca:	48 b9 1d 87 21 04 80 	movabs $0x800421871d,%rcx
  80042129d1:	00 00 00 
  80042129d4:	48 ba 67 85 21 04 80 	movabs $0x8004218567,%rdx
  80042129db:	00 00 00 
  80042129de:	be 7b 02 00 00       	mov    $0x27b,%esi
  80042129e3:	48 bf 7c 85 21 04 80 	movabs $0x800421857c,%rdi
  80042129ea:	00 00 00 
  80042129ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042129f2:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042129f9:	00 00 00 
  80042129fc:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  80042129ff:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212a03:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004212a07:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a0b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212a0f:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  8004212a12:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212a16:	48 8b 10             	mov    (%rax),%rdx
  8004212a19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a1d:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212a21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212a25:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212a29:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212a2d:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212a31:	48 89 d7             	mov    %rdx,%rdi
  8004212a34:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004212a38:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212a3d:	48 89 ce             	mov    %rcx,%rsi
  8004212a40:	ff d0                	callq  *%rax
  8004212a42:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004212a46:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212a4b:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004212a4f:	75 2e                	jne    8004212a7f <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  8004212a51:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004212a58:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212a5c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212a60:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212a64:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212a68:	48 89 d7             	mov    %rdx,%rdi
  8004212a6b:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004212a6f:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212a74:	48 89 ce             	mov    %rcx,%rsi
  8004212a77:	ff d0                	callq  *%rax
  8004212a79:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212a7d:	eb 07                	jmp    8004212a86 <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  8004212a7f:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004212a86:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212a8a:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004212a8e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212a92:	48 8b 00             	mov    (%rax),%rax
  8004212a95:	48 29 c2             	sub    %rax,%rdx
  8004212a98:	48 89 d0             	mov    %rdx,%rax
  8004212a9b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212a9f:	73 0a                	jae    8004212aab <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004212aa1:	b8 12 00 00 00       	mov    $0x12,%eax
  8004212aa6:	e9 7e 03 00 00       	jmpq   8004212e29 <_dwarf_frame_set_cie+0x482>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  8004212aab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212aaf:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ab3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212ab7:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212abb:	48 89 d7             	mov    %rdx,%rdi
  8004212abe:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004212ac1:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004212ac5:	48 89 ce             	mov    %rcx,%rsi
  8004212ac8:	ff d0                	callq  *%rax
	cie->cie_length = length;
  8004212aca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ace:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212ad2:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004212ad6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ada:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ade:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212ae2:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212ae6:	48 89 d7             	mov    %rdx,%rdi
  8004212ae9:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004212aed:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212af2:	48 89 ce             	mov    %rcx,%rsi
  8004212af5:	ff d0                	callq  *%rax
  8004212af7:	89 c2                	mov    %eax,%edx
  8004212af9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212afd:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212b01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b05:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212b09:	66 83 f8 01          	cmp    $0x1,%ax
  8004212b0d:	74 26                	je     8004212b35 <_dwarf_frame_set_cie+0x18e>
  8004212b0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b13:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212b17:	66 83 f8 03          	cmp    $0x3,%ax
  8004212b1b:	74 18                	je     8004212b35 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  8004212b1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b21:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212b25:	66 83 f8 04          	cmp    $0x4,%ax
  8004212b29:	74 0a                	je     8004212b35 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004212b2b:	b8 16 00 00 00       	mov    $0x16,%eax
  8004212b30:	e9 f4 02 00 00       	jmpq   8004212e29 <_dwarf_frame_set_cie+0x482>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212b35:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212b39:	48 8b 10             	mov    (%rax),%rdx
  8004212b3c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212b40:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212b44:	48 01 d0             	add    %rdx,%rax
  8004212b47:	48 89 c2             	mov    %rax,%rdx
  8004212b4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b4e:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004212b52:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212b56:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212b5a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004212b5e:	90                   	nop
  8004212b5f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212b63:	48 8b 00             	mov    (%rax),%rax
  8004212b66:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004212b6a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212b6e:	48 89 0a             	mov    %rcx,(%rdx)
  8004212b71:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212b75:	48 01 d0             	add    %rdx,%rax
  8004212b78:	0f b6 00             	movzbl (%rax),%eax
  8004212b7b:	84 c0                	test   %al,%al
  8004212b7d:	75 e0                	jne    8004212b5f <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004212b7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b83:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212b87:	0f b6 00             	movzbl (%rax),%eax
  8004212b8a:	84 c0                	test   %al,%al
  8004212b8c:	74 48                	je     8004212bd6 <_dwarf_frame_set_cie+0x22f>
  8004212b8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b92:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212b96:	0f b6 00             	movzbl (%rax),%eax
  8004212b99:	3c 7a                	cmp    $0x7a,%al
  8004212b9b:	74 39                	je     8004212bd6 <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004212b9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ba1:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004212ba5:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212ba9:	75 07                	jne    8004212bb2 <_dwarf_frame_set_cie+0x20b>
  8004212bab:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212bb0:	eb 05                	jmp    8004212bb7 <_dwarf_frame_set_cie+0x210>
  8004212bb2:	ba 0c 00 00 00       	mov    $0xc,%edx
  8004212bb7:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  8004212bba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212bbe:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004212bc2:	48 01 c2             	add    %rax,%rdx
  8004212bc5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212bc9:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  8004212bcc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212bd1:	e9 53 02 00 00       	jmpq   8004212e29 <_dwarf_frame_set_cie+0x482>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004212bd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212bda:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212bde:	48 be 25 87 21 04 80 	movabs $0x8004218725,%rsi
  8004212be5:	00 00 00 
  8004212be8:	48 89 c7             	mov    %rax,%rdi
  8004212beb:	48 b8 a2 f0 20 04 80 	movabs $0x800420f0a2,%rax
  8004212bf2:	00 00 00 
  8004212bf5:	ff d0                	callq  *%rax
  8004212bf7:	48 85 c0             	test   %rax,%rax
  8004212bfa:	74 2e                	je     8004212c2a <_dwarf_frame_set_cie+0x283>
		cie->cie_ehdata = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  8004212bfc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212c00:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c04:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212c08:	8b 52 28             	mov    0x28(%rdx),%edx
  8004212c0b:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004212c0f:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  8004212c13:	48 89 cf             	mov    %rcx,%rdi
  8004212c16:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004212c1a:	48 89 ce             	mov    %rcx,%rsi
  8004212c1d:	ff d0                	callq  *%rax
  8004212c1f:	48 89 c2             	mov    %rax,%rdx
  8004212c22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c26:	48 89 50 30          	mov    %rdx,0x30(%rax)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212c2a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212c2e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212c32:	48 89 c2             	mov    %rax,%rdx
  8004212c35:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212c39:	48 89 c6             	mov    %rax,%rsi
  8004212c3c:	48 89 d7             	mov    %rdx,%rdi
  8004212c3f:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  8004212c46:	00 00 00 
  8004212c49:	ff d0                	callq  *%rax
  8004212c4b:	48 89 c2             	mov    %rax,%rdx
  8004212c4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c52:	48 89 50 38          	mov    %rdx,0x38(%rax)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212c56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212c5a:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212c5e:	48 89 c2             	mov    %rax,%rdx
  8004212c61:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212c65:	48 89 c6             	mov    %rax,%rsi
  8004212c68:	48 89 d7             	mov    %rdx,%rdi
  8004212c6b:	48 b8 eb f6 20 04 80 	movabs $0x800420f6eb,%rax
  8004212c72:	00 00 00 
  8004212c75:	ff d0                	callq  *%rax
  8004212c77:	48 89 c2             	mov    %rax,%rdx
  8004212c7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c7e:	48 89 50 40          	mov    %rdx,0x40(%rax)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004212c82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c86:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212c8a:	66 83 f8 01          	cmp    $0x1,%ax
  8004212c8e:	75 2e                	jne    8004212cbe <_dwarf_frame_set_cie+0x317>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004212c90:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212c94:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c98:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212c9c:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212ca0:	48 89 d7             	mov    %rdx,%rdi
  8004212ca3:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004212ca7:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212cac:	48 89 ce             	mov    %rcx,%rsi
  8004212caf:	ff d0                	callq  *%rax
  8004212cb1:	48 89 c2             	mov    %rax,%rdx
  8004212cb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212cb8:	48 89 50 48          	mov    %rdx,0x48(%rax)
  8004212cbc:	eb 2c                	jmp    8004212cea <_dwarf_frame_set_cie+0x343>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212cbe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212cc2:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212cc6:	48 89 c2             	mov    %rax,%rdx
  8004212cc9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212ccd:	48 89 c6             	mov    %rax,%rsi
  8004212cd0:	48 89 d7             	mov    %rdx,%rdi
  8004212cd3:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  8004212cda:	00 00 00 
  8004212cdd:	ff d0                	callq  *%rax
  8004212cdf:	48 89 c2             	mov    %rax,%rdx
  8004212ce2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ce6:	48 89 50 48          	mov    %rdx,0x48(%rax)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004212cea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212cee:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212cf2:	0f b6 00             	movzbl (%rax),%eax
  8004212cf5:	3c 7a                	cmp    $0x7a,%al
  8004212cf7:	0f 85 99 00 00 00    	jne    8004212d96 <_dwarf_frame_set_cie+0x3ef>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004212cfd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d01:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212d05:	48 89 c2             	mov    %rax,%rdx
  8004212d08:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212d0c:	48 89 c6             	mov    %rax,%rsi
  8004212d0f:	48 89 d7             	mov    %rdx,%rdi
  8004212d12:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  8004212d19:	00 00 00 
  8004212d1c:	ff d0                	callq  *%rax
  8004212d1e:	48 89 c2             	mov    %rax,%rdx
  8004212d21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d25:	48 89 50 50          	mov    %rdx,0x50(%rax)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212d29:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212d2d:	48 8b 10             	mov    (%rax),%rdx
  8004212d30:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d34:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212d38:	48 01 d0             	add    %rdx,%rax
  8004212d3b:	48 89 c2             	mov    %rax,%rdx
  8004212d3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d42:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004212d46:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212d4a:	48 8b 10             	mov    (%rax),%rdx
  8004212d4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d51:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004212d55:	48 01 c2             	add    %rax,%rdx
  8004212d58:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212d5c:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004212d5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d63:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004212d67:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212d6b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212d6f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d73:	48 89 ce             	mov    %rcx,%rsi
  8004212d76:	48 89 c7             	mov    %rax,%rdi
  8004212d79:	48 b8 57 28 21 04 80 	movabs $0x8004212857,%rax
  8004212d80:	00 00 00 
  8004212d83:	ff d0                	callq  *%rax
  8004212d85:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004212d88:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004212d8c:	74 08                	je     8004212d96 <_dwarf_frame_set_cie+0x3ef>
			return (ret);
  8004212d8e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004212d91:	e9 93 00 00 00       	jmpq   8004212e29 <_dwarf_frame_set_cie+0x482>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212d96:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212d9a:	48 8b 10             	mov    (%rax),%rdx
  8004212d9d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212da1:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212da5:	48 01 d0             	add    %rdx,%rax
  8004212da8:	48 89 c2             	mov    %rax,%rdx
  8004212dab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212daf:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004212db3:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212db7:	75 2a                	jne    8004212de3 <_dwarf_frame_set_cie+0x43c>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004212db9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212dbd:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212dc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212dc5:	48 01 c2             	add    %rax,%rdx
  8004212dc8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212dcc:	48 8b 00             	mov    (%rax),%rax
  8004212dcf:	48 f7 d8             	neg    %rax
  8004212dd2:	48 01 d0             	add    %rdx,%rax
  8004212dd5:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004212dd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ddd:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004212de1:	eb 28                	jmp    8004212e0b <_dwarf_frame_set_cie+0x464>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004212de3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212de7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212deb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212def:	48 01 c2             	add    %rax,%rdx
  8004212df2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212df6:	48 8b 00             	mov    (%rax),%rax
  8004212df9:	48 f7 d8             	neg    %rax
  8004212dfc:	48 01 d0             	add    %rdx,%rax
  8004212dff:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004212e03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e07:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004212e0b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e0f:	48 8b 10             	mov    (%rax),%rdx
  8004212e12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e16:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004212e1a:	48 01 c2             	add    %rax,%rdx
  8004212e1d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212e21:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004212e24:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212e29:	c9                   	leaveq 
  8004212e2a:	c3                   	retq   

0000008004212e2b <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004212e2b:	55                   	push   %rbp
  8004212e2c:	48 89 e5             	mov    %rsp,%rbp
  8004212e2f:	48 83 ec 60          	sub    $0x60,%rsp
  8004212e33:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212e37:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212e3b:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212e3f:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004212e43:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004212e47:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004212e4b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212e4f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004212e53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e57:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212e5b:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004212e5e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212e62:	48 8b 10             	mov    (%rax),%rdx
  8004212e65:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e69:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004212e6d:	48 01 d0             	add    %rdx,%rax
  8004212e70:	48 89 c2             	mov    %rax,%rdx
  8004212e73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e77:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004212e7b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212e7f:	48 8b 10             	mov    (%rax),%rdx
  8004212e82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e86:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212e8a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e8e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212e92:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212e96:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212e9a:	48 89 d7             	mov    %rdx,%rdi
  8004212e9d:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212ea1:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212ea6:	48 89 ce             	mov    %rcx,%rsi
  8004212ea9:	ff d0                	callq  *%rax
  8004212eab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004212eaf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212eb4:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004212eb8:	75 2e                	jne    8004212ee8 <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  8004212eba:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004212ec1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ec5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ec9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212ecd:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212ed1:	48 89 d7             	mov    %rdx,%rdi
  8004212ed4:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212ed8:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212edd:	48 89 ce             	mov    %rcx,%rsi
  8004212ee0:	ff d0                	callq  *%rax
  8004212ee2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212ee6:	eb 07                	jmp    8004212eef <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  8004212ee8:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004212eef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ef3:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004212ef7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212efb:	48 8b 00             	mov    (%rax),%rax
  8004212efe:	48 29 c2             	sub    %rax,%rdx
  8004212f01:	48 89 d0             	mov    %rdx,%rax
  8004212f04:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212f08:	73 0a                	jae    8004212f14 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004212f0a:	b8 12 00 00 00       	mov    $0x12,%eax
  8004212f0f:	e9 fb 02 00 00       	jmpq   800421320f <_dwarf_frame_set_fde+0x3e4>
	}

	fde->fde_length = length;
  8004212f14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f18:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212f1c:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004212f20:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004212f24:	74 61                	je     8004212f87 <_dwarf_frame_set_fde+0x15c>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004212f26:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f2a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212f2e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212f32:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212f36:	48 89 d7             	mov    %rdx,%rdi
  8004212f39:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212f3d:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212f42:	48 89 ce             	mov    %rcx,%rsi
  8004212f45:	ff d0                	callq  *%rax
  8004212f47:	48 89 c2             	mov    %rax,%rdx
  8004212f4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f4e:	48 89 50 28          	mov    %rdx,0x28(%rax)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004212f52:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212f56:	48 8b 10             	mov    (%rax),%rdx
  8004212f59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f5d:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212f61:	48 29 c2             	sub    %rax,%rdx
  8004212f64:	48 89 d0             	mov    %rdx,%rax
  8004212f67:	48 83 e8 04          	sub    $0x4,%rax
  8004212f6b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004212f6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f73:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212f77:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212f7b:	75 40                	jne    8004212fbd <_dwarf_frame_set_fde+0x192>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004212f7d:	b8 13 00 00 00       	mov    $0x13,%eax
  8004212f82:	e9 88 02 00 00       	jmpq   800421320f <_dwarf_frame_set_fde+0x3e4>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004212f87:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f8b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212f8f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212f93:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004212f97:	48 89 d7             	mov    %rdx,%rdi
  8004212f9a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004212f9d:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212fa1:	48 89 ce             	mov    %rcx,%rsi
  8004212fa4:	ff d0                	callq  *%rax
  8004212fa6:	48 89 c2             	mov    %rax,%rdx
  8004212fa9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fad:	48 89 50 28          	mov    %rdx,0x28(%rax)
		cieoff = fde->fde_cieoff;
  8004212fb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fb5:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212fb9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004212fbd:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004212fc1:	0f 84 e2 00 00 00    	je     80042130a9 <_dwarf_frame_set_fde+0x27e>
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004212fc7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212fcb:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212fcf:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212fd3:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004212fd6:	48 8d 3c 02          	lea    (%rdx,%rax,1),%rdi
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004212fda:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212fde:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004212fe2:	0f b6 c8             	movzbl %al,%ecx
						    (uint8_t *)dbg->dbg_eh_offset,
  8004212fe5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212fe9:	48 8b 40 38          	mov    0x38(%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004212fed:	49 89 c2             	mov    %rax,%r10
  8004212ff0:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212ff4:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004212ff8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ffc:	48 83 ec 08          	sub    $0x8,%rsp
  8004213000:	ff 75 10             	pushq  0x10(%rbp)
  8004213003:	49 89 f9             	mov    %rdi,%r9
  8004213006:	41 89 c8             	mov    %ecx,%r8d
  8004213009:	48 89 d1             	mov    %rdx,%rcx
  800421300c:	4c 89 d2             	mov    %r10,%rdx
  800421300f:	48 89 c7             	mov    %rax,%rdi
  8004213012:	48 b8 2b 26 21 04 80 	movabs $0x800421262b,%rax
  8004213019:	00 00 00 
  800421301c:	ff d0                	callq  *%rax
  800421301e:	48 83 c4 10          	add    $0x10,%rsp
  8004213022:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004213025:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213029:	74 08                	je     8004213033 <_dwarf_frame_set_fde+0x208>
			return (ret);
  800421302b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421302e:	e9 dc 01 00 00       	jmpq   800421320f <_dwarf_frame_set_fde+0x3e4>
		fde->fde_initloc = val;
  8004213033:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213037:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421303b:	48 89 50 30          	mov    %rdx,0x30(%rax)
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
  800421303f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213043:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213047:	0f b6 c8             	movzbl %al,%ecx
						    (uint8_t *)dbg->dbg_eh_offset,
  800421304a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421304e:	48 8b 40 38          	mov    0x38(%rax),%rax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004213052:	48 89 c7             	mov    %rax,%rdi
  8004213055:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004213059:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  800421305d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213061:	48 83 ec 08          	sub    $0x8,%rsp
  8004213065:	ff 75 10             	pushq  0x10(%rbp)
  8004213068:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421306e:	41 89 c8             	mov    %ecx,%r8d
  8004213071:	48 89 d1             	mov    %rdx,%rcx
  8004213074:	48 89 fa             	mov    %rdi,%rdx
  8004213077:	48 89 c7             	mov    %rax,%rdi
  800421307a:	48 b8 2b 26 21 04 80 	movabs $0x800421262b,%rax
  8004213081:	00 00 00 
  8004213084:	ff d0                	callq  *%rax
  8004213086:	48 83 c4 10          	add    $0x10,%rsp
  800421308a:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    (uint8_t *)dbg->dbg_eh_offset,
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  800421308d:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213091:	74 08                	je     800421309b <_dwarf_frame_set_fde+0x270>
			return (ret);
  8004213093:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213096:	e9 74 01 00 00       	jmpq   800421320f <_dwarf_frame_set_fde+0x3e4>
		fde->fde_adrange = val;
  800421309b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421309f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130a3:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042130a7:	eb 5c                	jmp    8004213105 <_dwarf_frame_set_fde+0x2da>
	} else {
		fde->fde_initloc = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042130a9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042130ad:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042130b1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042130b5:	8b 52 28             	mov    0x28(%rdx),%edx
  80042130b8:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042130bc:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  80042130c0:	48 89 cf             	mov    %rcx,%rdi
  80042130c3:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042130c7:	48 89 ce             	mov    %rcx,%rsi
  80042130ca:	ff d0                	callq  *%rax
  80042130cc:	48 89 c2             	mov    %rax,%rdx
  80042130cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130d3:	48 89 50 30          	mov    %rdx,0x30(%rax)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read((uint8_t *)dbg->dbg_eh_offset, off,
  80042130d7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042130db:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042130df:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042130e3:	8b 52 28             	mov    0x28(%rdx),%edx
  80042130e6:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042130ea:	48 8b 49 38          	mov    0x38(%rcx),%rcx
  80042130ee:	48 89 cf             	mov    %rcx,%rdi
  80042130f1:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042130f5:	48 89 ce             	mov    %rcx,%rsi
  80042130f8:	ff d0                	callq  *%rax
  80042130fa:	48 89 c2             	mov    %rax,%rdx
  80042130fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213101:	48 89 50 38          	mov    %rdx,0x38(%rax)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004213105:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213109:	74 71                	je     800421317c <_dwarf_frame_set_fde+0x351>
  800421310b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421310f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213113:	0f b6 00             	movzbl (%rax),%eax
  8004213116:	3c 7a                	cmp    $0x7a,%al
  8004213118:	75 62                	jne    800421317c <_dwarf_frame_set_fde+0x351>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  800421311a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421311e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213122:	48 89 c2             	mov    %rax,%rdx
  8004213125:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213129:	48 89 c6             	mov    %rax,%rsi
  800421312c:	48 89 d7             	mov    %rdx,%rdi
  800421312f:	48 b8 8f f7 20 04 80 	movabs $0x800420f78f,%rax
  8004213136:	00 00 00 
  8004213139:	ff d0                	callq  *%rax
  800421313b:	48 89 c2             	mov    %rax,%rdx
  800421313e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213142:	48 89 50 40          	mov    %rdx,0x40(%rax)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213146:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421314a:	48 8b 10             	mov    (%rax),%rdx
  800421314d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213151:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213155:	48 01 d0             	add    %rdx,%rax
  8004213158:	48 89 c2             	mov    %rax,%rdx
  800421315b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421315f:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004213163:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213167:	48 8b 10             	mov    (%rax),%rdx
  800421316a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421316e:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004213172:	48 01 c2             	add    %rax,%rdx
  8004213175:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213179:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  800421317c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213180:	48 8b 10             	mov    (%rax),%rdx
  8004213183:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213187:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421318b:	48 01 d0             	add    %rdx,%rax
  800421318e:	48 89 c2             	mov    %rax,%rdx
  8004213191:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213195:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004213199:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  800421319d:	75 2a                	jne    80042131c9 <_dwarf_frame_set_fde+0x39e>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  800421319f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131a3:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042131a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042131ab:	48 01 c2             	add    %rax,%rdx
  80042131ae:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042131b2:	48 8b 00             	mov    (%rax),%rax
  80042131b5:	48 f7 d8             	neg    %rax
  80042131b8:	48 01 d0             	add    %rdx,%rax
  80042131bb:	48 8d 50 04          	lea    0x4(%rax),%rdx
  80042131bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131c3:	48 89 50 58          	mov    %rdx,0x58(%rax)
  80042131c7:	eb 28                	jmp    80042131f1 <_dwarf_frame_set_fde+0x3c6>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  80042131c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131cd:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042131d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042131d5:	48 01 c2             	add    %rax,%rdx
  80042131d8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042131dc:	48 8b 00             	mov    (%rax),%rax
  80042131df:	48 f7 d8             	neg    %rax
  80042131e2:	48 01 d0             	add    %rdx,%rax
  80042131e5:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80042131e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131ed:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  80042131f1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042131f5:	48 8b 10             	mov    (%rax),%rdx
  80042131f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042131fc:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213200:	48 01 c2             	add    %rax,%rdx
  8004213203:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213207:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  800421320a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421320f:	c9                   	leaveq 
  8004213210:	c3                   	retq   

0000008004213211 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004213211:	55                   	push   %rbp
  8004213212:	48 89 e5             	mov    %rsp,%rbp
  8004213215:	48 83 ec 20          	sub    $0x20,%rsp
  8004213219:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421321d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	Dwarf_Regtable3 *rt = &global_rt_table;
  8004213221:	48 b8 a0 36 36 04 80 	movabs $0x80043636a0,%rax
  8004213228:	00 00 00 
  800421322b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	if (dbg->dbg_internal_reg_table != NULL)
  800421322f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213233:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213237:	48 85 c0             	test   %rax,%rax
  800421323a:	74 07                	je     8004213243 <_dwarf_frame_interal_table_init+0x32>
		return (DW_DLE_NONE);
  800421323c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213241:	eb 33                	jmp    8004213276 <_dwarf_frame_interal_table_init+0x65>

	rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004213243:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213247:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  800421324b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421324f:	66 89 50 18          	mov    %dx,0x18(%rax)
	rt->rt3_rules = global_rules;
  8004213253:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213257:	48 b9 60 3f 36 04 80 	movabs $0x8004363f60,%rcx
  800421325e:	00 00 00 
  8004213261:	48 89 48 20          	mov    %rcx,0x20(%rax)

	dbg->dbg_internal_reg_table = rt;
  8004213265:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213269:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421326d:	48 89 50 58          	mov    %rdx,0x58(%rax)

	return (DW_DLE_NONE);
  8004213271:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213276:	c9                   	leaveq 
  8004213277:	c3                   	retq   

0000008004213278 <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
		    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  8004213278:	55                   	push   %rbp
  8004213279:	48 89 e5             	mov    %rsp,%rbp
  800421327c:	48 83 ec 50          	sub    $0x50,%rsp
  8004213280:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213284:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004213287:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800421328b:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  800421328f:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004213296:	00 00 00 
  8004213299:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  800421329d:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  80042132a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042132a8:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042132ac:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  80042132b0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042132b4:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042132b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042132bc:	48 39 c2             	cmp    %rax,%rdx
  80042132bf:	0f 86 04 02 00 00    	jbe    80042134c9 <_dwarf_get_next_fde+0x251>
		entry_off = offset;
  80042132c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042132c9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  80042132cd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042132d1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042132d5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042132d9:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042132dd:	48 89 d7             	mov    %rdx,%rdi
  80042132e0:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  80042132e4:	ba 04 00 00 00       	mov    $0x4,%edx
  80042132e9:	48 89 ce             	mov    %rcx,%rsi
  80042132ec:	ff d0                	callq  *%rax
  80042132ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  80042132f2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042132f7:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042132fb:	75 2e                	jne    800421332b <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  80042132fd:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004213304:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213308:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421330c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213310:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213314:	48 89 d7             	mov    %rdx,%rdi
  8004213317:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800421331b:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213320:	48 89 ce             	mov    %rcx,%rsi
  8004213323:	ff d0                	callq  *%rax
  8004213325:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213329:	eb 07                	jmp    8004213332 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  800421332b:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  8004213332:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213336:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421333a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421333e:	48 29 c2             	sub    %rax,%rdx
  8004213341:	48 89 d0             	mov    %rdx,%rax
  8004213344:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213348:	72 0d                	jb     8004213357 <_dwarf_get_next_fde+0xdf>
  800421334a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421334f:	75 10                	jne    8004213361 <_dwarf_get_next_fde+0xe9>
  8004213351:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004213355:	75 0a                	jne    8004213361 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213357:	b8 12 00 00 00       	mov    $0x12,%eax
  800421335c:	e9 6d 01 00 00       	jmpq   80042134ce <_dwarf_get_next_fde+0x256>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004213361:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004213365:	74 11                	je     8004213378 <_dwarf_get_next_fde+0x100>
  8004213367:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421336c:	75 0a                	jne    8004213378 <_dwarf_get_next_fde+0x100>
			return(-1);
  800421336e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213373:	e9 56 01 00 00       	jmpq   80042134ce <_dwarf_get_next_fde+0x256>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  8004213378:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421337c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213380:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213384:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213388:	48 89 d7             	mov    %rdx,%rdi
  800421338b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421338e:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004213392:	48 89 ce             	mov    %rcx,%rsi
  8004213395:	ff d0                	callq  *%rax
  8004213397:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  800421339b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800421339f:	74 7c                	je     800421341d <_dwarf_get_next_fde+0x1a5>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  80042133a1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042133a6:	75 32                	jne    80042133da <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042133a8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133ac:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042133b0:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042133b4:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042133b8:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042133bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042133c0:	49 89 f8             	mov    %rdi,%r8
  80042133c3:	48 89 c7             	mov    %rax,%rdi
  80042133c6:	48 b8 a7 29 21 04 80 	movabs $0x80042129a7,%rax
  80042133cd:	00 00 00 
  80042133d0:	ff d0                	callq  *%rax
  80042133d2:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042133d5:	e9 ce 00 00 00       	jmpq   80042134a8 <_dwarf_get_next_fde+0x230>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  80042133da:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042133de:	48 8b 78 08          	mov    0x8(%rax),%rdi
  80042133e2:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042133e6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042133ea:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042133ee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042133f2:	48 83 ec 08          	sub    $0x8,%rsp
  80042133f6:	ff 75 b8             	pushq  -0x48(%rbp)
  80042133f9:	49 89 f9             	mov    %rdi,%r9
  80042133fc:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004213402:	48 89 c7             	mov    %rax,%rdi
  8004213405:	48 b8 2b 2e 21 04 80 	movabs $0x8004212e2b,%rax
  800421340c:	00 00 00 
  800421340f:	ff d0                	callq  *%rax
  8004213411:	48 83 c4 10          	add    $0x10,%rsp
  8004213415:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004213418:	e9 8b 00 00 00       	jmpq   80042134a8 <_dwarf_get_next_fde+0x230>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  800421341d:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213421:	75 0b                	jne    800421342e <_dwarf_get_next_fde+0x1b6>
  8004213423:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213428:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800421342c:	74 0d                	je     800421343b <_dwarf_get_next_fde+0x1c3>
  800421342e:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004213432:	75 36                	jne    800421346a <_dwarf_get_next_fde+0x1f2>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  8004213434:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  8004213439:	75 2f                	jne    800421346a <_dwarf_get_next_fde+0x1f2>
				ret = _dwarf_frame_set_cie(dbg, ds,
  800421343b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421343f:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004213443:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004213447:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800421344b:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800421344f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213453:	49 89 f8             	mov    %rdi,%r8
  8004213456:	48 89 c7             	mov    %rax,%rdi
  8004213459:	48 b8 a7 29 21 04 80 	movabs $0x80042129a7,%rax
  8004213460:	00 00 00 
  8004213463:	ff d0                	callq  *%rax
  8004213465:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004213468:	eb 3e                	jmp    80042134a8 <_dwarf_get_next_fde+0x230>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  800421346a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421346e:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004213472:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  8004213476:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421347a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421347e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213482:	48 83 ec 08          	sub    $0x8,%rsp
  8004213486:	ff 75 b8             	pushq  -0x48(%rbp)
  8004213489:	49 89 f9             	mov    %rdi,%r9
  800421348c:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004213492:	48 89 c7             	mov    %rax,%rdi
  8004213495:	48 b8 2b 2e 21 04 80 	movabs $0x8004212e2b,%rax
  800421349c:	00 00 00 
  800421349f:	ff d0                	callq  *%rax
  80042134a1:	48 83 c4 10          	add    $0x10,%rsp
  80042134a5:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  80042134a8:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  80042134ac:	74 07                	je     80042134b5 <_dwarf_get_next_fde+0x23d>
			return(-1);
  80042134ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042134b3:	eb 19                	jmp    80042134ce <_dwarf_get_next_fde+0x256>

		offset = entry_off;
  80042134b5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042134b9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  80042134bd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042134c1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042134c5:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  80042134c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042134ce:	c9                   	leaveq 
  80042134cf:	c3                   	retq   

00000080042134d0 <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  80042134d0:	55                   	push   %rbp
  80042134d1:	48 89 e5             	mov    %rsp,%rbp
  80042134d4:	48 83 ec 20          	sub    $0x20,%rsp
  80042134d8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042134dc:	89 f0                	mov    %esi,%eax
  80042134de:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Half old_value;

	old_value = dbg->dbg_frame_cfa_value;
  80042134e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042134e6:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042134ea:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
	dbg->dbg_frame_cfa_value = value;
  80042134ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042134f2:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80042134f6:	66 89 50 4c          	mov    %dx,0x4c(%rax)

	return (old_value);
  80042134fa:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  80042134fe:	c9                   	leaveq 
  80042134ff:	c3                   	retq   

0000008004213500 <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004213500:	55                   	push   %rbp
  8004213501:	48 89 e5             	mov    %rsp,%rbp
  8004213504:	48 83 ec 10          	sub    $0x10,%rsp
  8004213508:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421350c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  8004213510:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213515:	75 0a                	jne    8004213521 <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004213517:	b8 01 00 00 00       	mov    $0x1,%eax
  800421351c:	e9 85 00 00 00       	jmpq   80042135a6 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  8004213521:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213525:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004213529:	48 85 c0             	test   %rax,%rax
  800421352c:	75 25                	jne    8004213553 <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  800421352e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213532:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213536:	48 89 d6             	mov    %rdx,%rsi
  8004213539:	48 89 c7             	mov    %rax,%rdi
  800421353c:	48 b8 11 32 21 04 80 	movabs $0x8004213211,%rax
  8004213543:	00 00 00 
  8004213546:	ff d0                	callq  *%rax
  8004213548:	85 c0                	test   %eax,%eax
  800421354a:	74 07                	je     8004213553 <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  800421354c:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213551:	eb 53                	jmp    80042135a6 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  8004213553:	48 bf c0 b6 22 04 80 	movabs $0x800422b6c0,%rdi
  800421355a:	00 00 00 
  800421355d:	48 b8 6a 0f 21 04 80 	movabs $0x8004210f6a,%rax
  8004213564:	00 00 00 
  8004213567:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  8004213569:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421356d:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  8004213574:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  8004213575:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  800421357c:	00 00 00 
  800421357f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213583:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213587:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  800421358b:	48 b8 c0 b6 22 04 80 	movabs $0x800422b6c0,%rax
  8004213592:	00 00 00 
  8004213595:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213599:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421359d:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  80042135a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042135a6:	c9                   	leaveq 
  80042135a7:	c3                   	retq   

00000080042135a8 <_dwarf_lineno_run_program>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042135a8:	55                   	push   %rbp
  80042135a9:	48 89 e5             	mov    %rsp,%rbp
  80042135ac:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  80042135b3:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042135b7:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042135bb:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  80042135bf:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  80042135c3:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  80042135ca:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  80042135d1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042135d5:	48 83 c0 48          	add    $0x48,%rax
  80042135d9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  80042135dd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042135e4:	00 
  80042135e5:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  80042135ec:	00 
  80042135ed:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  80042135f4:	00 
  80042135f5:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042135fc:	00 
  80042135fd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213601:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004213605:	0f b6 c0             	movzbl %al,%eax
  8004213608:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421360b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  8004213612:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8004213619:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004213620:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004213627:	e9 b4 04 00 00       	jmpq   8004213ae0 <_dwarf_lineno_run_program+0x538>
		if (*p == 0) {
  800421362c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213630:	0f b6 00             	movzbl (%rax),%eax
  8004213633:	84 c0                	test   %al,%al
  8004213635:	0f 85 4c 01 00 00    	jne    8004213787 <_dwarf_lineno_run_program+0x1df>

			/*
			 * Extended Opcodes.
			 */

			p++;
  800421363b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421363f:	48 83 c0 01          	add    $0x1,%rax
  8004213643:	48 89 45 88          	mov    %rax,-0x78(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  8004213647:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  800421364b:	48 89 c7             	mov    %rax,%rdi
  800421364e:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004213655:	00 00 00 
  8004213658:	ff d0                	callq  *%rax
  800421365a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
			switch (*p) {
  800421365e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213662:	0f b6 00             	movzbl (%rax),%eax
  8004213665:	0f b6 c0             	movzbl %al,%eax
  8004213668:	83 f8 02             	cmp    $0x2,%eax
  800421366b:	74 74                	je     80042136e1 <_dwarf_lineno_run_program+0x139>
  800421366d:	83 f8 03             	cmp    $0x3,%eax
  8004213670:	0f 84 a7 00 00 00    	je     800421371d <_dwarf_lineno_run_program+0x175>
  8004213676:	83 f8 01             	cmp    $0x1,%eax
  8004213679:	0f 85 ee 00 00 00    	jne    800421376d <_dwarf_lineno_run_program+0x1c5>
			case DW_LNE_end_sequence:
				p++;
  800421367f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213683:	48 83 c0 01          	add    $0x1,%rax
  8004213687:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				end_sequence = 1;
  800421368b:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
				RESET_REGISTERS;
  8004213692:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004213699:	00 
  800421369a:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  80042136a1:	00 
  80042136a2:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  80042136a9:	00 
  80042136aa:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042136b1:	00 
  80042136b2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042136b6:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042136ba:	0f b6 c0             	movzbl %al,%eax
  80042136bd:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042136c0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  80042136c7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  80042136ce:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  80042136d5:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
				break;
  80042136dc:	e9 ff 03 00 00       	jmpq   8004213ae0 <_dwarf_lineno_run_program+0x538>
			case DW_LNE_set_address:
				p++;
  80042136e1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042136e5:	48 83 c0 01          	add    $0x1,%rax
  80042136e9:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  80042136ed:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  80042136f4:	00 00 00 
  80042136f7:	48 8b 00             	mov    (%rax),%rax
  80042136fa:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042136fe:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004213702:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004213706:	0f b6 ca             	movzbl %dl,%ecx
  8004213709:	48 8d 55 88          	lea    -0x78(%rbp),%rdx
  800421370d:	89 ce                	mov    %ecx,%esi
  800421370f:	48 89 d7             	mov    %rdx,%rdi
  8004213712:	ff d0                	callq  *%rax
  8004213714:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
				break;
  8004213718:	e9 c3 03 00 00       	jmpq   8004213ae0 <_dwarf_lineno_run_program+0x538>
			case DW_LNE_define_file:
				p++;
  800421371d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213721:	48 83 c0 01          	add    $0x1,%rax
  8004213725:	48 89 45 88          	mov    %rax,-0x78(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  8004213729:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213730:	00 00 00 
  8004213733:	48 8b 08             	mov    (%rax),%rcx
  8004213736:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421373d:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
  8004213741:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213745:	49 89 c8             	mov    %rcx,%r8
  8004213748:	48 89 d1             	mov    %rdx,%rcx
  800421374b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004213750:	48 89 c7             	mov    %rax,%rdi
  8004213753:	48 b8 fa 3a 21 04 80 	movabs $0x8004213afa,%rax
  800421375a:	00 00 00 
  800421375d:	ff d0                	callq  *%rax
  800421375f:	89 45 b4             	mov    %eax,-0x4c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  8004213762:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  8004213766:	74 19                	je     8004213781 <_dwarf_lineno_run_program+0x1d9>
					goto prog_fail;
  8004213768:	e9 88 03 00 00       	jmpq   8004213af5 <_dwarf_lineno_run_program+0x54d>
				break;
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  800421376d:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004213771:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213775:	48 01 d0             	add    %rdx,%rax
  8004213778:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  800421377c:	e9 5f 03 00 00       	jmpq   8004213ae0 <_dwarf_lineno_run_program+0x538>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  8004213781:	90                   	nop
  8004213782:	e9 59 03 00 00       	jmpq   8004213ae0 <_dwarf_lineno_run_program+0x538>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  8004213787:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421378b:	0f b6 00             	movzbl (%rax),%eax
  800421378e:	84 c0                	test   %al,%al
  8004213790:	0f 84 24 02 00 00    	je     80042139ba <_dwarf_lineno_run_program+0x412>
  8004213796:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421379a:	0f b6 10             	movzbl (%rax),%edx
  800421379d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042137a1:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042137a5:	38 c2                	cmp    %al,%dl
  80042137a7:	0f 83 0d 02 00 00    	jae    80042139ba <_dwarf_lineno_run_program+0x412>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  80042137ad:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042137b1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042137b5:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  80042137b9:	0f b6 00             	movzbl (%rax),%eax
  80042137bc:	0f b6 c0             	movzbl %al,%eax
  80042137bf:	83 f8 0c             	cmp    $0xc,%eax
  80042137c2:	0f 87 ec 01 00 00    	ja     80042139b4 <_dwarf_lineno_run_program+0x40c>
  80042137c8:	89 c0                	mov    %eax,%eax
  80042137ca:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042137d1:	00 
  80042137d2:	48 b8 28 87 21 04 80 	movabs $0x8004218728,%rax
  80042137d9:	00 00 00 
  80042137dc:	48 01 d0             	add    %rdx,%rax
  80042137df:	48 8b 00             	mov    (%rax),%rax
  80042137e2:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  80042137e4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042137eb:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042137ef:	73 0a                	jae    80042137fb <_dwarf_lineno_run_program+0x253>
  80042137f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042137f6:	e9 fd 02 00 00       	jmpq   8004213af8 <_dwarf_lineno_run_program+0x550>
  80042137fb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042137ff:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213803:	48 89 10             	mov    %rdx,(%rax)
  8004213806:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421380a:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213811:	00 
  8004213812:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213816:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421381a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421381e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213822:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213826:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421382a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421382e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213832:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213836:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421383a:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800421383d:	89 50 28             	mov    %edx,0x28(%rax)
  8004213840:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213844:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004213847:	89 50 2c             	mov    %edx,0x2c(%rax)
  800421384a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421384e:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004213851:	89 50 30             	mov    %edx,0x30(%rax)
  8004213854:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213858:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  800421385f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213863:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213867:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  800421386e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				prologue_end = 0;
  8004213875:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
				epilogue_begin = 0;
  800421387c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
				break;
  8004213883:	e9 2d 01 00 00       	jmpq   80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004213888:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  800421388c:	48 89 c7             	mov    %rax,%rdi
  800421388f:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004213896:	00 00 00 
  8004213899:	ff d0                	callq  *%rax
  800421389b:	48 89 c2             	mov    %rax,%rdx
					li->li_minlen;
  800421389e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042138a2:	0f b6 40 18          	movzbl 0x18(%rax),%eax
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  80042138a6:	0f b6 c0             	movzbl %al,%eax
  80042138a9:	48 0f af c2          	imul   %rdx,%rax
  80042138ad:	48 01 45 f8          	add    %rax,-0x8(%rbp)
					li->li_minlen;
				break;
  80042138b1:	e9 ff 00 00 00       	jmpq   80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  80042138b6:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042138ba:	48 89 c7             	mov    %rax,%rdi
  80042138bd:	48 b8 0e f8 20 04 80 	movabs $0x800420f80e,%rax
  80042138c4:	00 00 00 
  80042138c7:	ff d0                	callq  *%rax
  80042138c9:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  80042138cd:	e9 e3 00 00 00       	jmpq   80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  80042138d2:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042138d6:	48 89 c7             	mov    %rax,%rdi
  80042138d9:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  80042138e0:	00 00 00 
  80042138e3:	ff d0                	callq  *%rax
  80042138e5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
				break;
  80042138e9:	e9 c7 00 00 00       	jmpq   80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  80042138ee:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042138f2:	48 89 c7             	mov    %rax,%rdi
  80042138f5:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  80042138fc:	00 00 00 
  80042138ff:	ff d0                	callq  *%rax
  8004213901:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  8004213905:	e9 ab 00 00 00       	jmpq   80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  800421390a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421390e:	0f 94 c0             	sete   %al
  8004213911:	0f b6 c0             	movzbl %al,%eax
  8004213914:	89 45 dc             	mov    %eax,-0x24(%rbp)
				break;
  8004213917:	e9 99 00 00 00       	jmpq   80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  800421391c:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
				break;
  8004213923:	e9 8d 00 00 00       	jmpq   80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  8004213928:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421392c:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213930:	0f b6 c0             	movzbl %al,%eax
  8004213933:	ba ff 00 00 00       	mov    $0xff,%edx
  8004213938:	89 d1                	mov    %edx,%ecx
  800421393a:	29 c1                	sub    %eax,%ecx
  800421393c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213940:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213944:	0f b6 f0             	movzbl %al,%esi
  8004213947:	89 c8                	mov    %ecx,%eax
  8004213949:	99                   	cltd   
  800421394a:	f7 fe                	idiv   %esi
  800421394c:	89 c2                	mov    %eax,%edx
  800421394e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213952:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004213956:	0f b6 c0             	movzbl %al,%eax
  8004213959:	0f af c2             	imul   %edx,%eax
  800421395c:	48 98                	cltq   
  800421395e:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  8004213962:	eb 51                	jmp    80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  8004213964:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  800421396b:	00 00 00 
  800421396e:	48 8b 00             	mov    (%rax),%rax
  8004213971:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213975:	48 8d 55 88          	lea    -0x78(%rbp),%rdx
  8004213979:	be 02 00 00 00       	mov    $0x2,%esi
  800421397e:	48 89 d7             	mov    %rdx,%rdi
  8004213981:	ff d0                	callq  *%rax
  8004213983:	48 01 45 f8          	add    %rax,-0x8(%rbp)
				break;
  8004213987:	eb 2c                	jmp    80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004213989:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				break;
  8004213990:	eb 23                	jmp    80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  8004213992:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%rbp)
				break;
  8004213999:	eb 1a                	jmp    80042139b5 <_dwarf_lineno_run_program+0x40d>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  800421399b:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  800421399f:	48 89 c7             	mov    %rax,%rdi
  80042139a2:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  80042139a9:	00 00 00 
  80042139ac:	ff d0                	callq  *%rax
  80042139ae:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
				break;
  80042139b2:	eb 01                	jmp    80042139b5 <_dwarf_lineno_run_program+0x40d>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  80042139b4:	90                   	nop
			}

		} else {
  80042139b5:	e9 26 01 00 00       	jmpq   8004213ae0 <_dwarf_lineno_run_program+0x538>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  80042139ba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139be:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  80042139c2:	0f be c8             	movsbl %al,%ecx
  80042139c5:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042139c9:	0f b6 00             	movzbl (%rax),%eax
  80042139cc:	0f b6 d0             	movzbl %al,%edx
  80042139cf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139d3:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042139d7:	0f b6 c0             	movzbl %al,%eax
  80042139da:	29 c2                	sub    %eax,%edx
  80042139dc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139e0:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042139e4:	0f b6 f0             	movzbl %al,%esi
  80042139e7:	89 d0                	mov    %edx,%eax
  80042139e9:	99                   	cltd   
  80042139ea:	f7 fe                	idiv   %esi
  80042139ec:	89 d0                	mov    %edx,%eax
  80042139ee:	01 c8                	add    %ecx,%eax
  80042139f0:	48 98                	cltq   
  80042139f2:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			address += ADDRESS(*p);
  80042139f6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042139fa:	0f b6 00             	movzbl (%rax),%eax
  80042139fd:	0f b6 d0             	movzbl %al,%edx
  8004213a00:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a04:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213a08:	0f b6 c0             	movzbl %al,%eax
  8004213a0b:	89 d1                	mov    %edx,%ecx
  8004213a0d:	29 c1                	sub    %eax,%ecx
  8004213a0f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a13:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213a17:	0f b6 f0             	movzbl %al,%esi
  8004213a1a:	89 c8                	mov    %ecx,%eax
  8004213a1c:	99                   	cltd   
  8004213a1d:	f7 fe                	idiv   %esi
  8004213a1f:	89 c2                	mov    %eax,%edx
  8004213a21:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a25:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004213a29:	0f b6 c0             	movzbl %al,%eax
  8004213a2c:	0f af c2             	imul   %edx,%eax
  8004213a2f:	48 98                	cltq   
  8004213a31:	48 01 45 f8          	add    %rax,-0x8(%rbp)
			APPEND_ROW;
  8004213a35:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004213a3c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213a40:	73 0a                	jae    8004213a4c <_dwarf_lineno_run_program+0x4a4>
  8004213a42:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213a47:	e9 ac 00 00 00       	jmpq   8004213af8 <_dwarf_lineno_run_program+0x550>
  8004213a4c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a50:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213a54:	48 89 10             	mov    %rdx,(%rax)
  8004213a57:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a5b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213a62:	00 
  8004213a63:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a67:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213a6b:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004213a6f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a73:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213a77:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004213a7b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213a7f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a83:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213a87:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a8b:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004213a8e:	89 50 28             	mov    %edx,0x28(%rax)
  8004213a91:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a95:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004213a98:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004213a9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a9f:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004213aa2:	89 50 30             	mov    %edx,0x30(%rax)
  8004213aa5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213aa9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004213ab0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213ab4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213ab8:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004213abf:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
			prologue_end = 0;
  8004213ac6:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
			epilogue_begin = 0;
  8004213acd:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
			p++;
  8004213ad4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213ad8:	48 83 c0 01          	add    $0x1,%rax
  8004213adc:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004213ae0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213ae4:	48 3b 45 80          	cmp    -0x80(%rbp),%rax
  8004213ae8:	0f 82 3e fb ff ff    	jb     800421362c <_dwarf_lineno_run_program+0x84>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  8004213aee:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213af3:	eb 03                	jmp    8004213af8 <_dwarf_lineno_run_program+0x550>

prog_fail:

	return (ret);
  8004213af5:	8b 45 b4             	mov    -0x4c(%rbp),%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  8004213af8:	c9                   	leaveq 
  8004213af9:	c3                   	retq   

0000008004213afa <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004213afa:	55                   	push   %rbp
  8004213afb:	48 89 e5             	mov    %rsp,%rbp
  8004213afe:	48 83 ec 40          	sub    $0x40,%rsp
  8004213b02:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004213b06:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004213b0a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213b0e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004213b12:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  8004213b16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213b1a:	48 8b 00             	mov    (%rax),%rax
  8004213b1d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004213b21:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213b25:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	src += strlen(fname) + 1;
  8004213b29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213b2d:	48 89 c7             	mov    %rax,%rdi
  8004213b30:	48 b8 71 e9 20 04 80 	movabs $0x800420e971,%rax
  8004213b37:	00 00 00 
  8004213b3a:	ff d0                	callq  *%rax
  8004213b3c:	83 c0 01             	add    $0x1,%eax
  8004213b3f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213b43:	48 98                	cltq   
  8004213b45:	48 01 d0             	add    %rdx,%rax
  8004213b48:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	_dwarf_decode_uleb128(&src);
  8004213b4c:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004213b50:	48 89 c7             	mov    %rax,%rdi
  8004213b53:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004213b5a:	00 00 00 
  8004213b5d:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004213b5f:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004213b63:	48 89 c7             	mov    %rax,%rdi
  8004213b66:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004213b6d:	00 00 00 
  8004213b70:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004213b72:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004213b76:	48 89 c7             	mov    %rax,%rdi
  8004213b79:	48 b8 a0 f8 20 04 80 	movabs $0x800420f8a0,%rax
  8004213b80:	00 00 00 
  8004213b83:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004213b85:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213b89:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213b8d:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004213b90:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213b95:	c9                   	leaveq 
  8004213b96:	c3                   	retq   

0000008004213b97 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004213b97:	55                   	push   %rbp
  8004213b98:	48 89 e5             	mov    %rsp,%rbp
  8004213b9b:	53                   	push   %rbx
  8004213b9c:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004213ba3:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004213baa:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004213bb1:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004213bb8:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004213bbf:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004213bc6:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004213bcd:	00 
  8004213bce:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004213bd5:	00 
  8004213bd6:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004213bdd:	00 
  8004213bde:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004213be5:	00 
  8004213be6:	48 b8 90 87 21 04 80 	movabs $0x8004218790,%rax
  8004213bed:	00 00 00 
  8004213bf0:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004213bf4:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004213bf8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004213bfc:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004213c03:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004213c0a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004213c0e:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004213c13:	75 35                	jne    8004213c4a <_dwarf_lineno_init+0xb3>
  8004213c15:	48 b9 9c 87 21 04 80 	movabs $0x800421879c,%rcx
  8004213c1c:	00 00 00 
  8004213c1f:	48 ba a7 87 21 04 80 	movabs $0x80042187a7,%rdx
  8004213c26:	00 00 00 
  8004213c29:	be 13 01 00 00       	mov    $0x113,%esi
  8004213c2e:	48 bf bc 87 21 04 80 	movabs $0x80042187bc,%rdi
  8004213c35:	00 00 00 
  8004213c38:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213c3d:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004213c44:	00 00 00 
  8004213c47:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004213c4a:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213c51:	00 00 00 
  8004213c54:	48 8b 00             	mov    (%rax),%rax
  8004213c57:	48 85 c0             	test   %rax,%rax
  8004213c5a:	75 35                	jne    8004213c91 <_dwarf_lineno_init+0xfa>
  8004213c5c:	48 b9 d3 87 21 04 80 	movabs $0x80042187d3,%rcx
  8004213c63:	00 00 00 
  8004213c66:	48 ba a7 87 21 04 80 	movabs $0x80042187a7,%rdx
  8004213c6d:	00 00 00 
  8004213c70:	be 14 01 00 00       	mov    $0x114,%esi
  8004213c75:	48 bf bc 87 21 04 80 	movabs $0x80042187bc,%rdi
  8004213c7c:	00 00 00 
  8004213c7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213c84:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004213c8b:	00 00 00 
  8004213c8e:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004213c91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213c95:	48 89 c7             	mov    %rax,%rdi
  8004213c98:	48 b8 6a 0f 21 04 80 	movabs $0x8004210f6a,%rax
  8004213c9f:	00 00 00 
  8004213ca2:	ff d0                	callq  *%rax
  8004213ca4:	85 c0                	test   %eax,%eax
  8004213ca6:	74 0a                	je     8004213cb2 <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004213ca8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213cad:	e9 51 04 00 00       	jmpq   8004214103 <_dwarf_lineno_init+0x56c>

	li = linfo;
  8004213cb2:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004213cb9:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004213cbd:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213cc4:	00 00 00 
  8004213cc7:	48 8b 00             	mov    (%rax),%rax
  8004213cca:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213cce:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213cd2:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213cd6:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213cdd:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213ce2:	48 89 cf             	mov    %rcx,%rdi
  8004213ce5:	ff d0                	callq  *%rax
  8004213ce7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004213ceb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213cf0:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004213cf4:	75 37                	jne    8004213d2d <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004213cf6:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004213cfd:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213d04:	00 00 00 
  8004213d07:	48 8b 00             	mov    (%rax),%rax
  8004213d0a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d0e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213d12:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213d16:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213d1d:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213d22:	48 89 cf             	mov    %rcx,%rdi
  8004213d25:	ff d0                	callq  *%rax
  8004213d27:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004213d2b:	eb 07                	jmp    8004213d34 <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004213d2d:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004213d34:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213d38:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213d3c:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213d43:	48 29 c2             	sub    %rax,%rdx
  8004213d46:	48 89 d0             	mov    %rdx,%rax
  8004213d49:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213d4d:	73 0a                	jae    8004213d59 <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004213d4f:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004213d54:	e9 aa 03 00 00       	jmpq   8004214103 <_dwarf_lineno_init+0x56c>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004213d59:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213d5d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213d61:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004213d64:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004213d6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d6f:	48 01 d0             	add    %rdx,%rax
  8004213d72:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004213d76:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213d7d:	00 00 00 
  8004213d80:	48 8b 00             	mov    (%rax),%rax
  8004213d83:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d87:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213d8b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213d8f:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213d96:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213d9b:	48 89 cf             	mov    %rcx,%rdi
  8004213d9e:	ff d0                	callq  *%rax
  8004213da0:	89 c2                	mov    %eax,%edx
  8004213da2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213da6:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004213daa:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213db1:	00 00 00 
  8004213db4:	48 8b 00             	mov    (%rax),%rax
  8004213db7:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213dbb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213dbf:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213dc3:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004213dc6:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213dcd:	48 89 cf             	mov    %rcx,%rdi
  8004213dd0:	ff d0                	callq  *%rax
  8004213dd2:	48 89 c2             	mov    %rax,%rdx
  8004213dd5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213dd9:	48 89 50 10          	mov    %rdx,0x10(%rax)
	hdroff = offset;
  8004213ddd:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213de4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004213de8:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213def:	00 00 00 
  8004213df2:	48 8b 00             	mov    (%rax),%rax
  8004213df5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213df9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213dfd:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213e01:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213e08:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213e0d:	48 89 cf             	mov    %rcx,%rdi
  8004213e10:	ff d0                	callq  *%rax
  8004213e12:	89 c2                	mov    %eax,%edx
  8004213e14:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213e18:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004213e1b:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213e22:	00 00 00 
  8004213e25:	48 8b 00             	mov    (%rax),%rax
  8004213e28:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e2c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e30:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213e34:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213e3b:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213e40:	48 89 cf             	mov    %rcx,%rdi
  8004213e43:	ff d0                	callq  *%rax
  8004213e45:	89 c2                	mov    %eax,%edx
  8004213e47:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213e4b:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004213e4e:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213e55:	00 00 00 
  8004213e58:	48 8b 00             	mov    (%rax),%rax
  8004213e5b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e5f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e63:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213e67:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213e6e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213e73:	48 89 cf             	mov    %rcx,%rdi
  8004213e76:	ff d0                	callq  *%rax
  8004213e78:	89 c2                	mov    %eax,%edx
  8004213e7a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213e7e:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004213e81:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213e88:	00 00 00 
  8004213e8b:	48 8b 00             	mov    (%rax),%rax
  8004213e8e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e92:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e96:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213e9a:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213ea1:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213ea6:	48 89 cf             	mov    %rcx,%rdi
  8004213ea9:	ff d0                	callq  *%rax
  8004213eab:	89 c2                	mov    %eax,%edx
  8004213ead:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213eb1:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004213eb4:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213ebb:	00 00 00 
  8004213ebe:	48 8b 00             	mov    (%rax),%rax
  8004213ec1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ec5:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213ec9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213ecd:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213ed4:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213ed9:	48 89 cf             	mov    %rcx,%rdi
  8004213edc:	ff d0                	callq  *%rax
  8004213ede:	89 c2                	mov    %eax,%edx
  8004213ee0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213ee4:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004213ee7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213eeb:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004213eef:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004213ef2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213ef6:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213efa:	0f b6 c0             	movzbl %al,%eax
  8004213efd:	83 e8 01             	sub    $0x1,%eax
  8004213f00:	39 c2                	cmp    %eax,%edx
  8004213f02:	7d 0c                	jge    8004213f10 <_dwarf_lineno_init+0x379>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004213f04:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004213f0b:	e9 f0 01 00 00       	jmpq   8004214100 <_dwarf_lineno_init+0x569>
	}

	li->li_oplen = global_std_op;
  8004213f10:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213f14:	48 bb a0 45 36 04 80 	movabs $0x80043645a0,%rbx
  8004213f1b:	00 00 00 
  8004213f1e:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004213f22:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004213f29:	eb 41                	jmp    8004213f6c <_dwarf_lineno_init+0x3d5>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004213f2b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213f2f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213f33:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004213f36:	48 98                	cltq   
  8004213f38:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004213f3c:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004213f43:	00 00 00 
  8004213f46:	48 8b 00             	mov    (%rax),%rax
  8004213f49:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f4d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f51:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004213f55:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004213f5c:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213f61:	48 89 cf             	mov    %rcx,%rdi
  8004213f64:	ff d0                	callq  *%rax
  8004213f66:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004213f68:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004213f6c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213f70:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213f74:	0f b6 c0             	movzbl %al,%eax
  8004213f77:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004213f7a:	7f af                	jg     8004213f2b <_dwarf_lineno_init+0x394>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  8004213f7c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004213f83:	00 
	p = ds->ds_data + offset;
  8004213f84:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213f88:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213f8c:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213f93:	48 01 d0             	add    %rdx,%rax
  8004213f96:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  8004213f9d:	eb 1f                	jmp    8004213fbe <_dwarf_lineno_init+0x427>
		while (*p++ != '\0')
  8004213f9f:	90                   	nop
  8004213fa0:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213fa7:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213fab:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  8004213fb2:	0f b6 00             	movzbl (%rax),%eax
  8004213fb5:	84 c0                	test   %al,%al
  8004213fb7:	75 e7                	jne    8004213fa0 <_dwarf_lineno_init+0x409>
			;
		length++;
  8004213fb9:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  8004213fbe:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213fc5:	0f b6 00             	movzbl (%rax),%eax
  8004213fc8:	84 c0                	test   %al,%al
  8004213fca:	75 d3                	jne    8004213f9f <_dwarf_lineno_init+0x408>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  8004213fcc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213fd0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213fd4:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004213fd8:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213fdf:	48 89 c2             	mov    %rax,%rdx
  8004213fe2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213fe6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213fea:	48 29 c2             	sub    %rax,%rdx
  8004213fed:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213ff1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ff5:	48 98                	cltq   
  8004213ff7:	48 39 c2             	cmp    %rax,%rdx
  8004213ffa:	7e 0c                	jle    8004214008 <_dwarf_lineno_init+0x471>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004213ffc:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214003:	e9 f8 00 00 00       	jmpq   8004214100 <_dwarf_lineno_init+0x569>
	}
	p++;
  8004214008:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421400f:	48 83 c0 01          	add    $0x1,%rax
  8004214013:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  800421401a:	eb 3c                	jmp    8004214058 <_dwarf_lineno_init+0x4c1>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  800421401c:	48 b8 a8 b6 22 04 80 	movabs $0x800422b6a8,%rax
  8004214023:	00 00 00 
  8004214026:	48 8b 08             	mov    (%rax),%rcx
  8004214029:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004214030:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004214037:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421403b:	49 89 c8             	mov    %rcx,%r8
  800421403e:	48 89 d1             	mov    %rdx,%rcx
  8004214041:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214046:	48 89 c7             	mov    %rax,%rdi
  8004214049:	48 b8 fa 3a 21 04 80 	movabs $0x8004213afa,%rax
  8004214050:	00 00 00 
  8004214053:	ff d0                	callq  *%rax
  8004214055:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004214058:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421405f:	0f b6 00             	movzbl (%rax),%eax
  8004214062:	84 c0                	test   %al,%al
  8004214064:	75 b6                	jne    800421401c <_dwarf_lineno_init+0x485>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  8004214066:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421406d:	48 83 c0 01          	add    $0x1,%rax
  8004214071:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004214078:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421407f:	48 89 c2             	mov    %rax,%rdx
  8004214082:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214086:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421408a:	48 29 c2             	sub    %rax,%rdx
  800421408d:	48 89 d0             	mov    %rdx,%rax
  8004214090:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  8004214094:	48 89 c2             	mov    %rax,%rdx
  8004214097:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421409b:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421409f:	48 39 c2             	cmp    %rax,%rdx
  80042140a2:	74 09                	je     80042140ad <_dwarf_lineno_init+0x516>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  80042140a4:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  80042140ab:	eb 53                	jmp    8004214100 <_dwarf_lineno_init+0x569>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  80042140ad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042140b1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042140b5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042140b9:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042140bd:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042140c4:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  80042140cb:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  80042140d2:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042140d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042140da:	4d 89 c1             	mov    %r8,%r9
  80042140dd:	49 89 f8             	mov    %rdi,%r8
  80042140e0:	48 89 c7             	mov    %rax,%rdi
  80042140e3:	48 b8 a8 35 21 04 80 	movabs $0x80042135a8,%rax
  80042140ea:	00 00 00 
  80042140ed:	ff d0                	callq  *%rax
  80042140ef:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  80042140f2:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042140f6:	75 07                	jne    80042140ff <_dwarf_lineno_init+0x568>
		goto fail_cleanup;

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  80042140f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042140fd:	eb 04                	jmp    8004214103 <_dwarf_lineno_init+0x56c>
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
					error);
	if (ret != DW_DLE_NONE)
		goto fail_cleanup;
  80042140ff:	90                   	nop
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  8004214100:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004214103:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  800421410a:	5b                   	pop    %rbx
  800421410b:	5d                   	pop    %rbp
  800421410c:	c3                   	retq   

000000800421410d <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  800421410d:	55                   	push   %rbp
  800421410e:	48 89 e5             	mov    %rsp,%rbp
  8004214111:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004214118:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800421411f:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004214126:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  800421412d:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  8004214134:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  800421413b:	00 
  800421413c:	75 35                	jne    8004214173 <dwarf_srclines+0x66>
  800421413e:	48 b9 df 87 21 04 80 	movabs $0x80042187df,%rcx
  8004214145:	00 00 00 
  8004214148:	48 ba a7 87 21 04 80 	movabs $0x80042187a7,%rdx
  800421414f:	00 00 00 
  8004214152:	be 9a 01 00 00       	mov    $0x19a,%esi
  8004214157:	48 bf bc 87 21 04 80 	movabs $0x80042187bc,%rdi
  800421415e:	00 00 00 
  8004214161:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214166:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  800421416d:	00 00 00 
  8004214170:	41 ff d0             	callq  *%r8
	assert(linebuf);
  8004214173:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  800421417a:	00 
  800421417b:	75 35                	jne    80042141b2 <dwarf_srclines+0xa5>
  800421417d:	48 b9 e3 87 21 04 80 	movabs $0x80042187e3,%rcx
  8004214184:	00 00 00 
  8004214187:	48 ba a7 87 21 04 80 	movabs $0x80042187a7,%rdx
  800421418e:	00 00 00 
  8004214191:	be 9b 01 00 00       	mov    $0x19b,%esi
  8004214196:	48 bf bc 87 21 04 80 	movabs $0x80042187bc,%rdi
  800421419d:	00 00 00 
  80042141a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042141a5:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042141ac:	00 00 00 
  80042141af:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  80042141b2:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042141b9:	ba 88 00 00 00       	mov    $0x88,%edx
  80042141be:	be 00 00 00 00       	mov    $0x0,%esi
  80042141c3:	48 89 c7             	mov    %rax,%rdi
  80042141c6:	48 b8 77 ec 20 04 80 	movabs $0x800420ec77,%rax
  80042141cd:	00 00 00 
  80042141d0:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  80042141d2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042141d9:	be 10 00 00 00       	mov    $0x10,%esi
  80042141de:	48 89 c7             	mov    %rax,%rdi
  80042141e1:	48 b8 55 0b 21 04 80 	movabs $0x8004210b55,%rax
  80042141e8:	00 00 00 
  80042141eb:	ff d0                	callq  *%rax
  80042141ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042141f1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042141f6:	75 0a                	jne    8004214202 <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  80042141f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042141fd:	e9 84 00 00 00       	jmpq   8004214286 <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004214202:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214206:	48 8b 70 28          	mov    0x28(%rax),%rsi
  800421420a:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004214211:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004214218:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  800421421f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214226:	49 89 f8             	mov    %rdi,%r8
  8004214229:	48 89 c7             	mov    %rax,%rdi
  800421422c:	48 b8 97 3b 21 04 80 	movabs $0x8004213b97,%rax
  8004214233:	00 00 00 
  8004214236:	ff d0                	callq  *%rax
  8004214238:	85 c0                	test   %eax,%eax
  800421423a:	74 07                	je     8004214243 <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  800421423c:	b8 01 00 00 00       	mov    $0x1,%eax
  8004214241:	eb 43                	jmp    8004214286 <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  8004214243:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800421424a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800421424e:	48 89 10             	mov    %rdx,(%rax)
  8004214251:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214255:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004214259:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421425d:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004214261:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214265:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214269:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421426d:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004214271:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214275:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004214279:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421427d:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  8004214281:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214286:	c9                   	leaveq 
  8004214287:	c3                   	retq   

0000008004214288 <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004214288:	55                   	push   %rbp
  8004214289:	48 89 e5             	mov    %rsp,%rbp
  800421428c:	48 83 ec 20          	sub    $0x20,%rsp
  8004214290:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  8004214294:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421429b:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  800421429c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042142a3:	eb 57                	jmp    80042142fc <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  80042142a5:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042142ac:	00 00 00 
  80042142af:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042142b2:	48 63 d2             	movslq %edx,%rdx
  80042142b5:	48 c1 e2 05          	shl    $0x5,%rdx
  80042142b9:	48 01 d0             	add    %rdx,%rax
  80042142bc:	48 8b 00             	mov    (%rax),%rax
  80042142bf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042142c3:	48 89 d6             	mov    %rdx,%rsi
  80042142c6:	48 89 c7             	mov    %rax,%rdi
  80042142c9:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  80042142d0:	00 00 00 
  80042142d3:	ff d0                	callq  *%rax
  80042142d5:	85 c0                	test   %eax,%eax
  80042142d7:	75 1f                	jne    80042142f8 <_dwarf_find_section+0x70>
			ret = (section_info + i);
  80042142d9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042142dc:	48 98                	cltq   
  80042142de:	48 c1 e0 05          	shl    $0x5,%rax
  80042142e2:	48 89 c2             	mov    %rax,%rdx
  80042142e5:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042142ec:	00 00 00 
  80042142ef:	48 01 d0             	add    %rdx,%rax
  80042142f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  80042142f6:	eb 0a                	jmp    8004214302 <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  80042142f8:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042142fc:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214300:	7e a3                	jle    80042142a5 <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  8004214302:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004214306:	c9                   	leaveq 
  8004214307:	c3                   	retq   

0000008004214308 <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  8004214308:	55                   	push   %rbp
  8004214309:	48 89 e5             	mov    %rsp,%rbp
  800421430c:	48 83 ec 40          	sub    $0x40,%rsp
  8004214310:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  8004214314:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214318:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  800421431c:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  8004214323:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004214324:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214328:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800421432c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214330:	48 01 d0             	add    %rdx,%rax
  8004214333:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004214337:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421433b:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  800421433f:	0f b7 c0             	movzwl %ax,%eax
  8004214342:	48 c1 e0 06          	shl    $0x6,%rax
  8004214346:	48 89 c2             	mov    %rax,%rdx
  8004214349:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421434d:	48 01 d0             	add    %rdx,%rax
  8004214350:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  8004214354:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214358:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  800421435c:	0f b7 c0             	movzwl %ax,%eax
  800421435f:	48 c1 e0 06          	shl    $0x6,%rax
  8004214363:	48 89 c2             	mov    %rax,%rdx
  8004214366:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421436a:	48 01 d0             	add    %rdx,%rax
  800421436d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  8004214371:	e9 4b 02 00 00       	jmpq   80042145c1 <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004214376:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421437a:	8b 00                	mov    (%rax),%eax
  800421437c:	89 c1                	mov    %eax,%ecx
  800421437e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214382:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214386:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421438a:	48 01 d0             	add    %rdx,%rax
  800421438d:	48 01 c8             	add    %rcx,%rax
  8004214390:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  8004214394:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214398:	48 be eb 87 21 04 80 	movabs $0x80042187eb,%rsi
  800421439f:	00 00 00 
  80042143a2:	48 89 c7             	mov    %rax,%rdi
  80042143a5:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  80042143ac:	00 00 00 
  80042143af:	ff d0                	callq  *%rax
  80042143b1:	85 c0                	test   %eax,%eax
  80042143b3:	75 4b                	jne    8004214400 <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  80042143b5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042143b9:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042143c0:	00 00 00 
  80042143c3:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  80042143c7:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042143ce:	00 00 00 
  80042143d1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042143d5:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  80042143d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042143dd:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042143e1:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042143e8:	00 00 00 
  80042143eb:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  80042143ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042143f3:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042143f7:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042143fb:	e9 bc 01 00 00       	jmpq   80042145bc <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  8004214400:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214404:	48 be f7 87 21 04 80 	movabs $0x80042187f7,%rsi
  800421440b:	00 00 00 
  800421440e:	48 89 c7             	mov    %rax,%rdi
  8004214411:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  8004214418:	00 00 00 
  800421441b:	ff d0                	callq  *%rax
  800421441d:	85 c0                	test   %eax,%eax
  800421441f:	75 4b                	jne    800421446c <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  8004214421:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214425:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421442c:	00 00 00 
  800421442f:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  8004214433:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421443a:	00 00 00 
  800421443d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214441:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  8004214445:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214449:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421444d:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214454:	00 00 00 
  8004214457:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  800421445b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421445f:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214463:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214467:	e9 50 01 00 00       	jmpq   80042145bc <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  800421446c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214470:	48 be 0f 88 21 04 80 	movabs $0x800421880f,%rsi
  8004214477:	00 00 00 
  800421447a:	48 89 c7             	mov    %rax,%rdi
  800421447d:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  8004214484:	00 00 00 
  8004214487:	ff d0                	callq  *%rax
  8004214489:	85 c0                	test   %eax,%eax
  800421448b:	75 4b                	jne    80042144d8 <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  800421448d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214491:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214498:	00 00 00 
  800421449b:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  800421449f:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042144a6:	00 00 00 
  80042144a9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042144ad:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  80042144b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042144b5:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042144b9:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042144c0:	00 00 00 
  80042144c3:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  80042144c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042144cb:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042144cf:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042144d3:	e9 e4 00 00 00       	jmpq   80042145bc <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  80042144d8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042144dc:	48 be 05 88 21 04 80 	movabs $0x8004218805,%rsi
  80042144e3:	00 00 00 
  80042144e6:	48 89 c7             	mov    %rax,%rdi
  80042144e9:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  80042144f0:	00 00 00 
  80042144f3:	ff d0                	callq  *%rax
  80042144f5:	85 c0                	test   %eax,%eax
  80042144f7:	75 53                	jne    800421454c <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  80042144f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042144fd:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214501:	48 89 c2             	mov    %rax,%rdx
  8004214504:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421450b:	00 00 00 
  800421450e:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  8004214512:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214516:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800421451a:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214521:	00 00 00 
  8004214524:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  8004214528:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421452c:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214530:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214537:	00 00 00 
  800421453a:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  800421453e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214542:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214546:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  800421454a:	eb 70                	jmp    80042145bc <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  800421454c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214550:	48 be 1b 88 21 04 80 	movabs $0x800421881b,%rsi
  8004214557:	00 00 00 
  800421455a:	48 89 c7             	mov    %rax,%rdi
  800421455d:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  8004214564:	00 00 00 
  8004214567:	ff d0                	callq  *%rax
  8004214569:	85 c0                	test   %eax,%eax
  800421456b:	75 4f                	jne    80042145bc <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  800421456d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214571:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214578:	00 00 00 
  800421457b:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  8004214582:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214589:	00 00 00 
  800421458c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214590:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  8004214597:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421459b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421459f:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  80042145a6:	00 00 00 
  80042145a9:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  80042145b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042145b4:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042145b8:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  80042145bc:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  80042145c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042145c5:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042145c9:	0f 82 a7 fd ff ff    	jb     8004214376 <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  80042145cf:	90                   	nop
  80042145d0:	c9                   	leaveq 
  80042145d1:	c3                   	retq   

00000080042145d2 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  80042145d2:	55                   	push   %rbp
  80042145d3:	48 89 e5             	mov    %rsp,%rbp
  80042145d6:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  80042145dd:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  80042145e4:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  80042145eb:	48 8d 95 c0 fe ff ff 	lea    -0x140(%rbp),%rdx
  80042145f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042145f7:	b9 14 00 00 00       	mov    $0x14,%ecx
  80042145fc:	48 89 d7             	mov    %rdx,%rdi
  80042145ff:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  8004214602:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  8004214609:	00 
  800421460a:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  8004214611:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214615:	48 01 d0             	add    %rdx,%rax
  8004214618:	48 83 e8 01          	sub    $0x1,%rax
  800421461c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004214620:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214624:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214629:	48 f7 75 e8          	divq   -0x18(%rbp)
  800421462d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214631:	48 29 d0             	sub    %rdx,%rax
  8004214634:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  8004214638:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  800421463f:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004214643:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214647:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  800421464b:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004214652:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004214653:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800421465a:	00 00 00 
  800421465d:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004214664:	75 11                	jne    8004214677 <read_section_headers+0xa5>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004214666:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421466d:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214671:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214675:	eb 26                	jmp    800421469d <read_section_headers+0xcb>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004214677:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421467e:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004214682:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004214689:	48 01 c2             	add    %rax,%rdx
  800421468c:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004214693:	ff ff ff 
  8004214696:	48 01 d0             	add    %rdx,%rax
  8004214699:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  800421469d:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042146a4:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  80042146a8:	0f b7 c0             	movzwl %ax,%eax
  80042146ab:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  80042146ae:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042146b5:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  80042146b9:	0f b7 c0             	movzwl %ax,%eax
  80042146bc:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  80042146bf:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042146c6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  80042146ca:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042146cd:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  80042146d1:	48 63 f0             	movslq %eax,%rsi
  80042146d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042146d8:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042146df:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042146e3:	48 89 c7             	mov    %rax,%rdi
  80042146e6:	48 b8 17 4d 21 04 80 	movabs $0x8004214d17,%rax
  80042146ed:	00 00 00 
  80042146f0:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  80042146f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042146f6:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042146fa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042146fe:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214704:	48 89 c2             	mov    %rax,%rdx
  8004214707:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421470b:	48 29 d0             	sub    %rdx,%rax
  800421470e:	48 89 c2             	mov    %rax,%rdx
  8004214711:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214715:	48 01 d0             	add    %rdx,%rax
  8004214718:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  800421471c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004214723:	eb 24                	jmp    8004214749 <read_section_headers+0x177>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004214725:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214728:	48 98                	cltq   
  800421472a:	48 c1 e0 06          	shl    $0x6,%rax
  800421472e:	48 89 c2             	mov    %rax,%rdx
  8004214731:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214735:	48 01 c2             	add    %rax,%rdx
  8004214738:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421473b:	48 98                	cltq   
  800421473d:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004214744:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004214745:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214749:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421474c:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  800421474f:	7c d4                	jl     8004214725 <read_section_headers+0x153>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004214751:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214755:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004214759:	0f b7 c0             	movzwl %ax,%eax
  800421475c:	48 98                	cltq   
  800421475e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214765:	ff 
  8004214766:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  800421476a:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214771:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004214775:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214779:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421477d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214781:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214785:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  800421478c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214790:	48 01 f1             	add    %rsi,%rcx
  8004214793:	48 89 cf             	mov    %rcx,%rdi
  8004214796:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421479d:	48 89 c6             	mov    %rax,%rsi
  80042147a0:	48 b8 17 4d 21 04 80 	movabs $0x8004214d17,%rax
  80042147a7:	00 00 00 
  80042147aa:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  80042147ac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042147b0:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042147b4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042147b8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042147bc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042147c0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042147c4:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042147ca:	48 29 c2             	sub    %rax,%rdx
  80042147cd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042147d1:	48 01 c2             	add    %rax,%rdx
  80042147d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042147d8:	48 01 d0             	add    %rdx,%rax
  80042147db:	48 89 45 90          	mov    %rax,-0x70(%rbp)

	for (i = 0; i < numSectionHeaders; i++)
  80042147df:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042147e6:	e9 10 05 00 00       	jmpq   8004214cfb <read_section_headers+0x729>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  80042147eb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042147ee:	48 98                	cltq   
  80042147f0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042147f7:	ff 
  80042147f8:	8b 00                	mov    (%rax),%eax
  80042147fa:	89 c2                	mov    %eax,%edx
  80042147fc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214800:	48 01 d0             	add    %rdx,%rax
  8004214803:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  8004214807:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421480e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214813:	48 85 c0             	test   %rax,%rax
  8004214816:	74 35                	je     800421484d <read_section_headers+0x27b>
  8004214818:	48 b9 26 88 21 04 80 	movabs $0x8004218826,%rcx
  800421481f:	00 00 00 
  8004214822:	48 ba 3f 88 21 04 80 	movabs $0x800421883f,%rdx
  8004214829:	00 00 00 
  800421482c:	be 86 00 00 00       	mov    $0x86,%esi
  8004214831:	48 bf 54 88 21 04 80 	movabs $0x8004218854,%rdi
  8004214838:	00 00 00 
  800421483b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214840:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004214847:	00 00 00 
  800421484a:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  800421484d:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214854:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004214858:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421485c:	48 be eb 87 21 04 80 	movabs $0x80042187eb,%rsi
  8004214863:	00 00 00 
  8004214866:	48 89 c7             	mov    %rax,%rdi
  8004214869:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  8004214870:	00 00 00 
  8004214873:	ff d0                	callq  *%rax
  8004214875:	85 c0                	test   %eax,%eax
  8004214877:	0f 85 db 00 00 00    	jne    8004214958 <read_section_headers+0x386>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421487d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214880:	48 98                	cltq   
  8004214882:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214889:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  800421488a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421488e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214891:	48 98                	cltq   
  8004214893:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421489a:	ff 
  800421489b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421489f:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  80042148a6:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042148aa:	48 01 f1             	add    %rsi,%rcx
  80042148ad:	48 89 cf             	mov    %rcx,%rdi
  80042148b0:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042148b7:	48 89 c6             	mov    %rax,%rsi
  80042148ba:	48 b8 17 4d 21 04 80 	movabs $0x8004214d17,%rax
  80042148c1:	00 00 00 
  80042148c4:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042148c6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042148c9:	48 98                	cltq   
  80042148cb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042148d2:	ff 
  80042148d3:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042148d7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042148da:	48 98                	cltq   
  80042148dc:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042148e3:	ff 
  80042148e4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042148e8:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  80042148ec:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042148f0:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042148f6:	48 29 c2             	sub    %rax,%rdx
  80042148f9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042148fd:	48 01 c2             	add    %rax,%rdx
  8004214900:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214904:	48 01 c2             	add    %rax,%rdx
  8004214907:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421490e:	00 00 00 
  8004214911:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  8004214915:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421491c:	00 00 00 
  800421491f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214923:	48 89 c2             	mov    %rax,%rdx
  8004214926:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421492d:	00 00 00 
  8004214930:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004214934:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214937:	48 98                	cltq   
  8004214939:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214940:	ff 
  8004214941:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214945:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  800421494c:	00 00 00 
  800421494f:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214953:	e9 9f 03 00 00       	jmpq   8004214cf7 <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004214958:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421495c:	48 be f7 87 21 04 80 	movabs $0x80042187f7,%rsi
  8004214963:	00 00 00 
  8004214966:	48 89 c7             	mov    %rax,%rdi
  8004214969:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  8004214970:	00 00 00 
  8004214973:	ff d0                	callq  *%rax
  8004214975:	85 c0                	test   %eax,%eax
  8004214977:	0f 85 e1 00 00 00    	jne    8004214a5e <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421497d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214980:	48 98                	cltq   
  8004214982:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214989:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  800421498a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421498e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214991:	48 98                	cltq   
  8004214993:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421499a:	ff 
  800421499b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421499f:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  80042149a6:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042149aa:	48 01 f1             	add    %rsi,%rcx
  80042149ad:	48 89 cf             	mov    %rcx,%rdi
  80042149b0:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042149b7:	48 89 c6             	mov    %rax,%rsi
  80042149ba:	48 b8 17 4d 21 04 80 	movabs $0x8004214d17,%rax
  80042149c1:	00 00 00 
  80042149c4:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042149c6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042149c9:	48 98                	cltq   
  80042149cb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042149d2:	ff 
  80042149d3:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042149d7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042149da:	48 98                	cltq   
  80042149dc:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042149e3:	ff 
  80042149e4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042149e8:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042149ef:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042149f6:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042149fc:	48 29 c2             	sub    %rax,%rdx
  80042149ff:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214a03:	48 01 c2             	add    %rax,%rdx
  8004214a06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214a0a:	48 01 c2             	add    %rax,%rdx
  8004214a0d:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214a14:	00 00 00 
  8004214a17:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004214a1b:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214a22:	00 00 00 
  8004214a25:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214a29:	48 89 c2             	mov    %rax,%rdx
  8004214a2c:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214a33:	00 00 00 
  8004214a36:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004214a3a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214a3d:	48 98                	cltq   
  8004214a3f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214a46:	ff 
  8004214a47:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214a4b:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214a52:	00 00 00 
  8004214a55:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004214a59:	e9 99 02 00 00       	jmpq   8004214cf7 <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_line"))
  8004214a5e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214a62:	48 be 0f 88 21 04 80 	movabs $0x800421880f,%rsi
  8004214a69:	00 00 00 
  8004214a6c:	48 89 c7             	mov    %rax,%rdi
  8004214a6f:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  8004214a76:	00 00 00 
  8004214a79:	ff d0                	callq  *%rax
  8004214a7b:	85 c0                	test   %eax,%eax
  8004214a7d:	0f 85 e1 00 00 00    	jne    8004214b64 <read_section_headers+0x592>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214a83:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214a86:	48 98                	cltq   
  8004214a88:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214a8f:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214a90:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214a94:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214a97:	48 98                	cltq   
  8004214a99:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214aa0:	ff 
  8004214aa1:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214aa5:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004214aac:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214ab0:	48 01 f1             	add    %rsi,%rcx
  8004214ab3:	48 89 cf             	mov    %rcx,%rdi
  8004214ab6:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214abd:	48 89 c6             	mov    %rax,%rsi
  8004214ac0:	48 b8 17 4d 21 04 80 	movabs $0x8004214d17,%rax
  8004214ac7:	00 00 00 
  8004214aca:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214acc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214acf:	48 98                	cltq   
  8004214ad1:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214ad8:	ff 
  8004214ad9:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214add:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214ae0:	48 98                	cltq   
  8004214ae2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214ae9:	ff 
  8004214aea:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214aee:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004214af5:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004214afc:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214b02:	48 29 c2             	sub    %rax,%rdx
  8004214b05:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214b09:	48 01 c2             	add    %rax,%rdx
  8004214b0c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214b10:	48 01 c2             	add    %rax,%rdx
  8004214b13:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214b1a:	00 00 00 
  8004214b1d:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004214b21:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214b28:	00 00 00 
  8004214b2b:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004214b2f:	48 89 c2             	mov    %rax,%rdx
  8004214b32:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214b39:	00 00 00 
  8004214b3c:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004214b40:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b43:	48 98                	cltq   
  8004214b45:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b4c:	ff 
  8004214b4d:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214b51:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214b58:	00 00 00 
  8004214b5b:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004214b5f:	e9 93 01 00 00       	jmpq   8004214cf7 <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004214b64:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214b68:	48 be 05 88 21 04 80 	movabs $0x8004218805,%rsi
  8004214b6f:	00 00 00 
  8004214b72:	48 89 c7             	mov    %rax,%rdi
  8004214b75:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  8004214b7c:	00 00 00 
  8004214b7f:	ff d0                	callq  *%rax
  8004214b81:	85 c0                	test   %eax,%eax
  8004214b83:	75 65                	jne    8004214bea <read_section_headers+0x618>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004214b85:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214b88:	48 98                	cltq   
  8004214b8a:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214b91:	ff 
  8004214b92:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214b96:	48 89 c2             	mov    %rax,%rdx
  8004214b99:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214ba0:	00 00 00 
  8004214ba3:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004214ba7:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214bae:	00 00 00 
  8004214bb1:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004214bb5:	48 89 c2             	mov    %rax,%rdx
  8004214bb8:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214bbf:	00 00 00 
  8004214bc2:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004214bc6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214bc9:	48 98                	cltq   
  8004214bcb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214bd2:	ff 
  8004214bd3:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214bd7:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214bde:	00 00 00 
  8004214be1:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004214be5:	e9 0d 01 00 00       	jmpq   8004214cf7 <read_section_headers+0x725>
		}
		else if(!strcmp(name, ".debug_str"))
  8004214bea:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214bee:	48 be 1b 88 21 04 80 	movabs $0x800421881b,%rsi
  8004214bf5:	00 00 00 
  8004214bf8:	48 89 c7             	mov    %rax,%rdi
  8004214bfb:	48 b8 3f eb 20 04 80 	movabs $0x800420eb3f,%rax
  8004214c02:	00 00 00 
  8004214c05:	ff d0                	callq  *%rax
  8004214c07:	85 c0                	test   %eax,%eax
  8004214c09:	0f 85 e8 00 00 00    	jne    8004214cf7 <read_section_headers+0x725>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214c0f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c12:	48 98                	cltq   
  8004214c14:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c1b:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214c1c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214c20:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c23:	48 98                	cltq   
  8004214c25:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c2c:	ff 
  8004214c2d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214c31:	48 8b b5 b8 fe ff ff 	mov    -0x148(%rbp),%rsi
  8004214c38:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214c3c:	48 01 f1             	add    %rsi,%rcx
  8004214c3f:	48 89 cf             	mov    %rcx,%rdi
  8004214c42:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214c49:	48 89 c6             	mov    %rax,%rsi
  8004214c4c:	48 b8 17 4d 21 04 80 	movabs $0x8004214d17,%rax
  8004214c53:	00 00 00 
  8004214c56:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214c58:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c5b:	48 98                	cltq   
  8004214c5d:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c64:	ff 
  8004214c65:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214c69:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214c6c:	48 98                	cltq   
  8004214c6e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214c75:	ff 
  8004214c76:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c7a:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004214c81:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214c88:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214c8e:	48 29 c2             	sub    %rax,%rdx
  8004214c91:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214c95:	48 01 c2             	add    %rax,%rdx
  8004214c98:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214c9c:	48 01 c2             	add    %rax,%rdx
  8004214c9f:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214ca6:	00 00 00 
  8004214ca9:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004214cb0:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214cb7:	00 00 00 
  8004214cba:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004214cc1:	48 89 c2             	mov    %rax,%rdx
  8004214cc4:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214ccb:	00 00 00 
  8004214cce:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004214cd5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214cd8:	48 98                	cltq   
  8004214cda:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214ce1:	ff 
  8004214ce2:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214ce6:	48 b8 e0 b6 22 04 80 	movabs $0x800422b6e0,%rax
  8004214ced:	00 00 00 
  8004214cf0:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

	for (i = 0; i < numSectionHeaders; i++)
  8004214cf7:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214cfb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214cfe:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004214d01:	0f 8c e4 fa ff ff    	jl     80042147eb <read_section_headers+0x219>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004214d07:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214d0b:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214d12:	48 01 d0             	add    %rdx,%rax
}
  8004214d15:	c9                   	leaveq 
  8004214d16:	c3                   	retq   

0000008004214d17 <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004214d17:	55                   	push   %rbp
  8004214d18:	48 89 e5             	mov    %rsp,%rbp
  8004214d1b:	48 83 ec 30          	sub    $0x30,%rsp
  8004214d1f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214d23:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004214d27:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004214d2b:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004214d2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214d33:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004214d37:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214d3b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214d3f:	48 01 d0             	add    %rdx,%rax
  8004214d42:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004214d46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d4a:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214d4f:	48 85 c0             	test   %rax,%rax
  8004214d52:	74 35                	je     8004214d89 <readseg+0x72>
  8004214d54:	48 b9 62 88 21 04 80 	movabs $0x8004218862,%rcx
  8004214d5b:	00 00 00 
  8004214d5e:	48 ba 3f 88 21 04 80 	movabs $0x800421883f,%rdx
  8004214d65:	00 00 00 
  8004214d68:	be c0 00 00 00       	mov    $0xc0,%esi
  8004214d6d:	48 bf 54 88 21 04 80 	movabs $0x8004218854,%rdi
  8004214d74:	00 00 00 
  8004214d77:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214d7c:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004214d83:	00 00 00 
  8004214d86:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004214d89:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004214d90:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004214d91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214d95:	48 c1 e8 09          	shr    $0x9,%rax
  8004214d99:	48 83 c0 01          	add    $0x1,%rax
  8004214d9d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004214da1:	eb 3c                	jmp    8004214ddf <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004214da3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214da7:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214dab:	48 89 d6             	mov    %rdx,%rsi
  8004214dae:	48 89 c7             	mov    %rax,%rdi
  8004214db1:	48 b8 a9 4e 21 04 80 	movabs $0x8004214ea9,%rax
  8004214db8:	00 00 00 
  8004214dbb:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004214dbd:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004214dc4:	00 
		*kvoffset += SECTSIZE;
  8004214dc5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214dc9:	48 8b 00             	mov    (%rax),%rax
  8004214dcc:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004214dd3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214dd7:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004214dda:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004214ddf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214de3:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004214de7:	72 ba                	jb     8004214da3 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004214de9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214ded:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214df2:	48 89 c2             	mov    %rax,%rdx
  8004214df5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214df9:	48 01 d0             	add    %rdx,%rax
  8004214dfc:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004214e02:	76 2f                	jbe    8004214e33 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004214e04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e08:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214e0c:	48 89 d6             	mov    %rdx,%rsi
  8004214e0f:	48 89 c7             	mov    %rax,%rdi
  8004214e12:	48 b8 a9 4e 21 04 80 	movabs $0x8004214ea9,%rax
  8004214e19:	00 00 00 
  8004214e1c:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004214e1e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e22:	48 8b 00             	mov    (%rax),%rax
  8004214e25:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004214e2c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e30:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004214e33:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e37:	48 8b 00             	mov    (%rax),%rax
  8004214e3a:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214e3f:	48 85 c0             	test   %rax,%rax
  8004214e42:	74 35                	je     8004214e79 <readseg+0x162>
  8004214e44:	48 b9 75 88 21 04 80 	movabs $0x8004218875,%rcx
  8004214e4b:	00 00 00 
  8004214e4e:	48 ba 3f 88 21 04 80 	movabs $0x800421883f,%rdx
  8004214e55:	00 00 00 
  8004214e58:	be d6 00 00 00       	mov    $0xd6,%esi
  8004214e5d:	48 bf 54 88 21 04 80 	movabs $0x8004218854,%rdi
  8004214e64:	00 00 00 
  8004214e67:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214e6c:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004214e73:	00 00 00 
  8004214e76:	41 ff d0             	callq  *%r8
}
  8004214e79:	90                   	nop
  8004214e7a:	c9                   	leaveq 
  8004214e7b:	c3                   	retq   

0000008004214e7c <waitdisk>:

void
waitdisk(void)
{
  8004214e7c:	55                   	push   %rbp
  8004214e7d:	48 89 e5             	mov    %rsp,%rbp
  8004214e80:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004214e84:	90                   	nop
  8004214e85:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004214e8c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214e8f:	89 c2                	mov    %eax,%edx
  8004214e91:	ec                   	in     (%dx),%al
  8004214e92:	88 45 fb             	mov    %al,-0x5(%rbp)
	return data;
  8004214e95:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004214e99:	0f b6 c0             	movzbl %al,%eax
  8004214e9c:	25 c0 00 00 00       	and    $0xc0,%eax
  8004214ea1:	83 f8 40             	cmp    $0x40,%eax
  8004214ea4:	75 df                	jne    8004214e85 <waitdisk+0x9>
		/* do nothing */;
}
  8004214ea6:	90                   	nop
  8004214ea7:	c9                   	leaveq 
  8004214ea8:	c3                   	retq   

0000008004214ea9 <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004214ea9:	55                   	push   %rbp
  8004214eaa:	48 89 e5             	mov    %rsp,%rbp
  8004214ead:	48 83 ec 50          	sub    $0x50,%rsp
  8004214eb1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004214eb5:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004214eb9:	48 b8 7c 4e 21 04 80 	movabs $0x8004214e7c,%rax
  8004214ec0:	00 00 00 
  8004214ec3:	ff d0                	callq  *%rax
  8004214ec5:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004214ecc:	c6 45 ce 01          	movb   $0x1,-0x32(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004214ed0:	0f b6 45 ce          	movzbl -0x32(%rbp),%eax
  8004214ed4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004214ed7:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004214ed8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214edc:	0f b6 c0             	movzbl %al,%eax
  8004214edf:	c7 45 f8 f3 01 00 00 	movl   $0x1f3,-0x8(%rbp)
  8004214ee6:	88 45 cf             	mov    %al,-0x31(%rbp)
  8004214ee9:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
  8004214eed:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004214ef0:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004214ef1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214ef5:	48 c1 e8 08          	shr    $0x8,%rax
  8004214ef9:	0f b6 c0             	movzbl %al,%eax
  8004214efc:	c7 45 f4 f4 01 00 00 	movl   $0x1f4,-0xc(%rbp)
  8004214f03:	88 45 d0             	mov    %al,-0x30(%rbp)
  8004214f06:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
  8004214f0a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214f0d:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004214f0e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214f12:	48 c1 e8 10          	shr    $0x10,%rax
  8004214f16:	0f b6 c0             	movzbl %al,%eax
  8004214f19:	c7 45 f0 f5 01 00 00 	movl   $0x1f5,-0x10(%rbp)
  8004214f20:	88 45 d1             	mov    %al,-0x2f(%rbp)
  8004214f23:	0f b6 45 d1          	movzbl -0x2f(%rbp),%eax
  8004214f27:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004214f2a:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004214f2b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214f2f:	48 c1 e8 18          	shr    $0x18,%rax
  8004214f33:	83 c8 e0             	or     $0xffffffe0,%eax
  8004214f36:	0f b6 c0             	movzbl %al,%eax
  8004214f39:	c7 45 ec f6 01 00 00 	movl   $0x1f6,-0x14(%rbp)
  8004214f40:	88 45 d2             	mov    %al,-0x2e(%rbp)
  8004214f43:	0f b6 45 d2          	movzbl -0x2e(%rbp),%eax
  8004214f47:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004214f4a:	ee                   	out    %al,(%dx)
  8004214f4b:	c7 45 e8 f7 01 00 00 	movl   $0x1f7,-0x18(%rbp)
  8004214f52:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004214f56:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004214f5a:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004214f5d:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004214f5e:	48 b8 7c 4e 21 04 80 	movabs $0x8004214e7c,%rax
  8004214f65:	00 00 00 
  8004214f68:	ff d0                	callq  *%rax
  8004214f6a:	c7 45 e4 f0 01 00 00 	movl   $0x1f0,-0x1c(%rbp)
  8004214f71:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214f75:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004214f79:	c7 45 d4 80 00 00 00 	movl   $0x80,-0x2c(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004214f80:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214f83:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214f87:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004214f8a:	48 89 ce             	mov    %rcx,%rsi
  8004214f8d:	48 89 f7             	mov    %rsi,%rdi
  8004214f90:	89 c1                	mov    %eax,%ecx
  8004214f92:	fc                   	cld    
  8004214f93:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004214f95:	89 c8                	mov    %ecx,%eax
  8004214f97:	48 89 fe             	mov    %rdi,%rsi
  8004214f9a:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  8004214f9e:	89 45 d4             	mov    %eax,-0x2c(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004214fa1:	90                   	nop
  8004214fa2:	c9                   	leaveq 
  8004214fa3:	c3                   	retq   
  8004214fa4:	0f 1f 40 00          	nopl   0x0(%rax)

0000008004214fa8 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004214fa8:	fa                   	cli    
	xorw    %ax, %ax
  8004214fa9:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  8004214fab:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004214fad:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004214faf:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004214fb1:	0f 01 16             	lgdt   (%rsi)
  8004214fb4:	e0 70                	loopne 8004215026 <start64+0x10>
	movl    %cr0, %eax
  8004214fb6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004214fb9:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  8004214fbd:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004214fc0:	ea                   	(bad)  
  8004214fc1:	1d                   	.byte 0x1d
  8004214fc2:	70 08                	jo     8004214fcc <start32+0x7>
	...

0000008004214fc5 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004214fc5:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004214fc9:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004214fcb:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004214fcd:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004214fcf:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004214fd3:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004214fd5:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  8004214fd7:	b8 20 00 00 00       	mov    $0x20,%eax

	movl %eax,%cr4
  8004214fdc:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004214fdf:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421c0a6 <bootstack+0x10a6>
	movl    %cr0, %eax
  8004214fe6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004214fe9:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004214fec:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004214fef:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004214ff4:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004214ff7:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004214ffc:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004214ffe:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004215002:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004215004:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004215007:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  800421500c:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  800421500f:	ea                   	(bad)  
  8004215010:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004215011:	70 00                	jo     8004215013 <start32+0x4e>
  8004215013:	00 08                	add    %cl,(%rax)
	...

0000008004215016 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004215016:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  800421501a:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  800421501c:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  800421501e:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215020:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215024:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215026:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004215028:	48 a1 18 37 36 04 80 	movabs 0x8004363718,%rax
  800421502f:	00 00 00 
	movq    %rax,%rsp
  8004215032:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004215035:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  800421503c:	48 b8 cb 03 20 04 80 	movabs $0x80042003cb,%rax
  8004215043:	00 00 00 
	call    *%rax
  8004215046:	ff d0                	callq  *%rax

0000008004215048 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004215048:	eb fe                	jmp    8004215048 <spin>
  800421504a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004215050 <gdt>:
	...
  8004215058:	ff                   	(bad)  
  8004215059:	ff 00                	incl   (%rax)
  800421505b:	00 00                	add    %al,(%rax)
  800421505d:	9a                   	(bad)  
  800421505e:	af                   	scas   %es:(%rdi),%eax
  800421505f:	00 ff                	add    %bh,%bh
  8004215061:	ff 00                	incl   (%rax)
  8004215063:	00 00                	add    %al,(%rax)
  8004215065:	92                   	xchg   %eax,%edx
  8004215066:	af                   	scas   %es:(%rdi),%eax
	...

0000008004215068 <gdtdesc>:
  8004215068:	17                   	(bad)  
  8004215069:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  800421506f:	90                   	nop

0000008004215070 <gdt32>:
	...
  8004215078:	ff                   	(bad)  
  8004215079:	ff 00                	incl   (%rax)
  800421507b:	00 00                	add    %al,(%rax)
  800421507d:	9a                   	(bad)  
  800421507e:	cf                   	iret   
  800421507f:	00 ff                	add    %bh,%bh
  8004215081:	ff 00                	incl   (%rax)
  8004215083:	00 00                	add    %al,(%rax)
  8004215085:	92                   	xchg   %eax,%edx
  8004215086:	cf                   	iret   
	...

0000008004215088 <gdt32desc>:
  8004215088:	17                   	(bad)  
  8004215089:	00 c8                	add    %cl,%al
  800421508b:	70 00                	jo     800421508d <gdt32desc+0x5>
	...

000000800421508e <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  800421508e:	90                   	nop

000000800421508f <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  800421508f:	55                   	push   %rbp
  8004215090:	48 89 e5             	mov    %rsp,%rbp
  8004215093:	48 83 ec 20          	sub    $0x20,%rsp
  8004215097:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421509b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  800421509e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  80042150a5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042150ac:	eb 1a                	jmp    80042150c8 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  80042150ae:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042150b1:	48 63 d0             	movslq %eax,%rdx
  80042150b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150b8:	48 01 d0             	add    %rdx,%rax
  80042150bb:	0f b6 00             	movzbl (%rax),%eax
  80042150be:	0f b6 c0             	movzbl %al,%eax
  80042150c1:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  80042150c4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042150c8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042150cb:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80042150ce:	7c de                	jl     80042150ae <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  80042150d0:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  80042150d3:	c9                   	leaveq 
  80042150d4:	c3                   	retq   

00000080042150d5 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  80042150d5:	55                   	push   %rbp
  80042150d6:	48 89 e5             	mov    %rsp,%rbp
  80042150d9:	48 83 ec 40          	sub    $0x40,%rsp
  80042150dd:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042150e1:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  80042150e4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042150e8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042150ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042150f0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042150f4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042150f7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042150fa:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004215101:	00 00 00 
  8004215104:	48 8b 00             	mov    (%rax),%rax
  8004215107:	48 39 c2             	cmp    %rax,%rdx
  800421510a:	72 32                	jb     800421513e <mpsearch1+0x69>
  800421510c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215110:	48 89 c1             	mov    %rax,%rcx
  8004215113:	48 ba 90 88 21 04 80 	movabs $0x8004218890,%rdx
  800421511a:	00 00 00 
  800421511d:	be 58 00 00 00       	mov    $0x58,%esi
  8004215122:	48 bf b3 88 21 04 80 	movabs $0x80042188b3,%rdi
  8004215129:	00 00 00 
  800421512c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215131:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004215138:	00 00 00 
  800421513b:	41 ff d0             	callq  *%r8
  800421513e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215145:	00 00 00 
  8004215148:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421514c:	48 01 d0             	add    %rdx,%rax
  800421514f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215153:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004215156:	48 63 d0             	movslq %eax,%rdx
  8004215159:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421515d:	48 01 d0             	add    %rdx,%rax
  8004215160:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004215164:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215168:	48 c1 e8 0c          	shr    $0xc,%rax
  800421516c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421516f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215172:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004215179:	00 00 00 
  800421517c:	48 8b 00             	mov    (%rax),%rax
  800421517f:	48 39 c2             	cmp    %rax,%rdx
  8004215182:	72 32                	jb     80042151b6 <mpsearch1+0xe1>
  8004215184:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215188:	48 89 c1             	mov    %rax,%rcx
  800421518b:	48 ba 90 88 21 04 80 	movabs $0x8004218890,%rdx
  8004215192:	00 00 00 
  8004215195:	be 58 00 00 00       	mov    $0x58,%esi
  800421519a:	48 bf b3 88 21 04 80 	movabs $0x80042188b3,%rdi
  80042151a1:	00 00 00 
  80042151a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042151a9:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  80042151b0:	00 00 00 
  80042151b3:	41 ff d0             	callq  *%r8
  80042151b6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042151bd:	00 00 00 
  80042151c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042151c4:	48 01 d0             	add    %rdx,%rax
  80042151c7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  80042151cb:	eb 4d                	jmp    800421521a <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042151cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042151d1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042151d6:	48 be c3 88 21 04 80 	movabs $0x80042188c3,%rsi
  80042151dd:	00 00 00 
  80042151e0:	48 89 c7             	mov    %rax,%rdi
  80042151e3:	48 b8 4d ee 20 04 80 	movabs $0x800420ee4d,%rax
  80042151ea:	00 00 00 
  80042151ed:	ff d0                	callq  *%rax
  80042151ef:	85 c0                	test   %eax,%eax
  80042151f1:	75 22                	jne    8004215215 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  80042151f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042151f7:	be 10 00 00 00       	mov    $0x10,%esi
  80042151fc:	48 89 c7             	mov    %rax,%rdi
  80042151ff:	48 b8 8f 50 21 04 80 	movabs $0x800421508f,%rax
  8004215206:	00 00 00 
  8004215209:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  800421520b:	84 c0                	test   %al,%al
  800421520d:	75 06                	jne    8004215215 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  800421520f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215213:	eb 14                	jmp    8004215229 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004215215:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  800421521a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421521e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004215222:	72 a9                	jb     80042151cd <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004215224:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215229:	c9                   	leaveq 
  800421522a:	c3                   	retq   

000000800421522b <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  800421522b:	55                   	push   %rbp
  800421522c:	48 89 e5             	mov    %rsp,%rbp
  800421522f:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004215233:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800421523a:	00 
  800421523b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421523f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215243:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004215246:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215249:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004215250:	00 00 00 
  8004215253:	48 8b 00             	mov    (%rax),%rax
  8004215256:	48 39 c2             	cmp    %rax,%rdx
  8004215259:	72 32                	jb     800421528d <mpsearch+0x62>
  800421525b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421525f:	48 89 c1             	mov    %rax,%rcx
  8004215262:	48 ba 90 88 21 04 80 	movabs $0x8004218890,%rdx
  8004215269:	00 00 00 
  800421526c:	be 70 00 00 00       	mov    $0x70,%esi
  8004215271:	48 bf b3 88 21 04 80 	movabs $0x80042188b3,%rdi
  8004215278:	00 00 00 
  800421527b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215280:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004215287:	00 00 00 
  800421528a:	41 ff d0             	callq  *%r8
  800421528d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215294:	00 00 00 
  8004215297:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421529b:	48 01 d0             	add    %rdx,%rax
  800421529e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  80042152a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152a6:	48 83 c0 0e          	add    $0xe,%rax
  80042152aa:	0f b7 00             	movzwl (%rax),%eax
  80042152ad:	0f b7 c0             	movzwl %ax,%eax
  80042152b0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  80042152b3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042152b7:	74 2c                	je     80042152e5 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  80042152b9:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  80042152bd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042152c0:	be 00 04 00 00       	mov    $0x400,%esi
  80042152c5:	48 89 c7             	mov    %rax,%rdi
  80042152c8:	48 b8 d5 50 21 04 80 	movabs $0x80042150d5,%rax
  80042152cf:	00 00 00 
  80042152d2:	ff d0                	callq  *%rax
  80042152d4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042152d8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042152dd:	74 49                	je     8004215328 <mpsearch+0xfd>
			return mp;
  80042152df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042152e3:	eb 59                	jmp    800421533e <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  80042152e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042152e9:	48 83 c0 13          	add    $0x13,%rax
  80042152ed:	0f b7 00             	movzwl (%rax),%eax
  80042152f0:	0f b7 c0             	movzwl %ax,%eax
  80042152f3:	c1 e0 0a             	shl    $0xa,%eax
  80042152f6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  80042152f9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042152fc:	2d 00 04 00 00       	sub    $0x400,%eax
  8004215301:	89 c0                	mov    %eax,%eax
  8004215303:	be 00 04 00 00       	mov    $0x400,%esi
  8004215308:	48 89 c7             	mov    %rax,%rdi
  800421530b:	48 b8 d5 50 21 04 80 	movabs $0x80042150d5,%rax
  8004215312:	00 00 00 
  8004215315:	ff d0                	callq  *%rax
  8004215317:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421531b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004215320:	74 06                	je     8004215328 <mpsearch+0xfd>
			return mp;
  8004215322:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215326:	eb 16                	jmp    800421533e <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004215328:	be 00 00 01 00       	mov    $0x10000,%esi
  800421532d:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004215332:	48 b8 d5 50 21 04 80 	movabs $0x80042150d5,%rax
  8004215339:	00 00 00 
  800421533c:	ff d0                	callq  *%rax
}
  800421533e:	c9                   	leaveq 
  800421533f:	c3                   	retq   

0000008004215340 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004215340:	55                   	push   %rbp
  8004215341:	48 89 e5             	mov    %rsp,%rbp
  8004215344:	48 83 ec 30          	sub    $0x30,%rsp
  8004215348:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  800421534c:	48 b8 2b 52 21 04 80 	movabs $0x800421522b,%rax
  8004215353:	00 00 00 
  8004215356:	ff d0                	callq  *%rax
  8004215358:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421535c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215361:	75 0a                	jne    800421536d <mpconfig+0x2d>
		return NULL;
  8004215363:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215368:	e9 f8 01 00 00       	jmpq   8004215565 <mpconfig+0x225>
	if (mp->physaddr == 0 || mp->type != 0) {
  800421536d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215371:	8b 40 04             	mov    0x4(%rax),%eax
  8004215374:	85 c0                	test   %eax,%eax
  8004215376:	74 0c                	je     8004215384 <mpconfig+0x44>
  8004215378:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421537c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004215380:	84 c0                	test   %al,%al
  8004215382:	74 25                	je     80042153a9 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004215384:	48 bf c8 88 21 04 80 	movabs $0x80042188c8,%rdi
  800421538b:	00 00 00 
  800421538e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215393:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800421539a:	00 00 00 
  800421539d:	ff d2                	callq  *%rdx
		return NULL;
  800421539f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042153a4:	e9 bc 01 00 00       	jmpq   8004215565 <mpconfig+0x225>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  80042153a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042153ad:	8b 40 04             	mov    0x4(%rax),%eax
  80042153b0:	89 c0                	mov    %eax,%eax
  80042153b2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042153b6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153ba:	48 c1 e8 0c          	shr    $0xc,%rax
  80042153be:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042153c1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042153c4:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  80042153cb:	00 00 00 
  80042153ce:	48 8b 00             	mov    (%rax),%rax
  80042153d1:	48 39 c2             	cmp    %rax,%rdx
  80042153d4:	72 32                	jb     8004215408 <mpconfig+0xc8>
  80042153d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153da:	48 89 c1             	mov    %rax,%rcx
  80042153dd:	48 ba 90 88 21 04 80 	movabs $0x8004218890,%rdx
  80042153e4:	00 00 00 
  80042153e7:	be 91 00 00 00       	mov    $0x91,%esi
  80042153ec:	48 bf b3 88 21 04 80 	movabs $0x80042188b3,%rdi
  80042153f3:	00 00 00 
  80042153f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042153fb:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004215402:	00 00 00 
  8004215405:	41 ff d0             	callq  *%r8
  8004215408:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421540f:	00 00 00 
  8004215412:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215416:	48 01 d0             	add    %rdx,%rax
  8004215419:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  800421541d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215421:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215426:	48 be f5 88 21 04 80 	movabs $0x80042188f5,%rsi
  800421542d:	00 00 00 
  8004215430:	48 89 c7             	mov    %rax,%rdi
  8004215433:	48 b8 4d ee 20 04 80 	movabs $0x800420ee4d,%rax
  800421543a:	00 00 00 
  800421543d:	ff d0                	callq  *%rax
  800421543f:	85 c0                	test   %eax,%eax
  8004215441:	74 25                	je     8004215468 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004215443:	48 bf 00 89 21 04 80 	movabs $0x8004218900,%rdi
  800421544a:	00 00 00 
  800421544d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215452:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004215459:	00 00 00 
  800421545c:	ff d2                	callq  *%rdx
		return NULL;
  800421545e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215463:	e9 fd 00 00 00       	jmpq   8004215565 <mpconfig+0x225>
	}
	if (sum(conf, conf->length) != 0) {
  8004215468:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421546c:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004215470:	0f b7 d0             	movzwl %ax,%edx
  8004215473:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215477:	89 d6                	mov    %edx,%esi
  8004215479:	48 89 c7             	mov    %rax,%rdi
  800421547c:	48 b8 8f 50 21 04 80 	movabs $0x800421508f,%rax
  8004215483:	00 00 00 
  8004215486:	ff d0                	callq  *%rax
  8004215488:	84 c0                	test   %al,%al
  800421548a:	74 25                	je     80042154b1 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  800421548c:	48 bf 38 89 21 04 80 	movabs $0x8004218938,%rdi
  8004215493:	00 00 00 
  8004215496:	b8 00 00 00 00       	mov    $0x0,%eax
  800421549b:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042154a2:	00 00 00 
  80042154a5:	ff d2                	callq  *%rdx
		return NULL;
  80042154a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154ac:	e9 b4 00 00 00       	jmpq   8004215565 <mpconfig+0x225>
	}
	if (conf->version != 1 && conf->version != 4) {
  80042154b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042154b5:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042154b9:	3c 01                	cmp    $0x1,%al
  80042154bb:	74 3b                	je     80042154f8 <mpconfig+0x1b8>
  80042154bd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042154c1:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042154c5:	3c 04                	cmp    $0x4,%al
  80042154c7:	74 2f                	je     80042154f8 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  80042154c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042154cd:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042154d1:	0f b6 c0             	movzbl %al,%eax
  80042154d4:	89 c6                	mov    %eax,%esi
  80042154d6:	48 bf 60 89 21 04 80 	movabs $0x8004218960,%rdi
  80042154dd:	00 00 00 
  80042154e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154e5:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042154ec:	00 00 00 
  80042154ef:	ff d2                	callq  *%rdx
		return NULL;
  80042154f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154f6:	eb 6d                	jmp    8004215565 <mpconfig+0x225>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  80042154f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042154fc:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8004215500:	0f b7 c0             	movzwl %ax,%eax
  8004215503:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215507:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  800421550b:	0f b7 ca             	movzwl %dx,%ecx
  800421550e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215512:	48 01 ca             	add    %rcx,%rdx
  8004215515:	89 c6                	mov    %eax,%esi
  8004215517:	48 89 d7             	mov    %rdx,%rdi
  800421551a:	48 b8 8f 50 21 04 80 	movabs $0x800421508f,%rax
  8004215521:	00 00 00 
  8004215524:	ff d0                	callq  *%rax
  8004215526:	89 c2                	mov    %eax,%edx
  8004215528:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421552c:	0f b6 40 2a          	movzbl 0x2a(%rax),%eax
  8004215530:	38 c2                	cmp    %al,%dl
  8004215532:	74 22                	je     8004215556 <mpconfig+0x216>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004215534:	48 bf 80 89 21 04 80 	movabs $0x8004218980,%rdi
  800421553b:	00 00 00 
  800421553e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215543:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800421554a:	00 00 00 
  800421554d:	ff d2                	callq  *%rdx
		return NULL;
  800421554f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215554:	eb 0f                	jmp    8004215565 <mpconfig+0x225>
	}
	*pmp = mp;
  8004215556:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421555a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421555e:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  8004215561:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004215565:	c9                   	leaveq 
  8004215566:	c3                   	retq   

0000008004215567 <mp_init>:

void
mp_init(void)
{
  8004215567:	55                   	push   %rbp
  8004215568:	48 89 e5             	mov    %rsp,%rbp
  800421556b:	48 83 ec 40          	sub    $0x40,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  800421556f:	48 b8 e0 53 36 04 80 	movabs $0x80043653e0,%rax
  8004215576:	00 00 00 
  8004215579:	48 be 20 50 36 04 80 	movabs $0x8004365020,%rsi
  8004215580:	00 00 00 
  8004215583:	48 89 30             	mov    %rsi,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004215586:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  800421558a:	48 89 c7             	mov    %rax,%rdi
  800421558d:	48 b8 40 53 21 04 80 	movabs $0x8004215340,%rax
  8004215594:	00 00 00 
  8004215597:	ff d0                	callq  *%rax
  8004215599:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421559d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042155a2:	0f 84 7f 03 00 00    	je     8004215927 <mp_init+0x3c0>
		return;
	ismp = 1;
  80042155a8:	48 b8 00 50 36 04 80 	movabs $0x8004365000,%rax
  80042155af:	00 00 00 
  80042155b2:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  80042155b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042155bc:	8b 40 24             	mov    0x24(%rax),%eax
  80042155bf:	89 c2                	mov    %eax,%edx
  80042155c1:	48 b8 00 60 3e 04 80 	movabs $0x80043e6000,%rax
  80042155c8:	00 00 00 
  80042155cb:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042155ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042155d2:	48 83 c0 2c          	add    $0x2c,%rax
  80042155d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042155da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042155e1:	e9 24 02 00 00       	jmpq   800421580a <mp_init+0x2a3>
		switch (*p) {
  80042155e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042155ea:	0f b6 00             	movzbl (%rax),%eax
  80042155ed:	0f b6 c0             	movzbl %al,%eax
  80042155f0:	85 c0                	test   %eax,%eax
  80042155f2:	74 16                	je     800421560a <mp_init+0xa3>
  80042155f4:	85 c0                	test   %eax,%eax
  80042155f6:	0f 88 c5 01 00 00    	js     80042157c1 <mp_init+0x25a>
  80042155fc:	83 f8 04             	cmp    $0x4,%eax
  80042155ff:	0f 8f bc 01 00 00    	jg     80042157c1 <mp_init+0x25a>
  8004215605:	e9 b0 01 00 00       	jmpq   80042157ba <mp_init+0x253>
		case MPPROC:
			proc = (struct mpproc *)p;
  800421560a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421560e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  8004215612:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215616:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  800421561a:	0f b6 c0             	movzbl %al,%eax
  800421561d:	83 e0 02             	and    $0x2,%eax
  8004215620:	85 c0                	test   %eax,%eax
  8004215622:	74 5b                	je     800421567f <mp_init+0x118>
				bootcpu = &cpus[ncpu];
  8004215624:	48 b8 e8 53 36 04 80 	movabs $0x80043653e8,%rax
  800421562b:	00 00 00 
  800421562e:	8b 00                	mov    (%rax),%eax
  8004215630:	48 98                	cltq   
  8004215632:	48 89 c2             	mov    %rax,%rdx
  8004215635:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  800421563c:	00 
  800421563d:	48 89 c2             	mov    %rax,%rdx
  8004215640:	48 89 d0             	mov    %rdx,%rax
  8004215643:	48 c1 e0 04          	shl    $0x4,%rax
  8004215647:	48 29 d0             	sub    %rdx,%rax
  800421564a:	48 ba 20 50 36 04 80 	movabs $0x8004365020,%rdx
  8004215651:	00 00 00 
  8004215654:	48 01 c2             	add    %rax,%rdx
  8004215657:	48 b8 e0 53 36 04 80 	movabs $0x80043653e0,%rax
  800421565e:	00 00 00 
  8004215661:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  8004215664:	48 bf ad 89 21 04 80 	movabs $0x80042189ad,%rdi
  800421566b:	00 00 00 
  800421566e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215673:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  800421567a:	00 00 00 
  800421567d:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  800421567f:	48 b8 e8 53 36 04 80 	movabs $0x80043653e8,%rax
  8004215686:	00 00 00 
  8004215689:	8b 00                	mov    (%rax),%eax
  800421568b:	83 f8 07             	cmp    $0x7,%eax
  800421568e:	0f 8f f7 00 00 00    	jg     800421578b <mp_init+0x224>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  8004215694:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215698:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  800421569c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156a0:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042156a4:	0f b6 f0             	movzbl %al,%esi
  80042156a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156ab:	8b 78 08             	mov    0x8(%rax),%edi
  80042156ae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156b2:	4c 8d 50 04          	lea    0x4(%rax),%r10
  80042156b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156ba:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  80042156be:	0f b6 c8             	movzbl %al,%ecx
  80042156c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156c5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80042156c9:	0f b6 d0             	movzbl %al,%edx
  80042156cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156d0:	0f b6 00             	movzbl (%rax),%eax
  80042156d3:	0f b6 c0             	movzbl %al,%eax
  80042156d6:	41 50                	push   %r8
  80042156d8:	56                   	push   %rsi
  80042156d9:	41 89 f9             	mov    %edi,%r9d
  80042156dc:	4d 89 d0             	mov    %r10,%r8
  80042156df:	89 c6                	mov    %eax,%esi
  80042156e1:	48 bf c0 89 21 04 80 	movabs $0x80042189c0,%rdi
  80042156e8:	00 00 00 
  80042156eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042156f0:	49 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%r10
  80042156f7:	00 00 00 
  80042156fa:	41 ff d2             	callq  *%r10
  80042156fd:	48 83 c4 10          	add    $0x10,%rsp
				if (proc->flags & MPROC_EN) {
  8004215701:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215705:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004215709:	0f b6 c0             	movzbl %al,%eax
  800421570c:	83 e0 01             	and    $0x1,%eax
  800421570f:	85 c0                	test   %eax,%eax
  8004215711:	74 5b                	je     800421576e <mp_init+0x207>
					cpus[ncpu].cpu_id = ncpu;
  8004215713:	48 b8 e8 53 36 04 80 	movabs $0x80043653e8,%rax
  800421571a:	00 00 00 
  800421571d:	8b 08                	mov    (%rax),%ecx
  800421571f:	48 b8 e8 53 36 04 80 	movabs $0x80043653e8,%rax
  8004215726:	00 00 00 
  8004215729:	8b 00                	mov    (%rax),%eax
  800421572b:	89 c6                	mov    %eax,%esi
  800421572d:	48 ba 20 50 36 04 80 	movabs $0x8004365020,%rdx
  8004215734:	00 00 00 
  8004215737:	48 63 c1             	movslq %ecx,%rax
  800421573a:	48 c1 e0 03          	shl    $0x3,%rax
  800421573e:	48 89 c1             	mov    %rax,%rcx
  8004215741:	48 c1 e1 04          	shl    $0x4,%rcx
  8004215745:	48 29 c1             	sub    %rax,%rcx
  8004215748:	48 89 c8             	mov    %rcx,%rax
  800421574b:	48 01 d0             	add    %rdx,%rax
  800421574e:	40 88 30             	mov    %sil,(%rax)
					ncpu++;
  8004215751:	48 b8 e8 53 36 04 80 	movabs $0x80043653e8,%rax
  8004215758:	00 00 00 
  800421575b:	8b 00                	mov    (%rax),%eax
  800421575d:	8d 50 01             	lea    0x1(%rax),%edx
  8004215760:	48 b8 e8 53 36 04 80 	movabs $0x80043653e8,%rax
  8004215767:	00 00 00 
  800421576a:	89 10                	mov    %edx,(%rax)
  800421576c:	eb 45                	jmp    80042157b3 <mp_init+0x24c>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  800421576e:	48 bf 10 8a 21 04 80 	movabs $0x8004218a10,%rdi
  8004215775:	00 00 00 
  8004215778:	b8 00 00 00 00       	mov    $0x0,%eax
  800421577d:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004215784:	00 00 00 
  8004215787:	ff d2                	callq  *%rdx
  8004215789:	eb 28                	jmp    80042157b3 <mp_init+0x24c>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  800421578b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421578f:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004215793:	0f b6 c0             	movzbl %al,%eax
  8004215796:	89 c6                	mov    %eax,%esi
  8004215798:	48 bf 40 8a 21 04 80 	movabs $0x8004218a40,%rdi
  800421579f:	00 00 00 
  80042157a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042157a7:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042157ae:	00 00 00 
  80042157b1:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  80042157b3:	48 83 45 f8 14       	addq   $0x14,-0x8(%rbp)
			continue;
  80042157b8:	eb 4c                	jmp    8004215806 <mp_init+0x29f>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  80042157ba:	48 83 45 f8 08       	addq   $0x8,-0x8(%rbp)
		continue;
  80042157bf:	eb 45                	jmp    8004215806 <mp_init+0x29f>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  80042157c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042157c5:	0f b6 00             	movzbl (%rax),%eax
  80042157c8:	0f b6 c0             	movzbl %al,%eax
  80042157cb:	89 c6                	mov    %eax,%esi
  80042157cd:	48 bf 68 8a 21 04 80 	movabs $0x8004218a68,%rdi
  80042157d4:	00 00 00 
  80042157d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042157dc:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042157e3:	00 00 00 
  80042157e6:	ff d2                	callq  *%rdx
			ismp = 0;
  80042157e8:	48 b8 00 50 36 04 80 	movabs $0x8004365000,%rax
  80042157ef:	00 00 00 
  80042157f2:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  80042157f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042157fc:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215800:	0f b7 c0             	movzwl %ax,%eax
  8004215803:	89 45 f4             	mov    %eax,-0xc(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004215806:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421580a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421580e:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215812:	0f b7 c0             	movzwl %ax,%eax
  8004215815:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004215818:	0f 87 c8 fd ff ff    	ja     80042155e6 <mp_init+0x7f>
			i = conf->entry;
		}
	}


	bootcpu->cpu_status = CPU_STARTED;
  800421581e:	48 b8 e0 53 36 04 80 	movabs $0x80043653e0,%rax
  8004215825:	00 00 00 
  8004215828:	48 8b 00             	mov    (%rax),%rax
  800421582b:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  8004215832:	48 b8 00 50 36 04 80 	movabs $0x8004365000,%rax
  8004215839:	00 00 00 
  800421583c:	8b 00                	mov    (%rax),%eax
  800421583e:	85 c0                	test   %eax,%eax
  8004215840:	75 41                	jne    8004215883 <mp_init+0x31c>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  8004215842:	48 b8 e8 53 36 04 80 	movabs $0x80043653e8,%rax
  8004215849:	00 00 00 
  800421584c:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  8004215852:	48 b8 00 60 3e 04 80 	movabs $0x80043e6000,%rax
  8004215859:	00 00 00 
  800421585c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  8004215863:	48 bf 88 8a 21 04 80 	movabs $0x8004218a88,%rdi
  800421586a:	00 00 00 
  800421586d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215872:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  8004215879:	00 00 00 
  800421587c:	ff d2                	callq  *%rdx
		return;
  800421587e:	e9 a5 00 00 00       	jmpq   8004215928 <mp_init+0x3c1>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  8004215883:	48 b8 e8 53 36 04 80 	movabs $0x80043653e8,%rax
  800421588a:	00 00 00 
  800421588d:	8b 10                	mov    (%rax),%edx
  800421588f:	48 b8 e0 53 36 04 80 	movabs $0x80043653e0,%rax
  8004215896:	00 00 00 
  8004215899:	48 8b 00             	mov    (%rax),%rax
  800421589c:	0f b6 00             	movzbl (%rax),%eax
  800421589f:	0f b6 c0             	movzbl %al,%eax
  80042158a2:	89 c6                	mov    %eax,%esi
  80042158a4:	48 bf b4 8a 21 04 80 	movabs $0x8004218ab4,%rdi
  80042158ab:	00 00 00 
  80042158ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80042158b3:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  80042158ba:	00 00 00 
  80042158bd:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  80042158bf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042158c3:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  80042158c7:	84 c0                	test   %al,%al
  80042158c9:	74 5d                	je     8004215928 <mp_init+0x3c1>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  80042158cb:	48 bf d8 8a 21 04 80 	movabs $0x8004218ad8,%rdi
  80042158d2:	00 00 00 
  80042158d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042158da:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042158e1:	00 00 00 
  80042158e4:	ff d2                	callq  *%rdx
  80042158e6:	c7 45 dc 22 00 00 00 	movl   $0x22,-0x24(%rbp)
  80042158ed:	c6 45 d1 70          	movb   $0x70,-0x2f(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042158f1:	0f b6 45 d1          	movzbl -0x2f(%rbp),%eax
  80042158f5:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042158f8:	ee                   	out    %al,(%dx)
  80042158f9:	c7 45 d8 23 00 00 00 	movl   $0x23,-0x28(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215900:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8004215903:	89 c2                	mov    %eax,%edx
  8004215905:	ec                   	in     (%dx),%al
  8004215906:	88 45 d2             	mov    %al,-0x2e(%rbp)
	return data;
  8004215909:	0f b6 45 d2          	movzbl -0x2e(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  800421590d:	83 c8 01             	or     $0x1,%eax
  8004215910:	0f b6 c0             	movzbl %al,%eax
  8004215913:	c7 45 d4 23 00 00 00 	movl   $0x23,-0x2c(%rbp)
  800421591a:	88 45 d3             	mov    %al,-0x2d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800421591d:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004215921:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215924:	ee                   	out    %al,(%dx)
  8004215925:	eb 01                	jmp    8004215928 <mp_init+0x3c1>
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
	if ((conf = mpconfig(&mp)) == 0)
		return;
  8004215927:	90                   	nop
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
	}
}
  8004215928:	c9                   	leaveq 
  8004215929:	c3                   	retq   

000000800421592a <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  800421592a:	55                   	push   %rbp
  800421592b:	48 89 e5             	mov    %rsp,%rbp
  800421592e:	48 83 ec 08          	sub    $0x8,%rsp
  8004215932:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004215935:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  8004215938:	48 b8 08 60 3e 04 80 	movabs $0x80043e6008,%rax
  800421593f:	00 00 00 
  8004215942:	48 8b 00             	mov    (%rax),%rax
  8004215945:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215948:	48 63 d2             	movslq %edx,%rdx
  800421594b:	48 c1 e2 02          	shl    $0x2,%rdx
  800421594f:	48 01 c2             	add    %rax,%rdx
  8004215952:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004215955:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  8004215957:	48 b8 08 60 3e 04 80 	movabs $0x80043e6008,%rax
  800421595e:	00 00 00 
  8004215961:	48 8b 00             	mov    (%rax),%rax
  8004215964:	48 83 c0 20          	add    $0x20,%rax
  8004215968:	8b 00                	mov    (%rax),%eax
}
  800421596a:	90                   	nop
  800421596b:	c9                   	leaveq 
  800421596c:	c3                   	retq   

000000800421596d <lapic_init>:

void
lapic_init(void)
{
  800421596d:	55                   	push   %rbp
  800421596e:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  8004215971:	48 b8 00 60 3e 04 80 	movabs $0x80043e6000,%rax
  8004215978:	00 00 00 
  800421597b:	48 8b 00             	mov    (%rax),%rax
  800421597e:	48 85 c0             	test   %rax,%rax
  8004215981:	0f 84 e9 01 00 00    	je     8004215b70 <lapic_init+0x203>
		return;

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  8004215987:	48 b8 00 60 3e 04 80 	movabs $0x80043e6000,%rax
  800421598e:	00 00 00 
  8004215991:	48 8b 00             	mov    (%rax),%rax
  8004215994:	be 00 10 00 00       	mov    $0x1000,%esi
  8004215999:	48 89 c7             	mov    %rax,%rdi
  800421599c:	48 b8 c8 37 20 04 80 	movabs $0x80042037c8,%rax
  80042159a3:	00 00 00 
  80042159a6:	ff d0                	callq  *%rax
  80042159a8:	48 89 c2             	mov    %rax,%rdx
  80042159ab:	48 b8 08 60 3e 04 80 	movabs $0x80043e6008,%rax
  80042159b2:	00 00 00 
  80042159b5:	48 89 10             	mov    %rdx,(%rax)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  80042159b8:	be 27 01 00 00       	mov    $0x127,%esi
  80042159bd:	bf 3c 00 00 00       	mov    $0x3c,%edi
  80042159c2:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  80042159c9:	00 00 00 
  80042159cc:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  80042159ce:	be 0b 00 00 00       	mov    $0xb,%esi
  80042159d3:	bf f8 00 00 00       	mov    $0xf8,%edi
  80042159d8:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  80042159df:	00 00 00 
  80042159e2:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  80042159e4:	be 20 00 02 00       	mov    $0x20020,%esi
  80042159e9:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042159ee:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  80042159f5:	00 00 00 
  80042159f8:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  80042159fa:	be 80 96 98 00       	mov    $0x989680,%esi
  80042159ff:	bf e0 00 00 00       	mov    $0xe0,%edi
  8004215a04:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215a0b:	00 00 00 
  8004215a0e:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  8004215a10:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004215a17:	00 00 00 
  8004215a1a:	ff d0                	callq  *%rax
  8004215a1c:	48 98                	cltq   
  8004215a1e:	48 89 c2             	mov    %rax,%rdx
  8004215a21:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004215a28:	00 
  8004215a29:	48 89 c2             	mov    %rax,%rdx
  8004215a2c:	48 89 d0             	mov    %rdx,%rax
  8004215a2f:	48 c1 e0 04          	shl    $0x4,%rax
  8004215a33:	48 29 d0             	sub    %rdx,%rax
  8004215a36:	48 ba 20 50 36 04 80 	movabs $0x8004365020,%rdx
  8004215a3d:	00 00 00 
  8004215a40:	48 01 c2             	add    %rax,%rdx
  8004215a43:	48 b8 e0 53 36 04 80 	movabs $0x80043653e0,%rax
  8004215a4a:	00 00 00 
  8004215a4d:	48 8b 00             	mov    (%rax),%rax
  8004215a50:	48 39 c2             	cmp    %rax,%rdx
  8004215a53:	74 16                	je     8004215a6b <lapic_init+0xfe>
		lapicw(LINT0, MASKED);
  8004215a55:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215a5a:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004215a5f:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215a66:	00 00 00 
  8004215a69:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004215a6b:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215a70:	bf d8 00 00 00       	mov    $0xd8,%edi
  8004215a75:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215a7c:	00 00 00 
  8004215a7f:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  8004215a81:	48 b8 08 60 3e 04 80 	movabs $0x80043e6008,%rax
  8004215a88:	00 00 00 
  8004215a8b:	48 8b 00             	mov    (%rax),%rax
  8004215a8e:	48 83 c0 30          	add    $0x30,%rax
  8004215a92:	8b 00                	mov    (%rax),%eax
  8004215a94:	c1 e8 10             	shr    $0x10,%eax
  8004215a97:	0f b6 c0             	movzbl %al,%eax
  8004215a9a:	83 f8 03             	cmp    $0x3,%eax
  8004215a9d:	76 16                	jbe    8004215ab5 <lapic_init+0x148>
		lapicw(PCINT, MASKED);
  8004215a9f:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215aa4:	bf d0 00 00 00       	mov    $0xd0,%edi
  8004215aa9:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215ab0:	00 00 00 
  8004215ab3:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  8004215ab5:	be 33 00 00 00       	mov    $0x33,%esi
  8004215aba:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004215abf:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215ac6:	00 00 00 
  8004215ac9:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004215acb:	be 00 00 00 00       	mov    $0x0,%esi
  8004215ad0:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004215ad5:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215adc:	00 00 00 
  8004215adf:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004215ae1:	be 00 00 00 00       	mov    $0x0,%esi
  8004215ae6:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004215aeb:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215af2:	00 00 00 
  8004215af5:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004215af7:	be 00 00 00 00       	mov    $0x0,%esi
  8004215afc:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004215b01:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215b08:	00 00 00 
  8004215b0b:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004215b0d:	be 00 00 00 00       	mov    $0x0,%esi
  8004215b12:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215b17:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215b1e:	00 00 00 
  8004215b21:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004215b23:	be 00 85 08 00       	mov    $0x88500,%esi
  8004215b28:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215b2d:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215b34:	00 00 00 
  8004215b37:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  8004215b39:	90                   	nop
  8004215b3a:	48 b8 08 60 3e 04 80 	movabs $0x80043e6008,%rax
  8004215b41:	00 00 00 
  8004215b44:	48 8b 00             	mov    (%rax),%rax
  8004215b47:	48 05 00 03 00 00    	add    $0x300,%rax
  8004215b4d:	8b 00                	mov    (%rax),%eax
  8004215b4f:	25 00 10 00 00       	and    $0x1000,%eax
  8004215b54:	85 c0                	test   %eax,%eax
  8004215b56:	75 e2                	jne    8004215b3a <lapic_init+0x1cd>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004215b58:	be 00 00 00 00       	mov    $0x0,%esi
  8004215b5d:	bf 20 00 00 00       	mov    $0x20,%edi
  8004215b62:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215b69:	00 00 00 
  8004215b6c:	ff d0                	callq  *%rax
  8004215b6e:	eb 01                	jmp    8004215b71 <lapic_init+0x204>

void
lapic_init(void)
{
	if (!lapicaddr)
		return;
  8004215b70:	90                   	nop
	while(lapic[ICRLO] & DELIVS)
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
}
  8004215b71:	5d                   	pop    %rbp
  8004215b72:	c3                   	retq   

0000008004215b73 <cpunum>:

int
cpunum(void)
{
  8004215b73:	55                   	push   %rbp
  8004215b74:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004215b77:	48 b8 08 60 3e 04 80 	movabs $0x80043e6008,%rax
  8004215b7e:	00 00 00 
  8004215b81:	48 8b 00             	mov    (%rax),%rax
  8004215b84:	48 85 c0             	test   %rax,%rax
  8004215b87:	74 18                	je     8004215ba1 <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004215b89:	48 b8 08 60 3e 04 80 	movabs $0x80043e6008,%rax
  8004215b90:	00 00 00 
  8004215b93:	48 8b 00             	mov    (%rax),%rax
  8004215b96:	48 83 c0 20          	add    $0x20,%rax
  8004215b9a:	8b 00                	mov    (%rax),%eax
  8004215b9c:	c1 e8 18             	shr    $0x18,%eax
  8004215b9f:	eb 05                	jmp    8004215ba6 <cpunum+0x33>
	return 0;
  8004215ba1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215ba6:	5d                   	pop    %rbp
  8004215ba7:	c3                   	retq   

0000008004215ba8 <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004215ba8:	55                   	push   %rbp
  8004215ba9:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004215bac:	48 b8 08 60 3e 04 80 	movabs $0x80043e6008,%rax
  8004215bb3:	00 00 00 
  8004215bb6:	48 8b 00             	mov    (%rax),%rax
  8004215bb9:	48 85 c0             	test   %rax,%rax
  8004215bbc:	74 16                	je     8004215bd4 <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004215bbe:	be 00 00 00 00       	mov    $0x0,%esi
  8004215bc3:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004215bc8:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215bcf:	00 00 00 
  8004215bd2:	ff d0                	callq  *%rax
}
  8004215bd4:	90                   	nop
  8004215bd5:	5d                   	pop    %rbp
  8004215bd6:	c3                   	retq   

0000008004215bd7 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004215bd7:	55                   	push   %rbp
  8004215bd8:	48 89 e5             	mov    %rsp,%rbp
  8004215bdb:	48 83 ec 08          	sub    $0x8,%rsp
  8004215bdf:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004215be2:	90                   	nop
  8004215be3:	c9                   	leaveq 
  8004215be4:	c3                   	retq   

0000008004215be5 <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004215be5:	55                   	push   %rbp
  8004215be6:	48 89 e5             	mov    %rsp,%rbp
  8004215be9:	48 83 ec 40          	sub    $0x40,%rsp
  8004215bed:	89 f8                	mov    %edi,%eax
  8004215bef:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004215bf2:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004215bf5:	c7 45 f8 70 00 00 00 	movl   $0x70,-0x8(%rbp)
  8004215bfc:	c6 45 da 0f          	movb   $0xf,-0x26(%rbp)
  8004215c00:	0f b6 45 da          	movzbl -0x26(%rbp),%eax
  8004215c04:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004215c07:	ee                   	out    %al,(%dx)
  8004215c08:	c7 45 dc 71 00 00 00 	movl   $0x71,-0x24(%rbp)
  8004215c0f:	c6 45 db 0a          	movb   $0xa,-0x25(%rbp)
  8004215c13:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004215c17:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215c1a:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004215c1b:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004215c22:	00 
  8004215c23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c27:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215c2b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215c2e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215c31:	48 b8 30 37 36 04 80 	movabs $0x8004363730,%rax
  8004215c38:	00 00 00 
  8004215c3b:	48 8b 00             	mov    (%rax),%rax
  8004215c3e:	48 39 c2             	cmp    %rax,%rdx
  8004215c41:	72 32                	jb     8004215c75 <lapic_startap+0x90>
  8004215c43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c47:	48 89 c1             	mov    %rax,%rcx
  8004215c4a:	48 ba 20 8b 21 04 80 	movabs $0x8004218b20,%rdx
  8004215c51:	00 00 00 
  8004215c54:	be 98 00 00 00       	mov    $0x98,%esi
  8004215c59:	48 bf 43 8b 21 04 80 	movabs $0x8004218b43,%rdi
  8004215c60:	00 00 00 
  8004215c63:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215c68:	49 b8 9b 04 20 04 80 	movabs $0x800420049b,%r8
  8004215c6f:	00 00 00 
  8004215c72:	41 ff d0             	callq  *%r8
  8004215c75:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004215c7c:	00 00 00 
  8004215c7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215c83:	48 01 d0             	add    %rdx,%rax
  8004215c86:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004215c8a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215c8e:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004215c93:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215c97:	48 83 c0 02          	add    $0x2,%rax
  8004215c9b:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004215c9e:	c1 ea 04             	shr    $0x4,%edx
  8004215ca1:	66 89 10             	mov    %dx,(%rax)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004215ca4:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215ca8:	c1 e0 18             	shl    $0x18,%eax
  8004215cab:	89 c6                	mov    %eax,%esi
  8004215cad:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215cb2:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215cb9:	00 00 00 
  8004215cbc:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004215cbe:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004215cc3:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215cc8:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215ccf:	00 00 00 
  8004215cd2:	ff d0                	callq  *%rax
	microdelay(200);
  8004215cd4:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215cd9:	48 b8 d7 5b 21 04 80 	movabs $0x8004215bd7,%rax
  8004215ce0:	00 00 00 
  8004215ce3:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004215ce5:	be 00 85 00 00       	mov    $0x8500,%esi
  8004215cea:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215cef:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215cf6:	00 00 00 
  8004215cf9:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004215cfb:	bf 64 00 00 00       	mov    $0x64,%edi
  8004215d00:	48 b8 d7 5b 21 04 80 	movabs $0x8004215bd7,%rax
  8004215d07:	00 00 00 
  8004215d0a:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004215d0c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215d13:	eb 4b                	jmp    8004215d60 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004215d15:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215d19:	c1 e0 18             	shl    $0x18,%eax
  8004215d1c:	89 c6                	mov    %eax,%esi
  8004215d1e:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215d23:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215d2a:	00 00 00 
  8004215d2d:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004215d2f:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004215d32:	c1 e8 0c             	shr    $0xc,%eax
  8004215d35:	80 cc 06             	or     $0x6,%ah
  8004215d38:	89 c6                	mov    %eax,%esi
  8004215d3a:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215d3f:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215d46:	00 00 00 
  8004215d49:	ff d0                	callq  *%rax
		microdelay(200);
  8004215d4b:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215d50:	48 b8 d7 5b 21 04 80 	movabs $0x8004215bd7,%rax
  8004215d57:	00 00 00 
  8004215d5a:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004215d5c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215d60:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004215d64:	7e af                	jle    8004215d15 <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  8004215d66:	90                   	nop
  8004215d67:	c9                   	leaveq 
  8004215d68:	c3                   	retq   

0000008004215d69 <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004215d69:	55                   	push   %rbp
  8004215d6a:	48 89 e5             	mov    %rsp,%rbp
  8004215d6d:	48 83 ec 08          	sub    $0x8,%rsp
  8004215d71:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004215d74:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215d77:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004215d7c:	89 c6                	mov    %eax,%esi
  8004215d7e:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215d83:	48 b8 2a 59 21 04 80 	movabs $0x800421592a,%rax
  8004215d8a:	00 00 00 
  8004215d8d:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004215d8f:	90                   	nop
  8004215d90:	48 b8 08 60 3e 04 80 	movabs $0x80043e6008,%rax
  8004215d97:	00 00 00 
  8004215d9a:	48 8b 00             	mov    (%rax),%rax
  8004215d9d:	48 05 00 03 00 00    	add    $0x300,%rax
  8004215da3:	8b 00                	mov    (%rax),%eax
  8004215da5:	25 00 10 00 00       	and    $0x1000,%eax
  8004215daa:	85 c0                	test   %eax,%eax
  8004215dac:	75 e2                	jne    8004215d90 <lapic_ipi+0x27>
		;
}
  8004215dae:	90                   	nop
  8004215daf:	c9                   	leaveq 
  8004215db0:	c3                   	retq   

0000008004215db1 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004215db1:	55                   	push   %rbp
  8004215db2:	48 89 e5             	mov    %rsp,%rbp
  8004215db5:	48 83 ec 20          	sub    $0x20,%rsp
  8004215db9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215dbd:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004215dc0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215dc4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004215dc7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004215dcb:	f0 87 02             	lock xchg %eax,(%rdx)
  8004215dce:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004215dd1:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004215dd4:	c9                   	leaveq 
  8004215dd5:	c3                   	retq   

0000008004215dd6 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004215dd6:	55                   	push   %rbp
  8004215dd7:	48 89 e5             	mov    %rsp,%rbp
  8004215dda:	48 83 ec 28          	sub    $0x28,%rsp
  8004215dde:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

static __inline uint64_t
read_rbp(void)
{
	uint64_t rbp;
	__asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004215de2:	48 89 e8             	mov    %rbp,%rax
  8004215de5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return rbp;
  8004215de9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004215ded:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004215df1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215df8:	eb 45                	jmp    8004215e3f <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004215dfa:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215dff:	74 65                	je     8004215e66 <get_caller_pcs+0x90>
  8004215e01:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004215e08:	00 00 00 
  8004215e0b:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004215e0f:	76 55                	jbe    8004215e66 <get_caller_pcs+0x90>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004215e11:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215e14:	48 98                	cltq   
  8004215e16:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004215e1d:	00 
  8004215e1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215e22:	48 01 c2             	add    %rax,%rdx
  8004215e25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215e29:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215e2d:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004215e30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215e34:	48 8b 00             	mov    (%rax),%rax
  8004215e37:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004215e3b:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215e3f:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004215e43:	7e b5                	jle    8004215dfa <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004215e45:	eb 1f                	jmp    8004215e66 <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004215e47:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215e4a:	48 98                	cltq   
  8004215e4c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004215e53:	00 
  8004215e54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215e58:	48 01 d0             	add    %rdx,%rax
  8004215e5b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004215e62:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215e66:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004215e6a:	7e db                	jle    8004215e47 <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  8004215e6c:	90                   	nop
  8004215e6d:	c9                   	leaveq 
  8004215e6e:	c3                   	retq   

0000008004215e6f <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004215e6f:	55                   	push   %rbp
  8004215e70:	48 89 e5             	mov    %rsp,%rbp
  8004215e73:	53                   	push   %rbx
  8004215e74:	48 83 ec 18          	sub    $0x18,%rsp
  8004215e78:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004215e7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215e80:	8b 00                	mov    (%rax),%eax
  8004215e82:	85 c0                	test   %eax,%eax
  8004215e84:	74 47                	je     8004215ecd <holding+0x5e>
  8004215e86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215e8a:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004215e8e:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004215e95:	00 00 00 
  8004215e98:	ff d0                	callq  *%rax
  8004215e9a:	48 98                	cltq   
  8004215e9c:	48 89 c2             	mov    %rax,%rdx
  8004215e9f:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004215ea6:	00 
  8004215ea7:	48 89 c2             	mov    %rax,%rdx
  8004215eaa:	48 89 d0             	mov    %rdx,%rax
  8004215ead:	48 c1 e0 04          	shl    $0x4,%rax
  8004215eb1:	48 29 d0             	sub    %rdx,%rax
  8004215eb4:	48 ba 20 50 36 04 80 	movabs $0x8004365020,%rdx
  8004215ebb:	00 00 00 
  8004215ebe:	48 01 d0             	add    %rdx,%rax
  8004215ec1:	48 39 c3             	cmp    %rax,%rbx
  8004215ec4:	75 07                	jne    8004215ecd <holding+0x5e>
  8004215ec6:	b8 01 00 00 00       	mov    $0x1,%eax
  8004215ecb:	eb 05                	jmp    8004215ed2 <holding+0x63>
  8004215ecd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215ed2:	48 83 c4 18          	add    $0x18,%rsp
  8004215ed6:	5b                   	pop    %rbx
  8004215ed7:	5d                   	pop    %rbp
  8004215ed8:	c3                   	retq   

0000008004215ed9 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004215ed9:	55                   	push   %rbp
  8004215eda:	48 89 e5             	mov    %rsp,%rbp
  8004215edd:	48 83 ec 10          	sub    $0x10,%rsp
  8004215ee1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004215ee5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004215ee9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215eed:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004215ef3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215ef7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004215efb:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004215eff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215f03:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004215f0a:	00 
#endif
}
  8004215f0b:	90                   	nop
  8004215f0c:	c9                   	leaveq 
  8004215f0d:	c3                   	retq   

0000008004215f0e <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004215f0e:	55                   	push   %rbp
  8004215f0f:	48 89 e5             	mov    %rsp,%rbp
  8004215f12:	53                   	push   %rbx
  8004215f13:	48 83 ec 18          	sub    $0x18,%rsp
  8004215f17:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004215f1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215f1f:	48 89 c7             	mov    %rax,%rdi
  8004215f22:	48 b8 6f 5e 21 04 80 	movabs $0x8004215e6f,%rax
  8004215f29:	00 00 00 
  8004215f2c:	ff d0                	callq  *%rax
  8004215f2e:	85 c0                	test   %eax,%eax
  8004215f30:	74 46                	je     8004215f78 <spin_lock+0x6a>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004215f32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215f36:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004215f3a:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004215f41:	00 00 00 
  8004215f44:	ff d0                	callq  *%rax
  8004215f46:	49 89 d8             	mov    %rbx,%r8
  8004215f49:	89 c1                	mov    %eax,%ecx
  8004215f4b:	48 ba 60 8b 21 04 80 	movabs $0x8004218b60,%rdx
  8004215f52:	00 00 00 
  8004215f55:	be 41 00 00 00       	mov    $0x41,%esi
  8004215f5a:	48 bf 8a 8b 21 04 80 	movabs $0x8004218b8a,%rdi
  8004215f61:	00 00 00 
  8004215f64:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215f69:	49 b9 9b 04 20 04 80 	movabs $0x800420049b,%r9
  8004215f70:	00 00 00 
  8004215f73:	41 ff d1             	callq  *%r9

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
		asm volatile ("pause");
  8004215f76:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004215f78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215f7c:	be 01 00 00 00       	mov    $0x1,%esi
  8004215f81:	48 89 c7             	mov    %rax,%rdi
  8004215f84:	48 b8 b1 5d 21 04 80 	movabs $0x8004215db1,%rax
  8004215f8b:	00 00 00 
  8004215f8e:	ff d0                	callq  *%rax
  8004215f90:	85 c0                	test   %eax,%eax
  8004215f92:	75 e2                	jne    8004215f76 <spin_lock+0x68>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004215f94:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  8004215f9b:	00 00 00 
  8004215f9e:	ff d0                	callq  *%rax
  8004215fa0:	48 98                	cltq   
  8004215fa2:	48 89 c2             	mov    %rax,%rdx
  8004215fa5:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
  8004215fac:	00 
  8004215fad:	48 89 c2             	mov    %rax,%rdx
  8004215fb0:	48 89 d0             	mov    %rdx,%rax
  8004215fb3:	48 c1 e0 04          	shl    $0x4,%rax
  8004215fb7:	48 29 d0             	sub    %rdx,%rax
  8004215fba:	48 ba 20 50 36 04 80 	movabs $0x8004365020,%rdx
  8004215fc1:	00 00 00 
  8004215fc4:	48 01 c2             	add    %rax,%rdx
  8004215fc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215fcb:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004215fcf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215fd3:	48 83 c0 18          	add    $0x18,%rax
  8004215fd7:	48 89 c7             	mov    %rax,%rdi
  8004215fda:	48 b8 d6 5d 21 04 80 	movabs $0x8004215dd6,%rax
  8004215fe1:	00 00 00 
  8004215fe4:	ff d0                	callq  *%rax
#endif
}
  8004215fe6:	90                   	nop
  8004215fe7:	48 83 c4 18          	add    $0x18,%rsp
  8004215feb:	5b                   	pop    %rbx
  8004215fec:	5d                   	pop    %rbp
  8004215fed:	c3                   	retq   

0000008004215fee <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004215fee:	55                   	push   %rbp
  8004215fef:	48 89 e5             	mov    %rsp,%rbp
  8004215ff2:	41 54                	push   %r12
  8004215ff4:	53                   	push   %rbx
  8004215ff5:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004215ffc:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004216003:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421600a:	48 89 c7             	mov    %rax,%rdi
  800421600d:	48 b8 6f 5e 21 04 80 	movabs $0x8004215e6f,%rax
  8004216014:	00 00 00 
  8004216017:	ff d0                	callq  *%rax
  8004216019:	85 c0                	test   %eax,%eax
  800421601b:	0f 85 d8 01 00 00    	jne    80042161f9 <spin_unlock+0x20b>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004216021:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216028:	48 8d 48 18          	lea    0x18(%rax),%rcx
  800421602c:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004216033:	ba 28 00 00 00       	mov    $0x28,%edx
  8004216038:	48 89 ce             	mov    %rcx,%rsi
  800421603b:	48 89 c7             	mov    %rax,%rdi
  800421603e:	48 b8 02 ed 20 04 80 	movabs $0x800420ed02,%rax
  8004216045:	00 00 00 
  8004216048:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  800421604a:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216051:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216055:	48 85 c0             	test   %rax,%rax
  8004216058:	75 39                	jne    8004216093 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  800421605a:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216061:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216065:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  800421606c:	00 00 00 
  800421606f:	ff d0                	callq  *%rax
  8004216071:	48 89 da             	mov    %rbx,%rdx
  8004216074:	89 c6                	mov    %eax,%esi
  8004216076:	48 bf a0 8b 21 04 80 	movabs $0x8004218ba0,%rdi
  800421607d:	00 00 00 
  8004216080:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216085:	48 b9 0a 8e 20 04 80 	movabs $0x8004208e0a,%rcx
  800421608c:	00 00 00 
  800421608f:	ff d1                	callq  *%rcx
  8004216091:	eb 4d                	jmp    80042160e0 <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004216093:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421609a:	48 8b 40 10          	mov    0x10(%rax),%rax
  800421609e:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  80042160a1:	44 0f b6 e0          	movzbl %al,%r12d
  80042160a5:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042160ac:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042160b0:	48 b8 73 5b 21 04 80 	movabs $0x8004215b73,%rax
  80042160b7:	00 00 00 
  80042160ba:	ff d0                	callq  *%rax
  80042160bc:	44 89 e1             	mov    %r12d,%ecx
  80042160bf:	48 89 da             	mov    %rbx,%rdx
  80042160c2:	89 c6                	mov    %eax,%esi
  80042160c4:	48 bf e0 8b 21 04 80 	movabs $0x8004218be0,%rdi
  80042160cb:	00 00 00 
  80042160ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042160d3:	49 b8 0a 8e 20 04 80 	movabs $0x8004208e0a,%r8
  80042160da:	00 00 00 
  80042160dd:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042160e0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042160e7:	e9 c9 00 00 00       	jmpq   80042161b5 <spin_unlock+0x1c7>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  80042160ec:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042160ef:	48 98                	cltq   
  80042160f1:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042160f8:	89 c2                	mov    %eax,%edx
  80042160fa:	48 8d 85 10 fb ff ff 	lea    -0x4f0(%rbp),%rax
  8004216101:	48 89 c6             	mov    %rax,%rsi
  8004216104:	48 89 d7             	mov    %rdx,%rdi
  8004216107:	48 b8 f0 d8 20 04 80 	movabs $0x800420d8f0,%rax
  800421610e:	00 00 00 
  8004216111:	ff d0                	callq  *%rax
  8004216113:	85 c0                	test   %eax,%eax
  8004216115:	78 71                	js     8004216188 <spin_unlock+0x19a>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216117:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421611a:	48 98                	cltq   
  800421611c:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004216123:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004216125:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  800421612c:	48 29 c2             	sub    %rax,%rdx
  800421612f:	49 89 d0             	mov    %rdx,%r8
  8004216132:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  8004216139:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  800421613f:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  8004216145:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  800421614c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421614f:	48 98                	cltq   
  8004216151:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216158:	48 83 ec 08          	sub    $0x8,%rsp
  800421615c:	41 50                	push   %r8
  800421615e:	49 89 f9             	mov    %rdi,%r9
  8004216161:	41 89 f0             	mov    %esi,%r8d
  8004216164:	89 c6                	mov    %eax,%esi
  8004216166:	48 bf 16 8c 21 04 80 	movabs $0x8004218c16,%rdi
  800421616d:	00 00 00 
  8004216170:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216175:	49 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%r10
  800421617c:	00 00 00 
  800421617f:	41 ff d2             	callq  *%r10
  8004216182:	48 83 c4 10          	add    $0x10,%rsp
  8004216186:	eb 29                	jmp    80042161b1 <spin_unlock+0x1c3>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004216188:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421618b:	48 98                	cltq   
  800421618d:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216194:	89 c6                	mov    %eax,%esi
  8004216196:	48 bf 2d 8c 21 04 80 	movabs $0x8004218c2d,%rdi
  800421619d:	00 00 00 
  80042161a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161a5:	48 ba 0a 8e 20 04 80 	movabs $0x8004208e0a,%rdx
  80042161ac:	00 00 00 
  80042161af:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042161b1:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042161b5:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042161b9:	7f 14                	jg     80042161cf <spin_unlock+0x1e1>
  80042161bb:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042161be:	48 98                	cltq   
  80042161c0:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042161c7:	85 c0                	test   %eax,%eax
  80042161c9:	0f 85 1d ff ff ff    	jne    80042160ec <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  80042161cf:	48 ba 35 8c 21 04 80 	movabs $0x8004218c35,%rdx
  80042161d6:	00 00 00 
  80042161d9:	be 6b 00 00 00       	mov    $0x6b,%esi
  80042161de:	48 bf 8a 8b 21 04 80 	movabs $0x8004218b8a,%rdi
  80042161e5:	00 00 00 
  80042161e8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161ed:	48 b9 9b 04 20 04 80 	movabs $0x800420049b,%rcx
  80042161f4:	00 00 00 
  80042161f7:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  80042161f9:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216200:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004216207:	00 
	lk->cpu = 0;
  8004216208:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421620f:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004216216:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  8004216217:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421621e:	be 00 00 00 00       	mov    $0x0,%esi
  8004216223:	48 89 c7             	mov    %rax,%rdi
  8004216226:	48 b8 b1 5d 21 04 80 	movabs $0x8004215db1,%rax
  800421622d:	00 00 00 
  8004216230:	ff d0                	callq  *%rax
}
  8004216232:	90                   	nop
  8004216233:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  8004216237:	5b                   	pop    %rbx
  8004216238:	41 5c                	pop    %r12
  800421623a:	5d                   	pop    %rbp
  800421623b:	c3                   	retq   
